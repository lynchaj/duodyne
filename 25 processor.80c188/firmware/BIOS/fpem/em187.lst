     1                                  ; em187.asm -- special emulator for 80186/80187
     2                                  ;
     3                                  %define ABSLOAD 1
     4                                  %define even align 2
     5                                  
     6                                  ;;;        .list		; ignored by Watcom ASSembler
     7                                  ;page 64,160
     8                                  	cpu	186	;        .186
     9                                  
    10                                  
    11                                  %ifdef   LONG
    12                                             ; use BIG=1 to assemble for 64 bit mantissa
    13                                  %define BIG 1
    14                                  %else
    15                                             ; use BIG=0 to assemble for 32 bit mantissa
    16                                  %define BIG 0
    17                                  %endif
    18                                  
    19                                  
    20                                   	segment	_TEXT public align=2 class='CODE'
    21                                  ;;;	segment EM187_DATA public align=2 class='DATA'
    22                                  
    23                                  %include "../config.asm"
    24                              <1> ;/*
    25                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                              <1> ; ANSI.CFG
    27                              <1> ;   Copied to CONFIG.ASM for general release.
    28                              <1> ;
    29                              <1> ;       Modify the parameters below to reflect your system
    30                              <1> ;
    31                              <1> ;
    32                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    33                              <1> ;
    34                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    35                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ;
    38                              <1> ; Define the serial terminal that the Video BIOS must emulate
    39                              <1> ; Set one of the following to 1
    40                              <1> ; If you have no idea what to choose, set TTY to 1
    41                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    42                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    43                              <1> ANSI    equ     1       ; very smart, like a VT-100
    44                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    45                              <1> ; others may get added in the future
    46                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    47                              <1> ;
    48                              <1> ; Does the hardware configuration contain the Color Video Display Unit?
    49                              <1> ; Both the 8563 and the 8242 are used.  The default is CVDU=0
    50                              <1> CVDU	equ	0	; system does not have the CVDU
    51                              <1> ;
    52                              <1> ; Does the hardware configuration contain the VGA3 a/n Video card?
    53                              <1> ; The 8563 will be disabled, but the 8242 code is shared with the CVDU
    54                              <1> ; The default is VGA3=0
    55                              <1> VGA3    equ     0       ; system does not have the VGA3
    56                              <1> %if 0
    57                              <1> 	*/
    58                              <1> #define VGA3 0
    59                              <1> /*
    60                              <1> %endif
    61                              <1> ;
    62                              <1> ; Boot up keyboard mode:  20h for NumLock on
    63                              <1> ;CVDU_KEYBOARD_STATUS	equ	0	; NumLock OFF
    64                              <1> CVDU_KEYBOARD_STATUS	equ	20h	; NumLock ON
    65                              <1> 
    66                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    67                              <1> ;UART_RATE	equ	0		; 1200
    68                              <1> ;UART_RATE	equ	1		; 2400
    69                              <1> ;UART_RATE	equ	2		; 4800
    70                              <1> UART_RATE	equ	3		; 9600
    71                              <1> ;UART_RATE	equ	4		; 19200
    72                              <1> ;UART_RATE	equ	5		; 38400
    73                              <1> ;UART_RATE	equ	6		; 57600
    74                              <1> ;UART_RATE	equ	7		; 115200
    75                              <1> 
    76                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    77                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    78                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    79                              <1> 						; but not ANSI
    80                              <1> ; Define the size of the ROM image on the system in Kilobytes
    81                              <1> ; It may be smaller than the actual EPROM in use.
    82                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    83                              <1> %ifndef ROM
    84                              <1> ROM             equ     32              ; 64 is the default
    85                              <1> %endif
    86                              <1> 
    87                              <1> ; Define the number of Wait States at which the ROM operates
    88                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    89                              <1> 
    90                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    91                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    92                              <1> RAM_DOS         equ     640
    93                              <1> 
    94                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    95                              <1> ; the default is 512 kilobytes
    96                              <1> RAM             equ     512             ; (512 is the default)
    97                              <1> 
    98                              <1> ; Define the number of Wait States at which the RAM operates
    99                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
   100                              <1> 
   101                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
   102                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
   103                              <1> 
   104                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
   105                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
   106                              <1> 
   107                              <1> ; Define the time zone in which we build the Relocatable BIOS
   108                              <1> %ifndef TIMEZONE
   109                              <1> %define TIMEZONE "CST"
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Has the REDBUG debugger been loaded?
   113                              <1> %ifndef SOFT_DEBUG
   114                              <1> %define SOFT_DEBUG 0
   115                              <1> %endif
   116                              <1> 
   117                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   118                              <1> %ifndef TBASIC
   119                              <1> TBASIC          equ     1		; default is 1
   120                              <1> %endif
   121                              <1> 
   122                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   123                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   124                              <1> %ifndef FPEM
   125                              <1> FPEM            equ     1               ; default is 1
   126                              <1> %endif
   127                              <1> 
   128                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   129                              <1> EMM_BOARDS      equ     0
   130                              <1> 
   131                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   132                              <1> ; or at locations 0280h..3FFh in low memory?
   133                              <1> %if SOFT_DEBUG
   134                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   135                              <1> %else
   136                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   137                              <1> %endif
   138                              <1> 
   139                              <1> ; Define the size of the EPROM that is to be installed on the system
   140                              <1> ; It may be larger than the actual ROM image to be generated.
   141                              <1> %ifndef CHIP
   142                              <1> CHIP            equ     64
   143                              <1> %endif
   144                              <1> 
   145                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   146                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   147                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   148                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   149                              <1> 
   150                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   151                              <1> ; If the wiring update is installed, or you have a later board, then
   152                              <1> ; set this to 0.  If you are using the software workaround, then set this
   153                              <1> ; to 1.  The rev 1.0 board has this fix already.
   154                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   155                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   156                              <1> 
   157                              <1> ; Define the UART oscillator speed
   158                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   159                              <1> 
   160                              <1> 
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> ; end of the User configuration
   163                              <1> ;       Do Not modify anything below this point
   164                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   165                              <1> 
   166                              <1> CVDU_8563	equ	CVDU		; separate inits
   167                              <1> CVDU_8242	equ	CVDU|VGA3 	; separate inits
   168                              <1> VGA3_6445       equ     VGA3            ; separate inits
   169                              <1> ; Suppress all UART output in color video Mode 3
   170                              <1> UART_MODE3_SUPPRESS	equ	CVDU_8563
   171                              <1> CVDU_USE_MSDOS_KLUDGE	equ	0; CVDU_8242	; bad, bad MSDOS
   172                              <1> CVDU_USE_KBD_HOOK		equ	CVDU_8242
   173                              <1> 
   174                              <1> ; Define existence of any uart chip
   175                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   176                              <1> startuplength   equ     512                     ; may be up to 1024
   177                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   178                              <1> highrom         equ     (ROM*400h)&0FFFFh
   179                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   180                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   181                              <1> 
   182                              <1> 
   183                              <1> %define ARG(n) [bp+2+(n)*2]
   184                              <1> 
   185                              <1> %macro  check   1.nolist
   186                              <1>  %if (%1)
   187                              <1>    %error Check Failure: %1
   188                              <1>  %endif
   189                              <1> %endm
   190                              <1> %macro  range   3.nolist
   191                              <1>  %if (%1)<(%2)
   192                              <1>    %error Out of Range: %1
   193                              <1>  %elif (%1)>(%3)
   194                              <1>    %error Out of Range: %1
   195                              <1>  %endif
   196                              <1> %endm
   197                              <1> _terminal equ UART+CVDU
   198                              <1>  check   RAM_DOS&15
   199                              <1>  check   RAM&(RAM-1)
   200                              <1>  check   ROM&(ROM-1)
   201                              <1>  range   RAM,32,512
   202                              <1>  range   ROM,32,256
   203                              <1>  range   RAM_WS,0,3
   204                              <1>  range   ROM_WS,0,3
   205                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   206                              <1>  range   LCL_IO_WS,0,3
   207                              <1>  range   BUS_IO_WS,0,3
   208                              <1>  range   UART_OSC,500000,16000000
   209                              <1>  range   UART_RATE,0,7
   210                              <1>  range	 UART,0,1
   211                              <1>  range	 _terminal,1,2
   212                              <1> 
   213                              <1> %ifndef SOFT_DEBUG
   214                              <1> %define SOFT_DEBUG 0
   215                              <1> %endif
   216                              <1> 
   217                              <1> %ifndef TRACE
   218                              <1> %define TRACE 0
   219                              <1> %endif
   220                              <1> 
   221                              <1> %ifdef MAKE_OBJECT_FILE
   222                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   223                              <1>         export _ROMsize
   224                              <1>         export _CHIPsize
   225                              <1> _ROMsize        dw      ROM
   226                              <1> _CHIPsize       dw      CHIP
   227                              <1> %endif
   228                              <1> ; end of the Hardware configuration file
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> ;*/
    24                                  %include "../bda.inc"
    25                              <1> ;/*======================================================================
    26                              <1> ; bda.inc -- BIOS data area definitions
    27                              <1> ;========================================================================
    28                              <1> ;   for the N8VEM SBC-188
    29                              <1> ;
    30                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    31                              <1> ;
    32                              <1> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    33                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    34                              <1> ;
    35                              <1> ; This program is free software: you can redistribute it and/or modify
    36                              <1> ; it under the terms of the GNU General Public License as published by
    37                              <1> ; the Free Software Foundation, either version 3 of the License, or
    38                              <1> ; (at your option) any later version.
    39                              <1> ;
    40                              <1> ; This program is distributed in the hope that it will be useful,
    41                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    42                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    43                              <1> ; GNU General Public License for more details.
    44                              <1> ;
    45                              <1> ; You should have received a copy of the GNU General Public License
    46                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    47                              <1> ;
    48                              <1> ;========================================================================
    49                              <1> 
    50                              <1> 			;*/ extern				/*
    51                              <1> 	ABSOLUTE  0	;*/ struct BDA {			/*
    52 00000000 ????????????????    <1> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
    53 00000008 ????????????????    <1> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
    54 00000010 ????                <1> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
    55                              <1> ;	dw	?		; 40:10 	; Equipment present word
    56                              <1> ;  						;  = (1 iff floppies) *     1.
    57                              <1> ;                                               ;  + (1 iff 187     ) *     2.
    58                              <1> ;  						;  + (#+1 64K sys ram) *    4.
    59                              <1> ;  						;  + (init crt mode ) *    16.
    60                              <1> ;  						;  + (# of floppies ) *    64.
    61                              <1> ;  						;  + (# serial ports) *   512.
    62                              <1> ;  						;  + (1 iff toy port) *  4096.
    63                              <1> ;                                               ;  + (1 iff modem   ) *  8192.
    64                              <1> ;  						;  + (# parallel LPT) * 16384.
    65 00000012 ??                  <1> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
    66 00000013 ????                <1> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
    67                              <1> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
    68 00000015 ??                  <1> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
    69 00000016 ??                  <1> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
    70                              <1> ;;---------------[Keyboard data area]------------;
    71 00000017 ????                <1> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
    72                              <1> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
    73 00000019 ??                  <1> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
    74 0000001A ????                <1> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
    75 0000001C ????                <1> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
    76 0000001E <res 20h>           <1> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
    77                              <1> kbd_buffer_last	equ	$	;*/				/*
    78                              <1> ;;---------------[Diskette data area]------------;
    79 0000003E ??                  <1> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
    80 0000003F ??                  <1> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
    81 00000040 ??                  <1> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
    82 00000041 ??                  <1> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
    83                              <1> ;				Floppy return code stat byte
    84                              <1> ;				;  1 = bad ic 765 command req.
    85                              <1> ;				;  2 = address mark not found
    86                              <1> ;				;  3 = write to protected disk
    87                              <1> ;				;  4 = sector not found
    88                              <1> ;				;  8 = data late (DMA overrun)
    89                              <1> ;				;  9 = DMA failed 64K page end
    90                              <1> ;				; 16 = bad CRC on floppy read
    91                              <1> ;				; 32 = bad NEC 765 controller
    92                              <1> ;				; 64 = seek operation failed
    93                              <1> ;				;128 = disk drive timed out
    94 00000042 ??????????????      <1> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
    95                              <1> ;;---------------[Video display area]------------;
    96 00000049 ??                  <1> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
    97                              <1> ;			 	; Current CRT mode  (software)
    98                              <1> ;				;  0 = 40 x 25 text (no color)
    99                              <1> ;				;  1 = 40 x 25 text (16 color)
   100                              <1> ;				;  2 = 80 x 25 text (no color)
   101                              <1> ;				;  3 = 80 x 25 text (16 color)
   102                              <1> ;				;  4 = 320 x 200 grafix 4 color
   103                              <1> ;				;  5 = 320 x 200 grafix 0 color
   104                              <1> ;				;  6 = 640 x 200 grafix 0 color
   105                              <1> ;				;  7 = 80 x 25 text (mono card)
   106 0000004A ????                <1> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   107 0000004C ????                <1> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   108 0000004E ????                <1> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   109 00000050 <res 10h>           <1> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   110 00000060 ????                <1> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   111 00000062 ??                  <1> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   112 00000063 ????                <1> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   113 00000065 ??                  <1> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   114 00000066 ??                  <1> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   115                              <1> ;;---------------[Used to setup ROM]-------------;
   116 00000067 ????????            <1> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   117 0000006B ??                  <1> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   118                              <1> ;;---------------[Timer data area]---------------;
   119 0000006C ????????            <1> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   120 00000070 ??                  <1> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   121                              <1> ;;---------------[System data area]--------------;
   122 00000071 ??                  <1> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   123 00000072 ????                <1> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   124                              <1> ;;---------------[Hard disk scratchpad]----------;
   125 00000074 ????????            <1> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   126                              <1> ;;---------------[Timout areas/PRT/LPT]----------;
   127 00000078 ????????            <1> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   128 0000007C ????????            <1> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   129                              <1> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   130 00000080 ????                <1> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   131 00000082 ????                <1> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   132                              <1> ;;---------------[EGA stuff]---------------------;
   133 00000084 ??????????????      <1> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   134                              <1> ;;---------------[Floppy/Fixed Media Info]-------------;
   135 0000008B ??                  <1> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   136 0000008C ????????            <1> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   137 00000090 ????                <1> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   138 00000092 ????                <1> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   139 00000094 ????                <1> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   140                              <1> ;;---------------[Additional KBD flags]----------------;
   141 00000096 ??                  <1> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   142 00000097 ??                  <1> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   143                              <1> ;;---------------[RTC/timer1 data]---------------------;
   144 00000098 ????????            <1> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   145 0000009C ????????            <1> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   146 000000A0 ??                  <1> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   147                              <1> ;;---------------[Cassette I/O stuff]------------------;
   148 000000A1 ??                  <1> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   149 000000A2 ????                <1> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   150                              <1> ;									Post Acknowleged=00;
   151 000000A4 ??                  <1> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   152 000000A5 ????                <1> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   153 000000A7 ????                <1> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   154                              <1> ;
   155 000000A9 ????????            <1> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   156 000000AD ??                  <1> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   157 000000AE ??                  <1> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   158 000000AF ??                  <1> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   159                              <1> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   160 000000B0 ????                <1> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   161 000000B2 ??                  <1> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   162 000000B3 ??                  <1> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   163 000000B4 ??                  <1> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   164 000000B5 ????                <1> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   165 000000B7 ??                  <1> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   166 000000B8 ??                  <1> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   167 000000B9 ????                <1> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   168 000000BB ??                  <1> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   169 000000BC ????                <1> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   170 000000BE ??                  <1> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   171 000000BF ??                  <1> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   172 000000C0 <res 10h>           <1> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   173 000000D0 <res 10h>           <1> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   174 000000E0 <res 10h>           <1> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   175                              <1> ;
   176                              <1> ;
   177                              <1> 
   178 000000F0 ????                <1> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   179                              <1> 
   180 000000F2 ????                <1> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   181                              <1> 
   182 000000F4 ????                <1> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   183 000000F6 ????                <1> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   184                              <1> 
   185 000000F8 ????                <1> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   186                              <1> 
   187 000000FA ????????            <1> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   188                              <1> 
   189 000000FE ??                  <1> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   190                              <1> 
   191 000000FF ??                  <1> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   192                              <1> ;								   CPU clock is half of this
   193                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   194                              <1> ;
   195                              <1> ;  System configuration stuff below
   196                              <1> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   197                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   198                              <1> %if 0				;*/
   199                              <1> #define FIXED_DISK_MAX 4		/*
   200                              <1> %else
   201                              <1> %define FIXED_DISK_MAX 4
   202                              <1> %endif
   203                              <1> %if 0				;*/
   204                              <1> #define PPIDE_driver 1		/*
   205                              <1> %else
   206                              <1> %define PPIDE_driver 1
   207                              <1> %endif
   208                              <1> %if 0				;*/
   209                              <1> #define DIDE_driver 0		/*
   210                              <1> %else
   211                              <1> %define DIDE_driver 0
   212                              <1> %endif
   213                              <1> %if 0				;*/
   214                              <1> #define DISKIO_driver 1		/*
   215                              <1> %else
   216                              <1> %define DISKIO_driver 1
   217                              <1> %endif
   218                              <1> %if 0				;*/
   219                              <1> #define MFPIC_driver 1		/*
   220                              <1> %else
   221                              <1> %define MFPIC_driver 1
   222                              <1> %endif
   223                              <1> %if 0				;*/
   224                              <1> #define DSD_driver 1		/*
   225                              <1> %else
   226                              <1> %define DSD_driver 1
   227                              <1> %endif
   228                              <1> %if 0				;*/
   229                              <1> #define V3IDE8_driver (SBC188==3)		/*
   230                              <1> %else
   231                              <1> %define V3IDE8_driver (SBC188==3)
   232                              <1> %endif
   233                              <1> 				;*/
    25                                  %include  "em187d.asm"
    26                              <1> ; em187d.asm -- definitions for em187.asm
    27                              <1> 
    28                              <1> ; define the structure of a floating point accumulator
    29                              <1> 
    30                              <1> ;ACCUM   struc
    31                              <1> 	struc	ACCUM
    32 00000000 ??                  <1> tag     resb	1
    33 00000001 ??                  <1> sign    resb	1
    34 00000002 ????                <1> expon   resw	1
    35 00000004 ????                <1> mantis  resw	1           ; high order word in low address
    36 00000006 ????                <1>         resw	1
    37                              <1> %if  BIG
    38 00000008 ????                <1>         resw	1           ; lower order words in higher addresses
    39 0000000A ????                <1>         resw	1
    40                              <1> %endif
    41                              <1> lenACCUM	equ	$
    42                              <1> ;ACCUM   ends
    43                              <1> ;	endstruc
    44                              <1> 
    45                              <1> ; define the condition code bits
    46                              <1> C3      equ     40H
    47                              <1> C2      equ     04H
    48                              <1> C1      equ     02H
    49                              <1> C0      equ     01H
    50                              <1> 
    51                              <1> ; define the tag conditions
    52                              <1> tag_valid   equ     0
    53                              <1> tag_zero    equ     1
    54                              <1> tag_infin   equ     2
    55                              <1> tag_empty   equ     3
    56                              <1> tag_invalid equ     6
    57                              <1> 
    58                              <1> ;define the funny exponent internal zero has
    59                              <1> exp_of_FPzero   equ   8001H         ;minimum negative number
    60                              <1> exp_of_FPinf    equ   7FFFH         ;maximum positive number
    61                              <1> 
    62                              <1> ;define the instruction bits
    63                              <1> Rbit        equ     4               ;reverse source and destination
    64                              <1> Pbit        equ     2               ;pop bit
    65                              <1> FMbits      equ     6               ;memory format bits
    66                              <1> 
    67                              <1> ;define the exception bits
    68                              <1> Iexcept     equ     1       ;invalid operation
    69                              <1> Dexcept     equ     2       ;denormalized operand
    70                              <1> Zexcept     equ     4       ;zero divide
    71                              <1> Oexcept     equ     8       ;overflow
    72                              <1> Uexcept     equ    10h      ;underflow
    73                              <1> Pexcept     equ    20h      ;precision
    74                              <1> 
    75                              <1> Sflag       equ    40h      ;stack flag     (new with 80187)
    76                              <1> Estatus     equ    80h      ;error summary status
    77                              <1> 
    78                              <1> ;define the high order error codes
    79                              <1> errUnemulated   equ     0100h   ;unemulated operation
    80                              <1> errSqrt         equ     0200h   ;error in SQRT
    81                              <1> ;unassigned
    82                              <1> errStkOverflow  equ     0800h   ;
    83                              <1> errStkUnderflow equ     1000h   ;
    84                              <1> 
    85                              <1> ;define the layout of the saved registers
    86                              <1> v7_regs equ   0
    87                              <1> v7_ds   equ     v7_regs
    88                              <1> v7_ss   equ     v7_ds+2
    89                              <1> v7_es   equ     v7_ss+2
    90                              <1> 
    91                              <1> v7_di   equ     v7_es+2
    92                              <1> v7_si   equ     v7_di+2
    93                              <1> v7_bp   equ     v7_si+2
    94                              <1> v7_sp   equ     v7_bp+2
    95                              <1> v7_bx   equ     v7_sp+2
    96                              <1> v7_dx   equ     v7_bx+2
    97                              <1> v7_cx   equ     v7_dx+2
    98                              <1> v7_ax   equ     v7_cx+2
    99                              <1> 
   100                              <1> v7_ip   equ     v7_ax+2
   101                              <1> v7_cs   equ     v7_ip+2
   102                              <1> v7_flag equ     v7_cs+2
   103                              <1> 
   104                              <1> CR      equ     0dH             ;carriage return
   105                              <1> LF      equ     0aH             ;line feed
   106                              <1> 
   107                              <1> ; end em187d.asm
    26                                  
    27                                  
    28                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                                  ;  The following are handled by "bda.inc"
    30                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                                  
    32                                  ;bios_data_seg	equ	40h	; BIOS data area segment
    33                                  
    34                                  ;  FPEM_segment	equ	0E6h	; use '../sizer' to determine
    35                                  ;        extrn  FPEM_segment:near
    36                                  
    37                                  
    38                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                                  ;  Offsets in the EM187 data area are all
    40                                  ;    relative to the segment address
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;;;	segment	EM187_DATA
    43                                  	absolute  0
    44                                  ;
    45                                  ; the order:  Control, then Status may be important in the future
    46                                  ;  for FSTENV, FLDENV
    47                                  ;
    48                                  ;Control label   word
    49                                  Control:
    50 00000000 ??                      masks   resb	1               ; interrupt masks (see 'enables', below)
    51 00000001 ??                      ctrl    resb	1               ; high order control bytes
    52                                  
    53                                  ;Status  label   word
    54                                  Status:
    55 00000002 ??                      flags   resb	1               ; error flags
    56 00000003 ??                      codes   resb	1               ; condition codes
    57                                  
    58                                  ; the Tag word bits are distributed through the Accumulator data structure
    59                                  
    60 00000004 ????                    save_ip:  resw	1		; IP of instruction causing exception
    61 00000006 ????                    save_cs:  resw	1		; CS of ditto
    62 00000008 ????                    data_offset:	resw	1
    63 0000000A ????                    data_segment:	resw	1	; Data address in full
    64 0000000C ????                    instruct    resw	1               ; copy of instruction saved here
    65 0000000E ????                    round       resw	1               ; rounding control bits times 2 (0,2,4,6)
    66 00000010 ??                      tos     resb	1               ; top of stack ptr
    67 00000011 ??                      enables resb	1               ;interrupts that are enabled (not 'masks')
    68                                  
    69                                  nFINIT	equ	($-Status)/2	; number of WORDs to clear
    70                                  
    71                                  ;guard_sticky  label word
    72                                  guard_sticky:
    73 00000012 ??                      sticky  resb	1               ;sticky if any bits set
    74 00000013 ??                      guard   resb	1               ;guard bit in bit7
    75                                  
    76                                  %if BIG
    77 00000014 ????                    mptr    resw	1               ;multiplicand pointer
    78                                  %endif
    79                                  
    80 00000016 ????                    trptr   resw	1               ;transcendental pointer
    81 00000018 ????                    trptr2  resw	1
    82                                  
    83 0000001A ??                      ctr     resb	1               ;loop counter for MUL/DIV and FBLD
    84                                  
    85 0000001B ??                      trctr   resb	1               ;transcendental counter
    86                                  
    87                                  ;mtemp   dw      8 dup (?)       ;mantissa temporary for 64x64 bit multiplication
    88 0000001C <res 10h>               mtemp	resw	8
    89                                  
    90                                  
    91                                  ;Areg    ACCUM   <>
    92 0000002C <res Ch>                Areg	resb	lenACCUM
    93                                  lenAccum    equ     $-Areg
    94                                  ;Breg    ACCUM   <>
    95 00000038 <res Ch>                Breg	resb	lenACCUM
    96                                  
    97                                  %if BIG
    98                                     
    99                                  %define maxcon 19
   100                                  %else
   101                                  %define maxcon 11
   102                                  %endif
   103                                  
   104                                  ;fp0     ACCUM   <>
   105 00000044 <res Ch>                fp0	resb	lenACCUM
   106                                  ;fp1     ACCUM   <>
   107 00000050 <res Ch>                fp1	resb	lenACCUM
   108                                  ;fp2     ACCUM   <>
   109 0000005C <res Ch>                fp2	resb	lenACCUM
   110                                  ;fp3     ACCUM   <>
   111 00000068 <res Ch>                fp3	resb	lenACCUM
   112                                  ;fp4     ACCUM   <>
   113 00000074 <res Ch>                fp4	resb	lenACCUM
   114                                  ;fp5     ACCUM   <>
   115 00000080 <res Ch>                fp5	resb	lenACCUM
   116                                  ;fp6     ACCUM   <>
   117 0000008C <res Ch>                fp6	resb	lenACCUM
   118                                  ;fp7     ACCUM   <>
   119 00000098 <res Ch>                fp7	resb	lenACCUM
   120                                  
   121                                  
   122                                  ;Creg    ACCUM   maxcon DUP (<>)
   123                                  Creg	equ	$
   124                                  	%rep	maxcon
   125                                  	resb	lenACCUM
   126                                  	%endrep
   125 000000A4 <res Ch>            <1>  resb lenACCUM
   125 000000B0 <res Ch>            <1>  resb lenACCUM
   125 000000BC <res Ch>            <1>  resb lenACCUM
   125 000000C8 <res Ch>            <1>  resb lenACCUM
   125 000000D4 <res Ch>            <1>  resb lenACCUM
   125 000000E0 <res Ch>            <1>  resb lenACCUM
   125 000000EC <res Ch>            <1>  resb lenACCUM
   125 000000F8 <res Ch>            <1>  resb lenACCUM
   125 00000104 <res Ch>            <1>  resb lenACCUM
   125 00000110 <res Ch>            <1>  resb lenACCUM
   125 0000011C <res Ch>            <1>  resb lenACCUM
   125 00000128 <res Ch>            <1>  resb lenACCUM
   125 00000134 <res Ch>            <1>  resb lenACCUM
   125 00000140 <res Ch>            <1>  resb lenACCUM
   125 0000014C <res Ch>            <1>  resb lenACCUM
   125 00000158 <res Ch>            <1>  resb lenACCUM
   125 00000164 <res Ch>            <1>  resb lenACCUM
   125 00000170 <res Ch>            <1>  resb lenACCUM
   125 0000017C <res Ch>            <1>  resb lenACCUM
   127                                  lenCreg     equ     $-Creg
   128                                  
   129                                  ;        public  EM187_DATA_PARAS
   130                                  	global	EM187_DATA_PARAS
   131                                  EM187_DATA_PARAS  equ     ($-Control+15)/16
   132                                  
   133                                  ;EM187_DATA   ENDS
   134                                  
   135                                  
   136                                  ;        assume  cs:_TEXT, ds:EM187_DATA
   137                                  
   138                                  
   139                                  ;_TEXT SEGMENT
   140                                  	segment	_TEXT
   141                                  ;        assume  cs:_TEXT
   142                                  
   143                                  
   144                                  ; vector7 is entered when an ESC trap occurs, for any co-processor
   145                                  ;   instruction
   146                                  
   147                                  	global  vector7
   148                                  
   149                                  	even
   150                                  
   151                                  vector7:	;  proc    far
   152 00000000 FB                              sti             ;re-enable interrupts
   153                                  vector7a:
   154 00000001 60                              pusha           ;save all the registers
   155 00000002 06                              push    es      ; **
   156 00000003 16                              push    ss
   157 00000004 1E                              push    ds      ; the order of these push'es is important
   158 00000005 89E5                            mov     bp,sp   ;establish stack addressability
   159 00000007 8CD8                            mov     ax,ds   ;most used segment
   160 00000009 8EC0                            mov     es,ax   ;for argument address  ES:DI  -- used later
   161 0000000B FC                      	cld		;will return with IRET
   162                                  
   163 0000000C C57616                          lds     si,[v7_ip+bp]        ;get instruction stream pointer
   164                                  
   165                                  %ifdef DEBUG
   166                                          mov     bx,[insptr]               ;get trace pointer
   167                                          sub     bx,4
   168                                  ;;;        cmp     bx,offset trace
   169                                          cmp     bx,trace
   170                                          jae     nowrap
   171                                  ;;;        mov     bx,offset tracee-4
   172                                          mov     bx,tracee-4
   173                                  nowrap:
   174                                          mov     [insptr],bx               ;restore trace pointer
   175                                    cs    mov     word [bx],si      ;save IP of instruction
   176                                    cs    mov     word [bx+2],ds    ;save CS of instruction
   177                                          mov     [savesp],sp               ;save SP before pop
   178                                  %endif
   179                                  
   180                                  ; check for segment override prefix
   181                                  
   182 0000000F AC                              lodsb
   183 00000010 08C0                            or      al,al               ;test hi-bit of first byte
   184 00000012 7825                            js      vec002              ;not segment override
   185 00000014 88C3                            mov     bl,al               ;move prefix to BX
   186 00000016 D0EB                            shr     bl,1                ;shift two bits to position
   187 00000018 D0EB                            shr     bl,1                ;**
   188 0000001A 83E306                          and     bx,0006h            ;mask for vectored jump
   189 0000001D 2EFFA7[FE01]               cs   jmp     [override+bx]
   190                                  
   191                                  	even
   192                                  
   193                                  cs_over:
   194 00000022 8CD8                            mov     ax,ds               ;former CS to AX
   195 00000024 EB0D                            jmp     short vec001a       ;go continue
   196                                  	even
   197                                  ss_over:
   198 00000026 8CD0                            mov     ax,ss               ;set up override
   199 00000028 EB0C                            jmp     short vec001
   200                                  	even
   201                                  ds_over:
   202 0000002A 8B4600                          mov     ax,[v7_ds+bp]        ;get saved DS
   203 0000002D EB04                            jmp     short vec001a       ;go continue
   204 0000002F 90                      	even
   205                                  es_over:
   206 00000030 8B4604                          mov     ax,[v7_es+bp]        ;get saved ES
   207                                  
   208                                  vec001a:
   209 00000033 894602                          mov     [v7_ss+bp],ax        ;set for [bp] addressing
   210                                  vec001:
   211 00000036 8EC0                            mov     es,ax               ;set up override segment
   212                                  
   213                                  ; get first instruction byte
   214                                  
   215 00000038 AC                              lodsb                       ;get first instruction byte
   216                                  vec002:
   217                                  ;;;;;;;;;;;
   218                                  ;  check for FWAIT
   219 00000039 3C9B                    	cmp	al,9Bh		; FWAIT
   220 0000003B 7503E97601              	je	restore_segs
   221                                  ;;;;;;;;;;;
   222 00000040 88C5                            mov     ch,al               ;save first instr. byte in ch
   223 00000042 AC                              lodsb
   224 00000043 88C1                            mov     cl,al               ;save second in cl
   225                                  
   226                                  ; fast instruction decode
   227                                  
   228 00000045 89CB                            mov     bx,cx               ;get mod, op-B, r/m bits
   229 00000047 D0C3                            rol     bl,1                ;
   230 00000049 D0C3                            rol     bl,1                ;get  r/m, mod  in low 5 bits
   231                                  ; may want to save BX at this point
   232 0000004B 89DA                            mov     dx,bx               ;save BX in DX for now
   233 0000004D 83E31F                          and     bx,1Fh              ;mask to 5 bits
   234 00000050 D1E3                            shl     bx,1                ;set for word addressing
   235 00000052 2EFFA7[BE01]              cs    jmp     [adrmode+bx]         ;dispatch to proper address mode
   236                                  
   237                                  mod_0_10:                           ;[bx+si]+d16
   238 00000057 8B7E08                          mov     di,[v7_si+bp]
   239 0000005A 037E0E                          add     di,[v7_bx+bp]
   240 0000005D E9A100                          jmp     vvw
   241                                  
   242                                  mod_1_10:                           ;[bx+di]+d16
   243                                  ;;;        mov     di,[v7_di+bp]
   244 00000060 037E0E                          add     di,[v7_bx+bp]
   245 00000063 E99B00                          jmp     vvw
   246                                  
   247                                  mod_2_10:                           ;[bp+si]+d16
   248 00000066 8B7E08                          mov     di,[v7_si+bp]
   249 00000069 037E0A                          add     di,[v7_bp+bp]
   250 0000006C 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   251 0000006F E98F00                          jmp     vvw
   252                                  
   253                                  mod_0_01:                           ;[bx+si]+d8
   254 00000072 8B7E08                          mov     di,[v7_si+bp]
   255 00000075 037E0E                          add     di,[v7_bx+bp]
   256 00000078 AC                              lodsb
   257 00000079 98                              cbw
   258 0000007A E98500                          jmp     vvb
   259                                  
   260                                  mod_3_10:                           ;[bp+di]+d16
   261                                  ;;;        mov     di,[v7_di+bp]
   262 0000007D 037E0A                          add     di,[v7_bp+bp]
   263 00000080 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   264 00000083 EB7C                            jmp     vvw
   265                                  
   266                                  mod_1_01:                           ;[bx+di]+d8
   267                                  ;;;        mov     di,[v7_di+bp]
   268 00000085 037E0E                          add     di,[v7_bx+bp]
   269 00000088 AC                              lodsb
   270 00000089 98                              cbw
   271 0000008A EB76                            jmp     vvb
   272                                  
   273                                  mod_2_01:                           ;[bp+si]+d8
   274 0000008C 8B7E08                          mov     di,[v7_si+bp]
   275 0000008F 037E0A                          add     di,[v7_bp+bp]
   276 00000092 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   277 00000095 AC                              lodsb
   278 00000096 98                              cbw
   279 00000097 EB69                            jmp     short vvb
   280                                  
   281                                  mod_3_01:                           ;[bp+di]+d8
   282                                  ;;;        mov     di,[v7_di+bp]
   283 00000099 037E0A                          add     di,[v7_bp+bp]
   284 0000009C 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   285 0000009F AC                              lodsb
   286 000000A0 98                              cbw
   287 000000A1 EB5F                            jmp     short vvb
   288                                  
   289                                  mod_0_00:                           ;[bx+si]
   290 000000A3 8B7E08                          mov     di,[v7_si+bp]
   291 000000A6 037E0E                          add     di,[v7_bx+bp]
   292 000000A9 EB59                            jmp     short vvv
   293                                  
   294                                  mod_1_00:                           ;[bx+di]
   295                                  ;;;        mov     di,[v7_di+bp]
   296 000000AB 037E0E                          add     di,[v7_bx+bp]
   297 000000AE EB54                            jmp     short vvv
   298                                  
   299                                  mod_2_00:                           ;[bp+si]
   300 000000B0 8B7E08                          mov     di,[v7_si+bp]
   301 000000B3 037E0A                          add     di,[v7_bp+bp]
   302 000000B6 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   303 000000B9 EB49                            jmp     short vvv
   304                                  
   305                                  mod_3_00:                           ;[bp+di]
   306                                  ;;;        mov     di,[v7_di+bp]
   307 000000BB 037E0A                          add     di,[v7_bp+bp]
   308 000000BE 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   309 000000C1 EB41                            jmp     short vvv
   310                                  
   311                                  mod_4_01:                           ;[si]+d8
   312 000000C3 8B7E08                          mov     di,[v7_si+bp]
   313 000000C6 AC                              lodsb
   314 000000C7 98                              cbw
   315 000000C8 EB38                            jmp     short vvb
   316                                  
   317                                  mod_5_01:                           ;[di]+d8
   318                                  ;;;        mov     di,[v7_di+bp]
   319 000000CA AC                              lodsb
   320 000000CB 98                              cbw
   321 000000CC EB34                            jmp     short vvb
   322                                  
   323                                  mod_6_01:                           ;[bp]+d8
   324 000000CE 8B7E0A                          mov     di,[v7_bp+bp]
   325 000000D1 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   326 000000D4 AC                              lodsb
   327 000000D5 98                              cbw
   328 000000D6 EB2A                            jmp     short vvb
   329                                  
   330                                  mod_7_01:                           ;[bx]+d8
   331 000000D8 8B7E0E                          mov     di,[v7_bx+bp]
   332 000000DB AC                              lodsb
   333 000000DC 98                              cbw
   334 000000DD EB23                            jmp     short vvb
   335                                  
   336                                  mod_4_10:                           ;[si]+d16
   337 000000DF 8B7E08                          mov     di,[v7_si+bp]
   338 000000E2 EB1D                            jmp     short vvw
   339                                  
   340                                  mod_5_10:                           ;[di]+d16
   341                                  ;;;        mov     di,[v7_di+bp]
   342 000000E4 EB1B                            jmp     short vvw
   343                                  
   344                                  mod_6_10:                           ;[bp]+d16
   345 000000E6 8B7E0A                          mov     di,[v7_bp+bp]
   346 000000E9 8E4602                          mov     es,[v7_ss+bp]        ;SS is used
   347 000000EC EB13                            jmp     short vvw
   348                                  
   349                                  mod_7_10:                           ;[bx]+d16
   350 000000EE 8B7E0E                          mov     di,[v7_bx+bp]
   351 000000F1 EB0E                            jmp     short vvw
   352                                  
   353                                  mod_4_00:                           ;[si]
   354 000000F3 8B7E08                          mov     di,[v7_si+bp]
   355 000000F6 EB0C                            jmp     short vvv
   356                                  
   357                                  mod_5_00:                           ;[di]
   358                                  ;;;        mov     di,[v7_di+bp]
   359 000000F8 EB0A                            jmp     short vvv
   360                                  
   361                                  mod_7_00:                           ;[bx]
   362 000000FA 8B7E0E                          mov     di,[v7_bx+bp]
   363 000000FD EB05                            jmp     short vvv
   364                                  
   365                                  mod_6_00:                           ;D16 -- simple variable
   366 000000FF 31FF                            xor     di,di
   367                                  vvw:
   368 00000101 AD                              lodsw
   369                                  vvb:
   370 00000102 01C7                            add     di,ax
   371                                  vvv:
   372                                  
   373                                  ;  ES:DI is pointer to argument
   374                                  
   375                                  ;;;        mov     ax,seg EM187_DATA
   376 00000104 E8D21A                  	call	get_data_segment	; to AX and DS
   377                                  ;;;
   378                                  ;;;        mov     ds,ax               ;set up addressing
   379                                  ;;;        assume  ds:EM187_DATA
   380                                  
   381 00000107 890E0C00                        mov     [instruct],cx       ;save instruction
   382                                  ;;
   383 0000010B 89D3                    	mov	bx,dx
   384 0000010D C1EB05                  	shr	bx,5
   385 00000110 83E31F                  	and	bx,0011111b	 ; FSTENV or FSAVE? mask (5bits)
   386 00000113 83FB0E                  	cmp	bx,0001110b	; one of the above?
   387 00000116 7416                    	je	bypass_SAV_ENV  ; do not muck up save areas if FSAVE or FSTENV
   388 00000118 893E0800                	mov	[data_offset],di	; save data address
   389 0000011C 8C060A00                	mov	[data_segment],es	; save data segment
   390 00000120 8B5E16                  	mov	bx,[v7_ip+bp]	; save instruction IP
   391 00000123 891E0400                	mov	[save_ip],bx
   392 00000127 8B5E18                  	mov	bx,[v7_cs+bp]	; save instruction CS
   393 0000012A 891E0600                	mov	[save_cs],bx
   394                                  bypass_SAV_ENV:
   395                                  ;;
   396 0000012E 897616                          mov     [v7_ip+bp],si        ;update return address
   397 00000131 89D3                            mov     bx,dx               ;move opA-opB to BX
   398 00000133 C1EB04                          shr     bx,4                ;get fmt12t dispatch index
   399 00000136 83E37E                          and     bx,7Eh              ;mask to 6 bits, set for word address
   400 00000139 2EFFA7[1602]              cs    jmp     [fmt12t+bx]          ;dispatch
   401                                  
   402                                  ;
   403                                  ; MOD == 11 --  R/R instructions
   404                                  
   405                                  mod_x_11:
   406 0000013E 897616                          mov     [v7_ip+bp],si        ;update return address
   407                                  
   408                                  ;;;        mov     ax,seg EM187_DATA
   409 00000141 E8951A                  	call	get_data_segment	; to AX and DS
   410                                  ;;;        mov     ds,ax               ;set up addressing
   411                                  
   412 00000144 8EC0                            mov     es,ax               ; from both DS and ES
   413 00000146 890E0C00                        mov     [instruct],cx         ;save instruction
   414                                  
   415                                  
   416 0000014A B82007                          mov     ax,0720H            ;get special mask
   417 0000014D 21C8                            and     ax,cx               ;mask instruction word
   418 0000014F 3D2001                          cmp     ax,0120H            ;test for format 4
   419 00000152 7418                            je      fmt04
   420 00000154 3D2003                          cmp     ax,0320H            ;test for format 5
   421 00000157 741F                            je      fmt05
   422                                  fmt03:
   423 00000159 80E401                          and     ah,01H              ;mask op-A
   424 0000015C D0E4                            shl     ah,1
   425 0000015E BB3800                          mov     bx,38H
   426 00000161 20CB                            and     bl,cl               ;form op-B
   427 00000163 D1EB                            shr     bx,1
   428 00000165 00E3                            add     bl,ah               ;form  op-B || op-A
   429 00000167 2EFFA7[9602]              cs    jmp     [fmt03t+bx]
   430                                  fmt04:
   431 0000016C BB1F00                          mov     bx,001fH            ;5 bit mask
   432 0000016F 21CB                            and     bx,cx               ;form op
   433 00000171 D1E3                            shl     bx,1
   434 00000173 2EFFA7[B602]              cs    jmp     [fmt04t+bx]
   435                                  fmt05:
   436 00000178 BB1F00                          mov     bx,001fH            ;5 bit mask
   437 0000017B 21CB                            and     bx,cx
   438 0000017D D1E3                            shl     bx,1
   439 0000017F 2EFFA7[F602]              cs    jmp     [fmt05t+bx]
   440                                  
   441                                  
   442                                  gFYL2XP1:
   443                                  
   444                                  gFENI:
   445                                  gFDISI:
   446                                  gSETPM:
   447                                  gFLDENV:
   448                                  gFSTENV:
   449                                  gFRSTOR:
   450                                  gFSAVE:
   451                                  unimplemented:
   452 00000184 680001                          push    errUnemulated
   453 00000187 E8671A                          call    exception
   454 0000018A EB2A                            jmp     short restore_segs
   455                                  
   456                                  underflow:
   457                                  ;;;        and     codes,NOT C1                ;indicate underflow
   458 0000018C 80260300FD                      and     byte [codes],~C1                ;indicate underflow
   459 00000191 684110                          push    errStkUnderflow+Sflag+Iexcept
   460 00000194 E85A1A                          call    exception
   461 00000197 EB11                            jmp     short pop001
   462                                  
   463                                  test_pop:
   464 00000199 F6060D0002                      test    byte [instruct+1],Pbit     ;test for pop
   465 0000019E 7416                            jz      restore_segs
   466                                  ;
   467                                  ;   pop stack, not knowing where ST(0) is
   468                                  ;
   469                                  pop_the_tos:
   470 000001A0 31DB                            xor     bx,bx               ;use ST(0)
   471 000001A2 E8B904                          call    regptr              ;get pointer in BX
   472                                  ;
   473                                  ;   pop stack, assuming FPac pointer is in BX
   474                                  ;
   475                                  pop_stack:
   476 000001A5 803F03                          cmp     byte [bx+tag], tag_empty
   477 000001A8 74E2                            je      underflow           ;can't pop an empty register
   478                                  pop001:
   479 000001AA C60703                          mov     byte [bx+tag], tag_empty     ;tag it empty
   480 000001AD FE061000                        inc     byte [tos]                 ;pop the stack
   481 000001B1 8026100007                      and     byte [tos],7               ; **
   482                                  
   483                                  restore_segs:
   484                                  %ifdef DEBUG
   485                                          cmp     [savesp],sp           ;check sp on exit
   486                                          je      rExit
   487                                          jmp     short restore_segs
   488                                  rExit:
   489                                  %endif
   490 000001B6 1F                              pop     ds
   491 000001B7 83C402                          add     sp,2    ;skip over ss
   492 000001BA 07                              pop     es
   493 000001BB 61                              popa            ;pop the rest
   494                                  vector7z:
   495 000001BC CF                              iret            ;and return
   496                                  
   497                                  ;;;vector7 endp
   498                                  
   499                                  
   500                                  
   501 000001BD 90                      	even
   502                                  %ifdef DEBUG
   503                                  insptr      dw      trace
   504                                  savesp      resw	1
   505                                  %endif
   506                                  
   507                                  
   508                                  
   509 000001BE [A300][7200][5700]-     adrmode dw      mod_0_00, mod_0_01, mod_0_10, mod_x_11
   509 000001C4 [3E01]             
   510 000001C6 [AB00][8500][6000]-             dw      mod_1_00, mod_1_01, mod_1_10, mod_x_11
   510 000001CC [3E01]             
   511 000001CE [B000][8C00][6600]-             dw      mod_2_00, mod_2_01, mod_2_10, mod_x_11
   511 000001D4 [3E01]             
   512 000001D6 [BB00][9900][7D00]-             dw      mod_3_00, mod_3_01, mod_3_10, mod_x_11
   512 000001DC [3E01]             
   513 000001DE [F300][C300][DF00]-             dw      mod_4_00, mod_4_01, mod_4_10, mod_x_11
   513 000001E4 [3E01]             
   514 000001E6 [F800][CA00][E400]-             dw      mod_5_00, mod_5_01, mod_5_10, mod_x_11
   514 000001EC [3E01]             
   515 000001EE [FF00][CE00][E600]-             dw      mod_6_00, mod_6_01, mod_6_10, mod_x_11
   515 000001F4 [3E01]             
   516 000001F6 [FA00][D800][EE00]-             dw      mod_7_00, mod_7_01, mod_7_10, mod_x_11
   516 000001FC [3E01]             
   517                                  
   518                                  %include "em187a.asm"
   519                              <1> ; em187a.asm
   520                              <1> 
   521                              <1> 	even
   522 000001FE [3000][2200][2600]- <1> override dw     es_over, cs_over, ss_over, ds_over
   522 00000204 [2A00]              <1>
   523 00000206 440050005C00680074- <1> fp0tab  dw      fp0,fp1,fp2,fp3,fp4,fp5,fp6,fp7
   523 0000020F 0080008C009800      <1>
   524                              <1> 
   525                              <1> ;                                 opA opB
   526 00000216 [DC08]              <1> fmt12t  dw      genFADD         ; 000 000       R32
   527 00000218 [1F10]              <1>         dw      genFMUL         ; 000 001       R32
   528 0000021A [9C13]              <1>         dw      genFCOM         ; 000 010       R32
   529 0000021C [BF13]              <1>         dw      genFCOMP        ; 000 011       R32
   530 0000021E [F608]              <1>         dw      genFSUB         ; 000 100       R32
   531 00000220 [1409]              <1>         dw      genFSUBR        ; 000 101       R32
   532 00000222 [6811]              <1>         dw      genFDIV         ; 000 110       R32
   533 00000224 [8211]              <1>         dw      genFDIVR        ; 000 111       R32
   534                              <1> 
   535 00000226 [3E03]              <1>         dw      genFLD          ; 001 000       R32
   536 00000228 [8401]              <1>         dw      unimplemented   ; 001 001
   537 0000022A [9E04]              <1>         dw      genFST          ; 001 010       R32
   538 0000022C [B204]              <1>         dw      genFSTP         ; 001 011       R32
   539 0000022E [8401]              <1>         dw      gFLDENV         ; 001 100       14 bytes
   540 00000230 [D104]              <1>         dw      gFLDCW          ; 001 101
   541 00000232 [8401]              <1>         dw      gFSTENV         ; 001 110       14 bytes
   542 00000234 [C804]              <1>         dw      gFSTCW          ; 001 111
   543                              <1> 
   544 00000236 [DC08]              <1>         dw      genFADD         ; 010 000       I32
   545 00000238 [1F10]              <1>         dw      genFMUL         ; 010 001       I32
   546 0000023A [9C13]              <1>         dw      genFCOM         ; 010 010       I32
   547 0000023C [BF13]              <1>         dw      genFCOMP        ; 010 011       I32
   548 0000023E [F608]              <1>         dw      genFSUB         ; 010 100       I32
   549 00000240 [1409]              <1>         dw      genFSUBR        ; 010 101       I32
   550 00000242 [6811]              <1>         dw      genFDIV         ; 010 110       I32
   551 00000244 [8211]              <1>         dw      genFDIVR        ; 010 111       I32
   552                              <1> 
   553 00000246 [3E03]              <1>         dw      genFLD          ; 011 000       I32
   554 00000248 [8401]              <1>         dw      unimplemented   ; 011 001
   555 0000024A [9E04]              <1>         dw      genFST          ; 011 010       I32
   556 0000024C [B204]              <1>         dw      genFSTP         ; 011 011       I32
   557 0000024E [8401]              <1>         dw      unimplemented   ; 011 100
   558 00000250 [4217]              <1>         dw      FLDtmp          ; 011 101
   559 00000252 [8401]              <1>         dw      unimplemented   ; 011 110
   560 00000254 [C917]              <1>         dw      FSTPtmp         ; 011 111
   561                              <1> 
   562 00000256 [DC08]              <1>         dw      genFADD         ; 100 000       R64
   563 00000258 [1F10]              <1>         dw      genFMUL         ; 100 001       R64
   564 0000025A [9C13]              <1>         dw      genFCOM         ; 100 010       R64
   565 0000025C [BF13]              <1>         dw      genFCOMP        ; 100 011       R64
   566 0000025E [F608]              <1>         dw      genFSUB         ; 100 100       R64
   567 00000260 [1409]              <1>         dw      genFSUBR        ; 100 101       R64
   568 00000262 [6811]              <1>         dw      genFDIV         ; 100 110       R64
   569 00000264 [8211]              <1>         dw      genFDIVR        ; 100 111       R64
   570                              <1> 
   571 00000266 [3E03]              <1>         dw      genFLD          ; 101 000       R64
   572 00000268 [8401]              <1>         dw      unimplemented   ; 101 001
   573 0000026A [9E04]              <1>         dw      genFST          ; 101 010       R64
   574 0000026C [B204]              <1>         dw      genFSTP         ; 101 011       R64
   575 0000026E [8401]              <1>         dw      gFRSTOR         ; 101 100       94 bytes
   576 00000270 [8401]              <1>         dw      unimplemented   ; 101 101
   577 00000272 [8401]              <1>         dw      gFSAVE          ; 101 110       94 bytes
   578 00000274 [F404]              <1>         dw      gFSTSW          ; 101 111
   579                              <1> 
   580 00000276 [DC08]              <1>         dw      genFADD         ; 110 000       I16
   581 00000278 [1F10]              <1>         dw      genFMUL         ; 110 001       I16
   582 0000027A [9C13]              <1>         dw      genFCOM         ; 110 010       I16
   583 0000027C [BF13]              <1>         dw      genFCOMP        ; 110 011       I16
   584 0000027E [F608]              <1>         dw      genFSUB         ; 110 100       I16
   585 00000280 [1409]              <1>         dw      genFSUBR        ; 110 101       I16
   586 00000282 [6811]              <1>         dw      genFDIV         ; 110 110       I16
   587 00000284 [8211]              <1>         dw      genFDIVR        ; 110 111       I16
   588                              <1> 
   589 00000286 [3E03]              <1>         dw      genFLD          ; 111 000       I16
   590 00000288 [8401]              <1>         dw      unimplemented   ; 111 001
   591 0000028A [9E04]              <1>         dw      genFST          ; 111 010       I16
   592 0000028C [B204]              <1>         dw      genFSTP         ; 111 011       I16
   593 0000028E [3F14]              <1>         dw      gFBLD           ; 111 100
   594 00000290 [B507]              <1>         dw      FLDi64          ; 111 101
   595 00000292 [0015]              <1>         dw      gFBSTP          ; 111 110
   596 00000294 [D916]              <1>         dw      FSTPi64         ; 111 111
   597                              <1> 
   598 00000296 [3404]              <1> fmt03t  dw      FADDrr              ; 0000      & FADDP
   599 00000298 [1205]              <1>         dw      FLD_i_to_0          ; 0001      & FFREE (R==1)
   600 0000029A [1510]              <1>         dw      FMULrr              ; 0010
   601 0000029C [4105]              <1>         dw      gFXCH               ; 0011
   602 0000029E [E213]              <1>         dw      FCOMrr              ; 0100
   603 000002A0 [2705]              <1>         dw      FST_0_to_i          ; 0101      & FNOP
   604 000002A2 [F413]              <1>         dw      FCOMPrr             ; 0110      & FCOMPP
   605 000002A4 [3305]              <1>         dw      FSTP_0_to_i         ; 0111
   606 000002A6 [3F04]              <1>         dw      FSUBi               ; 1000      ST - ST(i)
   607 000002A8 [EB04]              <1>         dw      FSTSW_ax            ; 1001
   608 000002AA [6A04]              <1>         dw      FSUB0               ; 1010      ST(i) - ST
   609 000002AC [8401]              <1>         dw      unimplemented       ; 1011
   610 000002AE [9E11]              <1>         dw      FDIVi               ; 1100      ST / ST(i)
   611 000002B0 [8401]              <1>         dw      unimplemented       ; 1101
   612 000002B2 [BF11]              <1>         dw      FDIV0               ; 1110      ST(i) / ST
   613 000002B4 [8401]              <1>         dw      unimplemented       ; 1111
   614                              <1> 
   615 000002B6 [C408]              <1> fmt04t  dw      gFCHS               ; 00000
   616 000002B8 [D008]              <1>         dw      gFABS               ; 00001
   617 000002BA [8401]              <1>         dw      unimplemented       ; 00010
   618 000002BC [8401]              <1>         dw      unimplemented       ; 00011
   619 000002BE [5211]              <1>         dw      gFTST               ; 00100
   620 000002C0 [1311]              <1>         dw      gFXAM               ; 00101
   621 000002C2 [8401]              <1>         dw      unimplemented       ; 00110
   622 000002C4 [8401]              <1>         dw      unimplemented       ; 00111
   623 000002C6 [6005]              <1>         dw      gFLD1               ; 01000
   624 000002C8 [7105]              <1>         dw      gFLDL2T             ; 01001
   625 000002CA [8205]              <1>         dw      gFLDL2E             ; 01010
   626 000002CC [9305]              <1>         dw      gFLDPI              ; 01011
   627 000002CE [A405]              <1>         dw      gFLDLG2             ; 01100
   628 000002D0 [B505]              <1>         dw      gFLDLN2             ; 01101
   629 000002D2 [C605]              <1>         dw      gFLDZ               ; 01110
   630 000002D4 [8401]              <1>         dw      unimplemented       ; 01111
   631                              <1> 
   632 000002D6 [B00A]              <1>         dw      gF2XM1              ; 10000
   633 000002D8 [DB0C]              <1>         dw      gFYL2X              ; 10001
   634 000002DA [B609]              <1>         dw      gFPTAN              ; 10010
   635 000002DC [2A1B]              <1>         dw      gFPATAN             ; 10011
   636 000002DE [7E16]              <1>         dw      gFXTRACT            ; 10100
   637 000002E0 [8401]              <1>         dw      unimplemented       ; 10101
   638 000002E2 [3209]              <1>         dw      gFDECSTP            ; 10110
   639 000002E4 [3E09]              <1>         dw      gFINCSTP            ; 10111
   640 000002E6 [5B19]              <1>         dw      gFPREM              ; 11000
   641 000002E8 [8401]              <1>         dw      gFYL2XP1            ; 11001
   642 000002EA [B818]              <1>         dw      gFSQRT              ; 11010
   643 000002EC [8401]              <1>         dw      unimplemented       ; 11011
   644 000002EE [6E18]              <1>         dw      gFRNDINT            ; 11100
   645 000002F0 [B416]              <1>         dw      gFSCALE             ; 11101
   646 000002F2 [8401]              <1>         dw      unimplemented       ; 11110
   647 000002F4 [8401]              <1>         dw      unimplemented       ; 11111
   648                              <1> 
   649 000002F6 [8401]              <1> fmt05t  dw      gFENI               ; 00000
   650 000002F8 [8401]              <1>         dw      gFDISI              ; 00001
   651 000002FA [7503]              <1>         dw      gFCLEX              ; 00010
   652 000002FC [5003]              <1>         dw      gFINIT              ; 00011
   653 000002FE [8401]              <1>         dw      unimplemented       ; 00100
   654 00000300 [8401]              <1>         dw      unimplemented       ; 00101
   655 00000302 [8401]              <1>         dw      unimplemented       ; 00110
   656 00000304 [8401]              <1>         dw      unimplemented       ; 00111
   657 00000306 [8401]              <1>         dw      unimplemented       ; 01000
   658 00000308 [8401]              <1>         dw      unimplemented       ; 01001
   659 0000030A [8401]              <1>         dw      unimplemented       ; 01010
   660 0000030C [8401]              <1>         dw      unimplemented       ; 01011
   661 0000030E [8401]              <1>         dw      unimplemented       ; 01100
   662 00000310 [8401]              <1>         dw      unimplemented       ; 01101
   663 00000312 [8401]              <1>         dw      unimplemented       ; 01110
   664 00000314 [8401]              <1>         dw      unimplemented       ; 01111
   665                              <1> 
   666 00000316 [8401]              <1>         dw      unimplemented       ; 10000
   667 00000318 [8401]              <1>         dw      unimplemented       ; 10001
   668 0000031A [8401]              <1>         dw      unimplemented       ; 10010
   669 0000031C [8401]              <1>         dw      unimplemented       ; 10011
   670 0000031E [8401]              <1>         dw      unimplemented       ; 10100
   671 00000320 [8401]              <1>         dw      unimplemented       ; 10101
   672 00000322 [8401]              <1>         dw      unimplemented       ; 10110
   673 00000324 [8401]              <1>         dw      unimplemented       ; 10111
   674 00000326 [8401]              <1>         dw      unimplemented       ; 11000
   675 00000328 [8401]              <1>         dw      unimplemented       ; 11001
   676 0000032A [8401]              <1>         dw      unimplemented       ; 11010
   677 0000032C [8401]              <1>         dw      unimplemented       ; 11011
   678 0000032E [8401]              <1>         dw      unimplemented       ; 11100
   679 00000330 [8401]              <1>         dw      unimplemented       ; 11101
   680 00000332 [8401]              <1>         dw      unimplemented       ; 11110
   681 00000334 [8401]              <1>         dw      unimplemented       ; 11111
   682                              <1> 
   683                              <1> 
   684                              <1> 	even
   685 00000336 [6D06][2E07][FF0D]- <1> vecFLD  dw  load_R32, load_I32, load_R64, load_I16  
   685 0000033C [1D07]              <1>
   686                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   687                              <1> ;
   688                              <1> ; FLD of i16, i32, r32, and r64
   689                              <1> ;   Floating point load
   690                              <1> ;
   691                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   692                              <1> genFLD:
   693 0000033E E8F702              <1>         call    alloc
   694 00000341 89DE                <1>         mov     si,bx
   695 00000343 BB0600              <1>         mov     bx,FMbits           ;get format mask
   696 00000346 20EB                <1>         and     bl,ch
   697                              <1> ;;;        push    OFFSET restore_segs
   698 00000348 68[B601]            <1>         push    restore_segs
   699 0000034B 2EFFA7[3603]        <1>   cs    jmp     [vecFLD+bx]
   700                              <1> 
   701                              <1> 
   702                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   703                              <1> ;
   704                              <1> ; do overall emulator initialization -- FINIT instruction
   705                              <1> ;
   706                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   707                              <1> gFINIT:
   708 00000350 C606030040          <1>         mov     byte [codes], C3
   709                              <1> ;;;        mov     byte [masks], 7Fh      ;mask all interrupts
   710                              <1> ;;;        mov     byte [ctrl], 03H
   711 00000355 C70600007F03        <1> 	mov	word [Control],037Fh
   712 0000035B 31C0                <1>         xor     ax,ax           ;get Zero
   713                              <1> %if 1
   714 0000035D 1E                  <1> 	push	ds
   715 0000035E 07                  <1> 	pop	es
   716 0000035F BF0200              <1> 	mov	di,Status
   717 00000362 B90800              <1> 	mov	cx,nFINIT
   718 00000365 F3AB                <1> 	rep	stosw
   719                              <1> %else
   720                              <1> ; clear CS:IP, data DS:PTR, instruct
   721                              <1> 	mov	[Status],ax	; Zap flags & codes
   722                              <1>         mov     [enables],al      ;mask all interrupts
   723                              <1>         mov     [tos],al
   724                              <1>         mov     [round],ax        ;set round to nearest
   725                              <1> %endif
   726 00000367 B90800              <1>         mov     cx,8
   727                              <1> ;;;        mov     si,offset fp0
   728 0000036A BE4400              <1>         mov     si, fp0
   729                              <1> gFINIT1:
   730 0000036D C60403              <1>         mov     byte [si+tag], tag_empty
   731 00000370 83C60C              <1>         add     si, lenAccum
   732 00000373 E2F8                <1>         loop    gFINIT1
   733                              <1> ; fall into
   734                              <1> 
   735                              <1> ; clear exceptions
   736                              <1> 
   737                              <1> gFCLEX:
   738 00000375 C606020000          <1>         mov     byte [flags], 0
   739 0000037A E939FE              <1>         jmp     restore_segs
   740                              <1> 
   741                              <1> 
   742                              <1> 
   743                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   744                              <1> ;
   745                              <1> ;   RRsetup -- setup for ST(i) - ST(0) operations
   746                              <1> ;
   747                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   748                              <1> RRsetup:	;	 proc    near
   749                              <1> 
   750 0000037D 88CB                <1>         mov     bl,cl           ;get source register
   751 0000037F E8DC02              <1>         call    regptr          ;get pointer to source
   752 00000382 89DE                <1>         mov     si,bx           ;source ptr to SI
   753 00000384 31DB                <1>         xor     bx,bx           ;get ST(0)
   754 00000386 E8D502              <1>         call    regptr          ;get pointer to destination
   755 00000389 89DF                <1>         mov     di,bx           ;dest. ptr to DI
   756 0000038B F6C504              <1>         test    ch,Rbit         ;test reversal bit
   757 0000038E 7402                <1>         jz      RR010           ;don't reverse
   758 00000390 87F7                <1>         xchg    si,di           ;reverse source and destination
   759                              <1> RR010:
   760 00000392 C3                  <1>         ret
   761                              <1> 
   762                              <1> ;RRsetup endp
   763                              <1> 
   764                              <1> 
   765                              <1> 
   766                              <1> ;  something is rotten in Source or Destination
   767                              <1> 
   768                              <1> FA200:              ;;;; ****
   769 00000393 5E                  <1>         pop     si                  ; clean up the stack for now
   770 00000394 C60406              <1>         mov     byte [si+tag], tag_invalid
   771 00000397 6A01                <1>         push    Iexcept             ;signal exception
   772 00000399 E85518              <1>         call    exception
   773 0000039C E99400              <1>         jmp     FA100
   774                              <1> 
   775                              <1> 
   776                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   777                              <1> ;
   778                              <1> ;   Add register - register
   779                              <1> ;       SI and DI point to operands
   780                              <1> ;       BX is place to put result, may be same as SI or DI
   781                              <1> ;
   782                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   783                              <1> do_add:		;      proc    near
   784 0000039F 53                  <1>         push    bx              ;save place to which to move result
   785 000003A0 8A04                <1>         mov     al,[si+tag]     ;get source tag
   786 000003A2 0A05                <1>         or      al,[di+tag]     ;or on destination tag
   787 000003A4 A802                <1>         test    al, tag_infin   ;test for infinity, empty, or invalid
   788 000003A6 75EB                <1>         jnz     FA200           ;if not both valid, something needs checking
   789                              <1> ; both tags are valid
   790 000003A8 8B4402              <1>         mov     ax,[si+expon]   ;get source exponent
   791 000003AB 3B4502              <1>         cmp     ax,[di+expon]   ;get dest exponent
   792 000003AE 7D02                <1>         jge     FA040           ;jump if source exponent is bigger
   793 000003B0 87F7                <1>         xchg    si,di           ;source has bigger or equal exponent
   794                              <1> FA040:
   795 000003B2 89FB                <1>         mov     bx,di           ;smaller exponent
   796 000003B4 8B4C02              <1>         mov     cx,[si+expon]   ;larger exponent
   797 000003B7 2B4F02              <1>         sub     cx,[bx+expon]   ;smaller exponent
   798                              <1> 
   799 000003BA 8A6401              <1>         mov     ah,[si+sign]    ;get sign of source
   800 000003BD 326701              <1>         xor     ah,[bx+sign]    ;get sign of destination
   801 000003C0 743E                <1>         jz      FA070           ;go do add if signs are the same
   802                              <1> ; signs are different
   803 000003C2 E81602              <1>         call    vloadshift      ;get right shifted mantissa
   804                              <1> %if BIG
   805 000003C5 8B7C0A              <1>         mov     di,[si+mantis+6]
   806 000003C8 29CF                <1>         sub     di,cx
   807 000003CA 8B4C08              <1>         mov     cx,[si+mantis+4]
   808 000003CD 19D9                <1>         sbb     cx,bx
   809 000003CF 8B5C06              <1>         mov     bx,[si+mantis+2]
   810 000003D2 19C3                <1>         sbb     bx,ax
   811 000003D4 8B4404              <1>         mov     ax,[si+mantis]
   812 000003D7 19D0                <1>         sbb     ax,dx
   813 000003D9 87D7                <1>         xchg    dx,di               ; AX:BX:CX:DX
   814                              <1> %else
   815                              <1>         mov     bx,[si+mantis+2]
   816                              <1>         sub     bx,ax
   817                              <1>         mov     ax,[si+mantis]
   818                              <1>         sbb     ax,dx               ; AX:BX
   819                              <1> %endif
   820 000003DB 5F                  <1>         pop     di                  ;get where to put it
   821 000003DC 8B2C                <1>         mov     bp,[si]             ;get sign & exponent
   822 000003DE 892D                <1>         mov     [di],bp             ;store at destination
   823 000003E0 8B7402              <1>         mov     si,[si+expon]       ;get result exponent
   824 000003E3 7316                <1>         jnc     FA050
   825                              <1> ; carry is set, invert the sign, and negate the mantissa
   826 000003E5 80750101            <1>         xor     byte [di+sign],01h
   827                              <1> %if BIG
   828 000003E9 F7DA                <1>         neg     dx
   829 000003EB F5                  <1>         cmc
   830 000003EC F7D1                <1>         not     cx
   831 000003EE 83D100              <1>         adc     cx,0
   832 000003F1 F7D3                <1>         not     bx
   833 000003F3 83D300              <1>         adc     bx,0
   834                              <1> %else
   835                              <1>         neg     bx
   836                              <1>         cmc
   837                              <1> %endif
   838 000003F6 F7D0                <1>         not     ax
   839 000003F8 83D000              <1>         adc     ax,0                ;end of negate
   840                              <1> FA050:
   841                              <1> ; will have to normalize the result
   842                              <1> ; result exponent is currently in SI
   843 000003FB 87F7                <1>         xchg    si,di               ;swap exponent to DI, dest to SI
   844 000003FD E95A03              <1>         jmp     normalize_and_exit
   845                              <1> 
   846                              <1> ;  Actually add the mantissas
   847                              <1> 
   848                              <1> FA070:
   849 00000400 E8D801              <1>         call    vloadshift      ;get right shifted mantissa
   850                              <1> %if BIG
   851 00000403 034C0A              <1>         add     cx,[si+mantis+6]
   852 00000406 135C08              <1>         adc     bx,[si+mantis+4]
   853 00000409 134406              <1>         adc     ax,[si+mantis+2]
   854                              <1> %else
   855                              <1>         add     ax,[si+mantis+2]
   856                              <1> %endif
   857 0000040C 135404              <1>         adc     dx,[si+mantis]
   858 0000040F 5F                  <1>         pop     di
   859 00000410 8B2C                <1>         mov     bp,[si]             ;get sign & tag
   860 00000412 892D                <1>         mov     [di],bp             ;store them
   861                              <1> ; 
   862 00000414 8B7402              <1>         mov     si,[si+expon]       ;get exponent
   863 00000417 7309                <1>         jnc     FA080
   864 00000419 D1DA                <1>         rcr     dx,1                ;carry bit to DX
   865 0000041B D1D8                <1>         rcr     ax,1
   866                              <1> %if BIG
   867 0000041D D1DB                <1>         rcr     bx,1
   868 0000041F D1D9                <1>         rcr     cx,1
   869                              <1> %endif
   870 00000421 46                  <1>         inc     si                  ;increment exponent
   871                              <1> FA080:
   872 00000422 897502              <1>         mov     [di+expon],si       ;store result exponent
   873 00000425 895504              <1>         mov     [di+mantis],dx      ;store result
   874 00000428 894506              <1>         mov     [di+mantis+2],ax
   875                              <1> %if BIG
   876 0000042B 895D08              <1>         mov     [di+mantis+4],bx
   877 0000042E 894D0A              <1>         mov     [di+mantis+6],cx
   878                              <1> %endif
   879 00000431 87F7                <1>         xchg    si,di               ;return pointer in SI
   880                              <1> FA100:
   881 00000433 C3                  <1>         ret
   882                              <1> 
   883                              <1> ;do_add      endp
   884                              <1> 
   885                              <1> 
   886                              <1> 
   887                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   888                              <1> ;
   889                              <1> ;   FADD    ST,ST(i)        R=0, P=0
   890                              <1> ;   FADD    ST(i),ST        R=1, P=0
   891                              <1> ;   FADDP   ST(i),ST        R=1, P=1
   892                              <1> ;
   893                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   894                              <1> FADDrr:
   895 00000434 E846FF              <1>         call    RRsetup         ;get source and destination reg. ptrs
   896 00000437 89FB                <1>         mov     bx,di           ;BX is where final result will go
   897 00000439 E863FF              <1>         call    do_add          ;do the register to register add
   898 0000043C E95AFD              <1>         jmp     test_pop        ;test stack for pop
   899                              <1> 
   900                              <1> 
   901                              <1> 
   902                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   903                              <1> ;
   904                              <1> ;   FSUB    ST,ST(i)        R=0, P=0
   905                              <1> ;   FSUBR   ST(i),ST        R=1, P=0
   906                              <1> ;   FSUBRP  ST(i),ST        R=1, P=1
   907                              <1> ;
   908                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   909                              <1> FSUBi:
   910 0000043F 88CB                <1>         mov     bl,cl           ;get ST(i)
   911 00000441 E81A02              <1>         call    regptr          ;BX is ST(i) pointer
   912 00000444 89DE                <1>         mov     si,bx           ;SI is ST(i) pointer
   913 00000446 31DB                <1>         xor     bx,bx           ;get ST
   914 00000448 E81302              <1>         call    regptr          ;BX is ST pointer
   915 0000044B 89DF                <1>         mov     di,bx           ;DI is ST pointer
   916 0000044D 80740101            <1>         xor     byte [si+sign],01    ;invert ST(i) sign
   917 00000451 F6C504              <1>         test    ch,Rbit         ;see who gets the result
   918 00000454 750C                <1>         jnz     FSUBi01         ;ST(i) does
   919                              <1> ; ST gets the result
   920 00000456 56                  <1>         push    si              ;save ST(i) pointer
   921 00000457 E845FF              <1>         call    do_add          ;get the answer
   922 0000045A 5E                  <1>         pop     si              ;restore ST(i) pointer
   923 0000045B 80740101            <1>         xor     byte [si+sign],01    ;invert ST(i) sign
   924 0000045F E954FD              <1>         jmp     restore_segs    ;no pop is possible
   925                              <1> FSUBi01:
   926 00000462 89F3                <1>         mov     bx,si           ;result to ST(i)
   927                              <1> ;;;     push    OFFSET test_pop ;pop is possible
   928 00000464 68[9901]            <1>         push    test_pop	;pop is possible
   929 00000467 E935FF              <1>         jmp     do_add          ;will return to 'test_pop'
   930                              <1> 
   931                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   932                              <1> ;
   933                              <1> ;   FSUBR   ST,ST(i)        R=0, P=0
   934                              <1> ;   FSUB    ST(i),ST        R=1, P=0
   935                              <1> ;   FSUBP   ST(i),ST        R=1, P=1
   936                              <1> ;
   937                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   938                              <1> FSUB0:
   939 0000046A 88CB                <1>         mov     bl,cl           ;get ST(i)
   940 0000046C E8EF01              <1>         call    regptr          ;BX is ST(i) pointer
   941 0000046F 89DE                <1>         mov     si,bx           ;SI is ST(i) pointer
   942 00000471 31DB                <1>         xor     bx,bx           ;get ST
   943 00000473 E8E801              <1>         call    regptr          ;BX is ST pointer
   944 00000476 89DF                <1>         mov     di,bx           ;DI is ST pointer
   945 00000478 80750101            <1>         xor     byte [di+sign],01h   ;invert ST sign
   946 0000047C F6C504              <1>         test    ch,Rbit         ;see if ST(i) gets result
   947 0000047F 7506                <1>         jnz     FSUB001         ;
   948                              <1> ; ST gets the result
   949                              <1> ;;;     push    OFFSET restore_segs ;no pop is possible
   950 00000481 68[B601]            <1>         push    restore_segs	;no pop is possible
   951 00000484 E918FF              <1>         jmp     do_add          ;will return to exit sequence
   952                              <1> 
   953                              <1> FSUB001:    ; ST(i) will get the result
   954 00000487 89F3                <1>         mov     bx,si           ;ST(i) gets the result
   955 00000489 57                  <1>         push    di              ;save pointer to ST
   956 0000048A E812FF              <1>         call    do_add          ;do the register to register add
   957 0000048D 5F                  <1>         pop     di              ;restore pointer
   958 0000048E 80750101            <1>         xor     byte [di+sign],01h   ;restore the original sign
   959 00000492 E904FD              <1>         jmp     test_pop        ;possible pop of ST
   960                              <1> 
   961                              <1> 
   962                              <1> ; end em187a.asm
   519                                  %include "em187b.asm"
   520                              <1> ; em187b.asm
   521                              <1> 
   522 00000495 90                  <1> 	even
   523 00000496 [4D08][CD0F][EF0E]- <1> vecFST  dw  store_R32, store_I32, store_R64, store_I16  
   523 0000049C [930F]              <1>
   524                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   525                              <1> ;
   526                              <1> ;   FST     mem
   527                              <1> ;
   528                              <1> ;       ES:DI is the destination address
   529                              <1> ;
   530                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   531                              <1> genFST:
   532 0000049E 31DB                <1>         xor     bx,bx               ;get ST(0)
   533 000004A0 E8BB01              <1>         call    regptr              ;   pointer to BX
   534 000004A3 89DE                <1>         mov     si,bx               ;put source pointer in SI
   535 000004A5 BB0600              <1>         mov     bx,FMbits           ;get format mask
   536 000004A8 20EB                <1>         and     bl,ch
   537                              <1> 
   538                              <1> ;;;     push    OFFSET restore_segs
   539 000004AA 68[B601]            <1>         push    restore_segs
   540 000004AD 2EFFA7[9604]        <1>   cs    jmp     [vecFST+bx]          ;dispatch to proper store routine
   541                              <1>         
   542                              <1> 
   543                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   544                              <1> ;
   545                              <1> ;   FSTP    mem
   546                              <1> ;
   547                              <1> ;       ES:DI is the destination address
   548                              <1> ;
   549                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   550                              <1> genFSTP:
   551 000004B2 31DB                <1>         xor     bx,bx               ;get ST(0)
   552 000004B4 E8A701              <1>         call    regptr              ;   pointer to BX
   553 000004B7 89DE                <1>         mov     si,bx               ;put source pointer in SI
   554 000004B9 BB0600              <1>         mov     bx,FMbits           ;get format mask
   555 000004BC 20EB                <1>         and     bl,ch
   556 000004BE 56                  <1>         push    si                  ;save pointer to ST(0)
   557 000004BF 2EFF97[9604]        <1>   cs    call    [vecFST+bx]          ;dispatch to proper store routine
   558 000004C4 5B                  <1>         pop     bx                  ;get ST(0) pointer
   559 000004C5 E9DDFC              <1>         jmp     pop_stack           ;pop stack with BX set
   560                              <1> 
   561                              <1>         
   562                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   563                              <1> ;
   564                              <1> ;   FSTCW   mem         ; store Control Word
   565                              <1> ;
   566                              <1> ;       ES:DI is the destination address
   567                              <1> ;
   568                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   569                              <1> gFSTCW:
   570 000004C8 A10000              <1>         mov     ax,word [Control]
   571 000004CB 268905              <1>   es    mov     [di],ax
   572 000004CE E9E5FC              <1>         jmp     restore_segs
   573                              <1> 
   574                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   575                              <1> ;
   576                              <1> ;   FLDCW   mem         ; load Control Word
   577                              <1> ;
   578                              <1> ;       ES:DI is the source address
   579                              <1> ;
   580                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   581                              <1> gFLDCW:
   582 000004D1 268B05              <1>   es    mov     ax,word [di]
   583 000004D4 A30000              <1>         mov     [Control],ax        ;set up new control word
   584 000004D7 F6D0                <1>         not     al                  ;interrupt masks become interrupt enables
   585 000004D9 243F                <1>         and     al,3Fh              ;mask bits which may cause interrupt
   586 000004DB A21100              <1>         mov     [enables],al        ;store interrupt enables
   587                              <1> 
   588 000004DE 88E0                <1>         mov     al,ah               ;extract rounding bits
   589 000004E0 83E00C              <1>         and     ax,0Ch              ; **
   590 000004E3 D1E8                <1>         shr     ax,1                ;get 0, 2, 4 or 6
   591 000004E5 A30E00              <1>         mov     [round],ax          ;store rounding index
   592 000004E8 E9CBFC              <1>         jmp     restore_segs
   593                              <1> 
   594                              <1> 
   595                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   596                              <1> ;
   597                              <1> ;   FSTSW   mem         ; store Status Word (8087, 80287, 80387)
   598                              <1> ;   FSTSW   AX          ; store Status Word to AX (not on 8087)
   599                              <1> ;
   600                              <1> ;       ES:DI is the destination address
   601                              <1> ;
   602                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   603                              <1> FSTSW_ax:
   604 000004EB E80F00              <1>         call    get_status          ;get Status to AX
   605 000004EE 894614              <1>         mov     [v7_ax+bp],ax
   606 000004F1 E9C2FC              <1>         jmp     restore_segs
   607                              <1> gFSTSW:
   608 000004F4 E80600              <1>         call    get_status          ;get Status to AX
   609 000004F7 268905              <1>   es    mov     word [di],ax
   610 000004FA E9B9FC              <1>         jmp     restore_segs
   611                              <1> 
   612                              <1> ;
   613                              <1> ;   Get Status word to AX
   614                              <1> ;
   615                              <1> get_status:		;  proc    near
   616 000004FD A10200              <1>         mov     ax,[Status]
   617 00000500 8A361000            <1>         mov     dh,[tos]            ;get top of stack pointer
   618 00000504 C0E603              <1>         shl     dh,3
   619 00000507 08F4                <1>         or      ah,dh               ;combine TOS with condition codes
   620 00000509 84061100            <1>         test    al,[enables]        ;test for interrupts enabled
   621 0000050D 7402                <1>         jz      GS010
   622                              <1> 
   623 0000050F 0C80                <1>         or      al,Estatus        ;set error summary status
   624                              <1> GS010:
   625 00000511 C3                  <1>         ret
   626                              <1> ;get_status  endp
   627                              <1> 
   628                              <1> 
   629                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   630                              <1> ;
   631                              <1> ;   FLD     ST(i)       push operand onto stack from another register
   632                              <1> ;
   633                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   634                              <1> FLD_i_to_0:
   635 00000512 88CB                <1>         mov     bl,cl               ;source register
   636 00000514 E84701              <1>         call    regptr
   637 00000517 89DE                <1>         mov     si,bx               ;source pointer to si
   638 00000519 E81C01              <1>         call    alloc
   639 0000051C 89DF                <1>         mov     di,bx               ;destination pointer to di
   640                              <1> ;;;        cld
   641                              <1> %if 0
   642                              <1>             REPT   lenAccum/2
   643                              <1>         movsw
   644                              <1>             ENDM
   645                              <1> %else
   646                              <1> 	%rep	lenAccum/2
   647                              <1> 	movsw
   648                              <1> 	%endrep
   647 0000051E A5                  <2>  movsw
   647 0000051F A5                  <2>  movsw
   647 00000520 A5                  <2>  movsw
   647 00000521 A5                  <2>  movsw
   647 00000522 A5                  <2>  movsw
   647 00000523 A5                  <2>  movsw
   649                              <1> %endif
   650 00000524 E98FFC              <1>         jmp     restore_segs
   651                              <1> 
   652                              <1> 
   653                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   654                              <1> ;
   655                              <1> ;   FST     ST(i)       store ST(0) into another stack register
   656                              <1> ;
   657                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   658                              <1> FST_0_to_i:
   659 00000527 E853FE              <1>         call    RRsetup             ;setup SI and DI
   660                              <1> ;;;        cld
   661                              <1> %if 0
   662                              <1>             REPT   lenAccum/2
   663                              <1>         movsw
   664                              <1>             ENDM
   665                              <1> %else
   666                              <1> 	%rep	lenAccum/2
   667                              <1> 	movsw
   668                              <1> 	%endrep
   667 0000052A A5                  <2>  movsw
   667 0000052B A5                  <2>  movsw
   667 0000052C A5                  <2>  movsw
   667 0000052D A5                  <2>  movsw
   667 0000052E A5                  <2>  movsw
   667 0000052F A5                  <2>  movsw
   669                              <1> %endif
   670 00000530 E983FC              <1>         jmp     restore_segs
   671                              <1> 
   672                              <1> FSTP_0_to_i:
   673 00000533 E847FE              <1>         call    RRsetup             ;setup SI and DI
   674                              <1> ;;;        cld
   675 00000536 56                  <1>         push    si
   676                              <1> %if 0
   677                              <1>             REPT   lenAccum/2
   678                              <1>         movsw
   679                              <1>             ENDM
   680                              <1> %else
   681                              <1> 	%rep	lenAccum/2
   682                              <1> 	movsw
   683                              <1> 	%endrep
   682 00000537 A5                  <2>  movsw
   682 00000538 A5                  <2>  movsw
   682 00000539 A5                  <2>  movsw
   682 0000053A A5                  <2>  movsw
   682 0000053B A5                  <2>  movsw
   682 0000053C A5                  <2>  movsw
   684                              <1> %endif
   685                              <1> ; now pop the stack top
   686 0000053D 5B                  <1>         pop     bx
   687 0000053E E964FC              <1>         jmp     pop_stack
   688                              <1> 
   689                              <1> 
   690                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   691                              <1> ;
   692                              <1> ;   FXCH    ST(i)       exchange register with ST(0)
   693                              <1> ;
   694                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   695                              <1> gFXCH:
   696 00000541 E839FE              <1>         call    RRsetup             ;setup SI and DI
   697 00000544 B90600              <1>         mov     cx,lenAccum/2       ;get count of words to exchange
   698                              <1> ;;;        cld                         ;set to work forward
   699 00000547 90                  <1> 	even
   700                              <1> xch000:
   701 00000548 AD                  <1>         lodsw                       ;load AX and increment SI
   702 00000549 8B15                <1>         mov     dx,[di]             ;get DX from DI
   703 0000054B 8954FE              <1>         mov     [si-2],dx           ;remember SI has already been incremented
   704 0000054E AB                  <1>         stosw                       ;store AX and increment DI
   705 0000054F E2F7                <1>         loop    xch000              ; loop back until done
   706                              <1> 
   707 00000551 E962FC              <1>         jmp     restore_segs
   708                              <1> 
   709                              <1> 
   710                              <1> 
   711                              <1> %if BIG
   712                              <1> FP_1:
   713                              <1> ;FP_1    ACCUM   <tag_valid, 0, 0, 8000H, 0, 0, 0>
   714 00000554 0000                <1> 	db	tag_valid, 0
   715 00000556 000000800000000000- <1> 	dw	0, 8000H, 0, 0, 0
   715 0000055F 00                  <1>
   716                              <1> %else
   717                              <1> FP_1:
   718                              <1> ;FP_1    ACCUM   <tag_valid, 0, 0, 8000H, 0>
   719                              <1> 	db	tag_valid, 0
   720                              <1> 	dw	0, 8000H, 0
   721                              <1> %endif
   722                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   723                              <1> ;
   724                              <1> ;   FLD1        load the constant 1.0
   725                              <1> ;
   726                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   727                              <1> gFLD1:
   728                              <1> ;;;     mov     si,OFFSET   FP_1
   729 00000560 BE[5405]            <1>         mov     si, FP_1
   730 00000563 EB64                <1>         jmp     short gFLDconstant
   731                              <1> 
   732                              <1> %if BIG
   733                              <1> FP_L2T:
   734                              <1> ;FP_L2T    ACCUM   <tag_valid, 0, 1, 0D49Ah, 0784Bh, 0CD1Bh, 08AFEh>
   735 00000565 0000                <1> 	db	tag_valid, 0
   736 00000567 01009AD44B781BCDFE- <1> 	dw	1, 0D49Ah, 0784Bh, 0CD1Bh, 08AFEh
   736 00000570 8A                  <1>
   737                              <1> %else
   738                              <1> FP_L2T:
   739                              <1> ;FP_L2T    ACCUM   <tag_valid, 0, 1, 0D49Ah, 0784Ch>
   740                              <1> 	db	tag_valid, 0
   741                              <1> 	dw	1, 0D49Ah, 0784Ch
   742                              <1> %endif
   743                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   744                              <1> ;
   745                              <1> ;   FLDL2T        load the constant  LOG2(10)
   746                              <1> ;
   747                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   748                              <1> gFLDL2T:
   749                              <1> ;;;     mov     si,OFFSET   FP_L2T
   750 00000571 BE[6505]            <1>         mov     si, FP_L2T
   751 00000574 EB53                <1>         jmp     short gFLDconstant
   752                              <1> 
   753                              <1> %if BIG
   754                              <1> FP_L2E:
   755                              <1> ;FP_L2E    ACCUM   <tag_valid, 0, 0, 0B8AAh, 03B29h, 05C17h, 0F0BCh>
   756 00000576 0000                <1> 	db	tag_valid, 0
   757 00000578 0000AAB8293B175CBC- <1> 	dw	0, 0B8AAh, 03B29h, 05C17h, 0F0BCh
   757 00000581 F0                  <1>
   758                              <1> %else
   759                              <1> FP_L2E:
   760                              <1> ;FP_L2E    ACCUM   <tag_valid, 0, 0, 0B8AAh, 03B29h>
   761                              <1> 	db	tag_valid, 0
   762                              <1> 	dw	0, 0B8AAh, 03B29h
   763                              <1> %endif
   764                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   765                              <1> ;
   766                              <1> ;   FLDL2E        load the constant  LOG2(E)
   767                              <1> ;
   768                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   769                              <1> gFLDL2E:
   770                              <1> ;;;     mov     si,OFFSET   FP_L2E
   771 00000582 BE[7605]            <1>         mov     si, FP_L2E
   772 00000585 EB42                <1>         jmp     short gFLDconstant
   773                              <1> 
   774                              <1> %if BIG
   775                              <1> FP_PI:
   776                              <1> ;FP_PI    ACCUM   <tag_valid, 0, 1, 0C90Fh, 0DAA2h, 02168h, 0C235h>
   777 00000587 0000                <1> 	db	tag_valid, 0
   778 00000589 01000FC9A2DA682135- <1> 	dw	1, 0C90Fh, 0DAA2h, 02168h, 0C235h
   778 00000592 C2                  <1>
   779                              <1> %else
   780                              <1> FP_PI:
   781                              <1> ;FP_PI    ACCUM   <tag_valid, 0, 1, 0C90Fh, 0DAA2h>
   782                              <1> 	db	tag_valid, 0
   783                              <1> 	dw	1, 0C90Fh, 0DAA2h
   784                              <1> %endif
   785                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   786                              <1> ;
   787                              <1> ;   FLDPI        load the constant  PI
   788                              <1> ;
   789                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   790                              <1> gFLDPI:
   791 00000593 BE[8705]            <1>         mov     si,  FP_PI
   792 00000596 EB31                <1>         jmp     short gFLDconstant
   793                              <1> 
   794                              <1> %if BIG
   795                              <1> FP_LG2:
   796                              <1> ;FP_LG2    ACCUM   <tag_valid, 0, -2, 09A20h, 09A84h, 0FBCFh, 0F799h>
   797 00000598 0000                <1> 	db	tag_valid, 0
   798 0000059A FEFF209A849ACFFB99- <1> 	dw	-2, 09A20h, 09A84h, 0FBCFh, 0F799h
   798 000005A3 F7                  <1>
   799                              <1> %else
   800                              <1> FP_LG2:
   801                              <1> ;FP_LG2    ACCUM   <tag_valid, 0, -2, 09A20h, 09A85h>
   802                              <1> 	db	tag_valid, 0
   803                              <1> 	dw	-2, 09A20h, 09A85h
   804                              <1> %endif
   805                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   806                              <1> ;
   807                              <1> ;   FLDLG2        load the constant LOG10(2)
   808                              <1> ;
   809                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   810                              <1> gFLDLG2:
   811 000005A4 BE[9805]            <1>         mov     si,  FP_LG2
   812 000005A7 EB20                <1>         jmp     short gFLDconstant
   813                              <1> 
   814                              <1> %if BIG
   815                              <1> FP_LN2:
   816                              <1> ;FP_LN2    ACCUM   <tag_valid, 0, -1, 0B172h, 017F7h, 0D1CFh, 079ACh>
   817 000005A9 0000                <1> 	db	tag_valid, 0
   818 000005AB FFFF72B1F717CFD1AC- <1> 	dw	-1, 0B172h, 017F7h, 0D1CFh, 079ACh
   818 000005B4 79                  <1>
   819                              <1> %else
   820                              <1> FP_LN2:
   821                              <1> ;FP_LN2    ACCUM   <tag_valid, 0, -1, 0B172h, 017F8h>
   822                              <1> 	db	tag_valid, 0
   823                              <1> 	dw	-1, 0B172h, 017F8h
   824                              <1> %endif
   825                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   826                              <1> ;
   827                              <1> ;   FLDLN2        load the constant LN(2)
   828                              <1> ;
   829                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   830                              <1> gFLDLN2:
   831 000005B5 BE[A905]            <1>         mov     si,  FP_LN2
   832 000005B8 EB0F                <1>         jmp     short gFLDconstant
   833                              <1> 
   834                              <1> %if BIG
   835                              <1> FP_Z:
   836                              <1> ;FP_Z    ACCUM   <tag_zero, 0, exp_of_FPzero, 0, 0, 0, 0>
   837 000005BA 0100                <1> 	db	tag_zero, 0
   838 000005BC 018000000000000000- <1> 	dw	exp_of_FPzero, 0, 0, 0, 0
   838 000005C5 00                  <1>
   839                              <1> %else
   840                              <1> FP_Z:
   841                              <1> ;FP_Z    ACCUM   <tag_zero, 0, exp_of_FPzero, 0, 0>
   842                              <1> 	db	tag_zero, 0
   843                              <1> 	dw	exp_of_FPzero, 0, 0
   844                              <1> %endif
   845                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   846                              <1> ;
   847                              <1> ;   FLDZ        load the constant 0.0
   848                              <1> ;
   849                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   850                              <1> gFLDZ:
   851 000005C6 BE[BA05]            <1>         mov     si,  FP_Z
   852                              <1> gFLDconstant:
   853 000005C9 E86C00              <1>         call    alloc           ;allocate space on the stack
   854 000005CC 89DF                <1>         mov     di,bx
   855                              <1> ;;;        cld
   856 000005CE 8CC8                <1>         mov     ax,cs
   857 000005D0 8ED8                <1>         mov     ds,ax
   858                              <1> 		%rep lenAccum/2
   859                              <1>         movsw
   860                              <1> 		%endrep
   859 000005D2 A5                  <2>  movsw
   859 000005D3 A5                  <2>  movsw
   859 000005D4 A5                  <2>  movsw
   859 000005D5 A5                  <2>  movsw
   859 000005D6 A5                  <2>  movsw
   859 000005D7 A5                  <2>  movsw
   861 000005D8 E9DBFB              <1>         jmp     restore_segs
   862                              <1> 
   863                              <1> 
   864                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   865                              <1> ;   Name:  vloadshift
   866                              <1> ;   Desc:  get the mantissa pointed to by BX, and shift right by
   867                              <1> ;          the amount in CX.  Return result in  DX:AX[:BX:CX]
   868                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   869                              <1> vloadshift:		;  proc    near
   870                              <1> %if BIG
   871 000005DB 83F93F              <1>         cmp     cx,63       ;shift of 63 is the max for 64-bit mantissa
   872 000005DE 774E                <1>         ja      vlds100     ;go return zero
   873                              <1> 
   874 000005E0 56                  <1>         push    si          ;counter will be here for 64-bit mantissa
   875                              <1> %else
   876                              <1>         cmp     cx,31       ;shift of 31 is the max for 32-bit mantissa
   877                              <1>         ja      vlds100     ;go return zero
   878                              <1> %endif
   879 000005E1 8B5704              <1>         mov     dx,[bx+mantis]      ;first word of mantissa
   880 000005E4 8B4706              <1>         mov     ax,[bx+mantis+2]    ;second word
   881                              <1> %if BIG
   882 000005E7 8B770A              <1>         mov     si,[bx+mantis+6]    ;fourth word of mantissa
   883 000005EA 8B5F08              <1>         mov     bx,[bx+mantis+4]    ;third word of mantissa
   884                              <1> %endif
   885 000005ED 80F910              <1>         cmp     cl,16               ;compare to 16
   886 000005F0 7210                <1>         jb      vlds020             ;skip 16 bit shifts if below 16
   887                              <1> %if BIG
   888                              <1> vlds010:
   889 000005F2 89DE                <1>         mov     si,bx               ;shift by 16 bits
   890 000005F4 89C3                <1>         mov     bx,ax               ;**
   891                              <1> %endif
   892 000005F6 89D0                <1>         mov     ax,dx               ; **
   893 000005F8 31D2                <1>         xor     dx,dx               ;  **
   894 000005FA 80E910              <1>         sub     cl,16
   895                              <1> %if BIG
   896 000005FD 80F910              <1>         cmp     cl,16               ;compare if another 16-bit shift is needed
   897 00000600 77F0                <1>         ja      vlds010             ;loop back if above zero
   898                              <1> %endif
   899                              <1> vlds020:            ; check for 8 bit shift
   900 00000602 80F908              <1>         cmp     cl,8            
   901 00000605 7217                <1>         jb      vlds040
   902                              <1> %if BIG
   903 00000607 87CE                <1>         xchg    cx,si           ;do a long 8 bit shift
   904 00000609 88E9                <1>         mov     cl,ch
   905 0000060B 88DD                <1>         mov     ch,bl
   906 0000060D 88FB                <1>         mov     bl,bh
   907 0000060F 88C7                <1>         mov     bh,al
   908 00000611 87CE                <1>         xchg    cx,si
   909                              <1> %endif
   910 00000613 88E0                <1>         mov     al,ah           ;do the short portion of an 8-bit shift
   911 00000615 88D4                <1>         mov     ah,dl
   912 00000617 88F2                <1>         mov     dl,dh
   913 00000619 30F6                <1>         xor     dh,dh
   914 0000061B 80E908              <1>         sub     cl,8
   915                              <1> vlds040:
   916 0000061E E30A                <1>         jcxz    vlds090         ;may have been reduced this far
   917                              <1>         even
   918                              <1> vlds050:
   919 00000620 D1EA                <1>         shr     dx,1            ;short right shift of 1 bit
   920 00000622 D1D8                <1>         rcr     ax,1
   921                              <1> %if BIG
   922 00000624 D1DB                <1>         rcr     bx,1            ;long extension, right shift 1 bit
   923 00000626 D1DE                <1>         rcr     si,1
   924                              <1> %endif
   925 00000628 E2F6                <1>         loop    vlds050
   926                              <1> vlds090:
   927                              <1> %if BIG
   928 0000062A 89F1                <1>         mov     cx,si           ;result goes back in DX:AX:BX:CX
   929 0000062C 5E                  <1>         pop     si              ;restore saved register
   930                              <1> %endif
   931                              <1> vlds099:
   932 0000062D C3                  <1>         ret
   933                              <1> ; shift was so big, zero mantissa is the result
   934                              <1> vlds100:
   935 0000062E 31D2                <1>         xor     dx,dx
   936 00000630 31C0                <1>         xor     ax,ax
   937                              <1> %if BIG
   938 00000632 31DB                <1>         xor     bx,bx
   939 00000634 31C9                <1>         xor     cx,cx
   940                              <1> %endif
   941 00000636 EBF5                <1>         jmp     vlds099
   942                              <1> 
   943                              <1> ;vloadshift  endp
   944                              <1> 
   945                              <1> 
   946                              <1> 
   947                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   948                              <1> ; allocate FP stack element
   949                              <1> ;
   950                              <1> ;   return with [bx] pointing at stack top
   951                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   952                              <1> 	even
   953                              <1> alloc:		;   proc    near
   954 00000638 8A1E1000            <1>         mov     bl,[tos]        ;get top of stack
   955 0000063C FECB                <1>         dec     bl
   956 0000063E 83E307              <1>         and     bx,7            ;mask to 3 bits
   957 00000641 881E1000            <1>         mov     [tos],bl
   958 00000645 D1E3                <1>         shl     bx,1            ;index words
   959 00000647 2E8B9F[0602]        <1>   cs    mov     bx, [fp0tab+bx]  ; get accumulator array pointer
   960 0000064C 803F03              <1>         cmp     byte [bx+tag], tag_empty
   961 0000064F 7501                <1>         jne     alloc9
   962 00000651 C3                  <1>         ret
   963                              <1> alloc9:
   964 00000652 800E030002          <1>         or      byte [codes],C1        ;flag overflow
   965 00000657 684108              <1>         push    errStkOverflow+Sflag+Iexcept
   966 0000065A E89415              <1>         call    exception
   967 0000065D C3                  <1>         ret
   968                              <1> 
   969                              <1> ;alloc   endp
   970                              <1> 
   971                              <1> 
   972                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   973                              <1> ; regptr -- get pointer to ST(i), and check for validity
   974                              <1> ;  enter with reg in low 3 bits of bx
   975                              <1> ;  return with pointer in [bx]
   976                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   977                              <1>         even
   978                              <1> regptr:		;	  proc    near
   979 0000065E 021E1000            <1>         add     bl,[tos]        ;get index to actual register
   980 00000662 83E307              <1>         and     bx,7            ;mask to 3 bits
   981 00000665 D1E3                <1>         shl     bx,1            ;index words
   982 00000667 2E8B9F[0602]        <1>   cs    mov     bx, [fp0tab+bx]  ; get offset into accumulator array
   983 0000066C C3                  <1>         ret
   984                              <1> ;regptr  endp
   985                              <1> 
   986                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   987                              <1> ;
   988                              <1> ; load IEEE 4-byte real to accumulator
   989                              <1> ;       es:di   points to value to load
   990                              <1> ;       si      points to accumulator to receive value
   991                              <1> ; uses: ax & dx
   992                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   993                              <1> load_R32:	;	    proc    near
   994 0000066D 268B5502            <1>   es    mov     dx, word [di+2]     ;get exponent
   995 00000671 31C0                <1>         xor     ax,ax
   996 00000673 D1E2                <1>         shl     dx,1            ; sign goes to carry
   997 00000675 D0D0                <1>         rcl     al,1            ; sign goes to AL
   998 00000677 884401              <1>         mov     [si+sign], al
   999 0000067A 88F0                <1>         mov     al,dh           ; ax is biased exponent
  1000 0000067C 09C0                <1>         or      ax,ax
  1001 0000067E 742B                <1>         jz      lr3201
  1002 00000680 3CFF                <1>         cmp     al,255          ; test for max exponent
  1003 00000682 7479                <1>         je      lr3211
  1004 00000684 C60400              <1>         mov     byte [si+tag], tag_valid
  1005                              <1> 
  1006 00000687 83E87F              <1>         sub     ax,127          ; get correct exponent
  1007 0000068A 894402              <1>         mov     [si+expon], ax
  1008 0000068D F9                  <1>         stc
  1009 0000068E D0DA                <1>         rcr     dl,1            ; put fractional part on mantissa
  1010 00000690 268B05              <1>   es    mov     ax, word [di]
  1011 00000693 88D6                <1>         mov     dh,dl
  1012 00000695 88E2                <1>         mov     dl,ah
  1013 00000697 895404              <1>         mov     [si+mantis], dx
  1014 0000069A 88C4                <1>         mov     ah,al
  1015 0000069C 30C0                <1>         xor     al,al
  1016 0000069E 894406              <1>         mov     word [si+mantis+2], ax
  1017                              <1> %if  BIG
  1018                              <1> lr3200:
  1019 000006A1 31C0                <1>         xor     ax,ax
  1020 000006A3 894408              <1>         mov     [si+mantis+4], ax           ; zero out low words
  1021 000006A6 89440A              <1>         mov     [si+mantis+6], ax
  1022                              <1> %endif
  1023 000006A9 EB71                <1>         jmp     lr3299
  1024                              <1> 
  1025                              <1> ; biased exponent was 0
  1026                              <1> lr3201:
  1027 000006AB 08D0                <1>         or      al,dl
  1028 000006AD 260B05              <1>   es    or      ax,word [di]
  1029 000006B0 7516                <1>         jnz     lr3202           ; not a real zero
  1030                              <1> ; got real zero
  1031 000006B2 C60401              <1>         mov     byte [si+tag], tag_zero
  1032 000006B5 C744020180          <1>         mov     word [si+expon], exp_of_FPzero
  1033                              <1> lr32015:
  1034 000006BA 894404              <1>         mov     [si+mantis], ax
  1035 000006BD 894406              <1>         mov     [si+mantis+2], ax
  1036                              <1> %if  BIG
  1037 000006C0 894408              <1>         mov     [si+mantis+4], ax
  1038 000006C3 89440A              <1>         mov     [si+mantis+6], ax
  1039                              <1> %endif
  1040 000006C6 EB54                <1>         jmp     lr3299
  1041                              <1> 
  1042                              <1> ; not a real zero -- actually a denormal
  1043                              <1> lr3202:
  1044 000006C8 6A02                <1>         push    Dexcept
  1045 000006CA E82415              <1>         call    exception
  1046                              <1> 
  1047 000006CD 268B05              <1>   es    mov     ax,word [di]     ; get second word
  1048 000006D0 D1E0                <1>         shl     ax,1
  1049 000006D2 80D200              <1>         adc     dl,0                ;move bit into dl
  1050                              <1> lr3203:
  1051 000006D5 FECE                <1>         dec     dh              ; count shifts
  1052 000006D7 D1E0                <1>         shl     ax,1            ; try to normalize
  1053 000006D9 D0D2                <1>         rcl     dl,1
  1054 000006DB 73F8                <1>         jnc     lr3203
  1055                              <1> 
  1056 000006DD D0DA                <1>         rcr     dl,1
  1057 000006DF D1D8                <1>         rcr     ax,1            ; bit has been put back
  1058 000006E1 86D4                <1>         xchg    dl,ah
  1059 000006E3 86D0                <1>         xchg    dl,al
  1060 000006E5 894404              <1>         mov     [si+mantis], ax
  1061 000006E8 86D4                <1>         xchg    dl,ah
  1062 000006EA 30C0                <1>         xor     al,al
  1063 000006EC 894406              <1>         mov     [si+mantis+2], ax
  1064 000006EF 88F0                <1>         mov     al,dh
  1065 000006F1 98                  <1>         cbw
  1066 000006F2 83E87F              <1>         sub     ax,127          ; get correct exponent
  1067 000006F5 894402              <1>         mov     [si+expon], ax
  1068 000006F8 C60400              <1>         mov     byte [si+tag], tag_valid           
  1069                              <1> %if BIG
  1070 000006FB EBA4                <1>         jmp     lr3200
  1071                              <1> %else
  1072                              <1>         jmp     lr3299
  1073                              <1> %endif
  1074                              <1> 
  1075                              <1>         
  1076                              <1> ; biased exponent was 255 -- possible infinity
  1077                              <1> lr3211:
  1078 000006FD 31C0                <1>         xor     ax,ax
  1079 000006FF 260A15              <1>   es    or      dl, byte [di]
  1080 00000702 260A5501            <1>   es    or      dl, byte [di+1]
  1081 00000706 750A                <1>         jnz     lr3215              ; if not zero in packed for, NaN
  1082 00000708 C60402              <1>         mov     byte [si+tag], tag_infin
  1083                              <1> lr3213:
  1084 0000070B C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
  1085 00000710 EBA8                <1>         jmp     lr32015
  1086                              <1> 
  1087                              <1> lr3215:
  1088 00000712 C60406              <1>         mov     byte [si+tag], tag_invalid
  1089 00000715 6A01                <1>         push    Iexcept
  1090 00000717 E8D714              <1>         call    exception
  1091                              <1> 
  1092 0000071A EBEF                <1>         jmp     lr3213
  1093                              <1> 
  1094                              <1> lr3299:
  1095 0000071C C3                  <1>         ret
  1096                              <1> ;load_R32    endp
  1097                              <1> 
  1098                              <1> ; end em187b.asm
   520                                  %include "em187c.asm"
   521                              <1> ; em187c.asm
   522                              <1> 
   523                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   524                              <1> ;
   525                              <1> ; load 2-byte integer to accumulator
   526                              <1> ;       es:di   points to value to load
   527                              <1> ;       si      points to accumulator to receive value
   528                              <1> ;
   529                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   530                              <1> load_I16:		;    proc    near
   531 0000071D 268B05              <1>   es    mov     ax,word [di]            ;get 16 bit word
   532 00000720 31DB                <1>         xor     bx,bx
   533 00000722 BF0F00              <1>         mov     di,15                   ;initial exponent
   534 00000725 EB11                <1>         jmp     short L3200
   535                              <1> ;load_I16    endp
   536                              <1> 
   537                              <1> 
   538                              <1> LDindef:
   539 00000727 6A01                <1>         push    Iexcept
   540 00000729 E8C514              <1>         call    exception
   541 0000072C EB2C                <1>         jmp     short L3204
   542                              <1> 
   543                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   544                              <1> ;
   545                              <1> ; load 4-byte integer to accumulator
   546                              <1> ;       es:di   points to value to load
   547                              <1> ;       si      points to accumulator to receive value
   548                              <1> ;
   549                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   550                              <1> load_I32:		;    proc    near
   551 0000072E 268B1D              <1>   es    mov     bx,[di]          ;get low order
   552 00000731 268B4502            <1>   es    mov     ax,[di+2]
   553 00000735 BF1F00              <1>         mov     di,31               ;initial exponent
   554                              <1> L3200:
   555                              <1> %if BIG
   556 00000738 31C9                <1>         xor     cx,cx               ;if 64 bit mantissas,
   557 0000073A 31D2                <1>         xor     dx,dx               ;  zero out the low order
   558                              <1> %endif
   559 0000073C C6440100            <1>         mov     byte [si+sign],0
   560 00000740 09C0                <1>         or      ax,ax           ;test sign of integer
   561 00000742 7D16                <1>         jge     L3204
   562                              <1> ; is negative, must negate
   563 00000744 FE4401              <1>         inc     byte [si+sign]       ;indicate negative value
   564 00000747 F7D0                <1>         not     ax
   565                              <1> %if BIG
   566 00000749 31ED                <1>         xor     bp,bp           ;get a zero
   567 0000074B F7D3                <1>         not     bx
   568 0000074D F7D1                <1>         not     cx
   569 0000074F F7DA                <1>         neg     dx
   570 00000751 F5                  <1>         cmc
   571 00000752 11E9                <1>         adc     cx,bp
   572 00000754 11EB                <1>         adc     bx,bp
   573 00000756 11E8                <1>         adc     ax,bp
   574                              <1> %else
   575                              <1>         neg     bx
   576                              <1>         cmc
   577                              <1>         adc     ax,0
   578                              <1> %endif
   579 00000758 78CD                <1>         js      LDindef
   580                              <1> L3204:
   581                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   582                              <1> ;
   583                              <1> ;   Normalize the value in AX:BX:[CX:DX], 
   584                              <1> ;   adjusting the exponent in di
   585                              <1> ;
   586                              <1> ;   Tag, exponent, and mantissa are stored at DS:SI if normal number
   587                              <1> ;   Tag and sign stored, too, if result is zero
   588                              <1> ;
   589                              <1> ;   BP is destroyed
   590                              <1> ;
   591                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   592                              <1> normalize_and_exit:
   593 0000075A 89C5                <1>         mov     bp,ax               ;test for zero result first
   594 0000075C 09DD                <1>         or      bp,bx               ;
   595                              <1> %if BIG
   596 0000075E 09CD                <1>         or      bp,cx
   597 00000760 09D5                <1>         or      bp,dx
   598                              <1> %endif
   599 00000762 7446                <1>         jz      NM060               ;result of FADD is zero
   600 00000764 C60400              <1>         mov     byte [si+tag], tag_valid
   601                              <1> NM055:
   602 00000767 09C0                <1>         or      ax,ax               ;test for hi zero
   603 00000769 750A                <1>         jnz     short NM056
   604 0000076B 93                  <1>         xchg    bx,ax
   605                              <1> %if BIG
   606 0000076C 87CB                <1>         xchg    cx,bx
   607 0000076E 87D1                <1>         xchg    dx,cx
   608                              <1> %endif
   609 00000770 83EF10              <1>         sub     di,16               ;decrease exponent
   610 00000773 EBF2                <1>         jmp     NM055
   611                              <1> NM056:
   612 00000775 08E4                <1>         or      ah,ah               ;test for hi zero byte
   613 00000777 7511                <1>         jnz     short   NM057
   614 00000779 86C4                <1>         xchg    al,ah
   615 0000077B 86F8                <1>         xchg    bh,al
   616 0000077D 86DF                <1>         xchg    bl,bh
   617                              <1> %if BIG
   618 0000077F 86EB                <1>         xchg    ch,bl
   619 00000781 86CD                <1>         xchg    cl,ch
   620 00000783 86F1                <1>         xchg    dh,cl
   621 00000785 86D6                <1>         xchg    dl,dh
   622                              <1> %endif
   623 00000787 83EF08              <1>         sub     di,8                ;adjust exponent
   624                              <1> NM057:
   625 0000078A F6C480              <1>         test    ah,80H              ;test for normalized bit
   626 0000078D 750B                <1>         jnz     NM058
   627                              <1> %if BIG
   628 0000078F D1E2                <1>         shl     dx,1                ;normalize a bit at a time
   629 00000791 D1D1                <1>         rcl     cx,1
   630 00000793 D1D3                <1>         rcl     bx,1
   631                              <1> %else
   632                              <1>         shl     bx,1
   633                              <1> %endif
   634 00000795 D1D0                <1>         rcl     ax,1
   635 00000797 4F                  <1>         dec     di                  ;decrease exponent
   636 00000798 EBF0                <1>         jmp     NM057
   637                              <1> 
   638                              <1> NM058:  ; non-zero result
   639 0000079A 897C02              <1>         mov     [si+expon],di       ;store new exponent
   640 0000079D 894404              <1>         mov     [si+mantis],ax
   641 000007A0 895C06              <1>         mov     [si+mantis+2],bx
   642                              <1> %if BIG
   643 000007A3 894C08              <1>         mov     [si+mantis+4],cx
   644 000007A6 89540A              <1>         mov     [si+mantis+6],dx
   645                              <1> %endif
   646 000007A9 C3                  <1>         ret
   647                              <1> 
   648                              <1> 
   649                              <1> NM060:  ; zero result
   650 000007AA C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   651 000007AD 884401              <1>         mov     [si+sign],al            ;all regs are zero
   652 000007B0 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   653 000007B3 EBE5                <1>         jmp     NM058
   654                              <1> 
   655                              <1> ;load_I32    endp
   656                              <1> 
   657                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   658                              <1> ;
   659                              <1> ;   FILD    qword ptr QJ        load 64-bit integer
   660                              <1> ;
   661                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   662                              <1> FLDi64:
   663 000007B5 E880FE              <1>         call    alloc                   ;get new ST
   664 000007B8 89DE                <1>         mov     si,bx                   ;SI will receive value
   665 000007BA 68[B601]            <1>         push    restore_segs     ; call to load_I64 returns to r_s
   666                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   667                              <1> ;
   668                              <1> ; load 8-byte integer to accumulator
   669                              <1> ;       es:di   points to value to load
   670                              <1> ;       si      points to accumulator to receive value
   671                              <1> ;
   672                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   673                              <1> load_I64:		;    proc    near
   674 000007BD 268B15              <1>   es    mov     dx,[di]      ;get lowest order
   675 000007C0 268B4D02            <1>   es    mov     cx,[di+2]
   676 000007C4 268B5D04            <1>   es    mov     bx,[di+4]
   677 000007C8 268B4506            <1>   es    mov     ax,[di+6]
   678 000007CC BF3F00              <1>         mov     di,63           ;initial exponent
   679                              <1> 
   680 000007CF C60400              <1>         mov     byte [si+tag], tag_valid
   681 000007D2 C6440100            <1>         mov     byte [si+sign],0
   682 000007D6 09C0                <1>         or      ax,ax           ;test sign of integer
   683 000007D8 7D1B                <1>         jge     L6404
   684                              <1> ; is negative, must negate
   685 000007DA FE4401              <1>         inc     byte [si+sign]       ;indicate negative value
   686 000007DD 31ED                <1>         xor     bp,bp           ;get a zero
   687 000007DF F7D0                <1>         not     ax
   688 000007E1 F7D3                <1>         not     bx
   689 000007E3 F7D1                <1>         not     cx
   690 000007E5 F7DA                <1>         neg     dx
   691 000007E7 F5                  <1>         cmc
   692 000007E8 11E9                <1>         adc     cx,bp
   693 000007EA 11EB                <1>         adc     bx,bp
   694 000007EC 11E8                <1>         adc     ax,bp
   695 000007EE 7905                <1>         jns     L6404
   696                              <1> ; loading integer indefinite
   697 000007F0 6A01                <1>         push    Iexcept
   698 000007F2 E8FC13              <1>         call    exception
   699                              <1> L6404:
   700 000007F5 89C5                <1>         mov     bp,ax               ;test for zero result first
   701 000007F7 09DD                <1>         or      bp,bx               ;
   702 000007F9 09CD                <1>         or      bp,cx
   703 000007FB 09D5                <1>         or      bp,dx
   704 000007FD 7443                <1>         jz      L6460               ;result is zero
   705                              <1> L6455:
   706 000007FF 09C0                <1>         or      ax,ax               ;test for hi zero
   707 00000801 750A                <1>         jnz     short   L6456
   708 00000803 93                  <1>         xchg    bx,ax
   709 00000804 87CB                <1>         xchg    cx,bx
   710 00000806 87D1                <1>         xchg    dx,cx
   711 00000808 83EF10              <1>         sub     di,16               ;decrease exponent
   712 0000080B EBF2                <1>         jmp     L6455
   713                              <1> L6456:
   714 0000080D 08E4                <1>         or      ah,ah               ;test for hi zero byte
   715 0000080F 7511                <1>         jnz     short   L6457
   716 00000811 86C4                <1>         xchg    al,ah
   717 00000813 86F8                <1>         xchg    bh,al
   718 00000815 86DF                <1>         xchg    bl,bh
   719 00000817 86EB                <1>         xchg    ch,bl
   720 00000819 86CD                <1>         xchg    cl,ch
   721 0000081B 86F1                <1>         xchg    dh,cl
   722 0000081D 86D6                <1>         xchg    dl,dh
   723 0000081F 83EF08              <1>         sub     di,8                ;adjust exponent
   724                              <1> L6457:
   725 00000822 F6C480              <1>         test    ah,80H              ;test for normalized bit
   726 00000825 750B                <1>         jnz     L6458
   727 00000827 D1E2                <1>         shl     dx,1                ;normalize a bit at a time
   728 00000829 D1D1                <1>         rcl     cx,1
   729 0000082B D1D3                <1>         rcl     bx,1
   730 0000082D D1D0                <1>         rcl     ax,1
   731 0000082F 4F                  <1>         dec     di                  ;decrease exponent
   732 00000830 EBF0                <1>         jmp     L6457
   733                              <1> 
   734                              <1> L6458:  ; non-zero result
   735 00000832 897C02              <1>         mov     [si+expon],di       ;store new exponent
   736 00000835 894404              <1>         mov     [si+mantis],ax
   737 00000838 895C06              <1>         mov     [si+mantis+2],bx
   738                              <1> %if BIG
   739 0000083B 894C08              <1>         mov     [si+mantis+4],cx
   740 0000083E 89540A              <1>         mov     [si+mantis+6],dx
   741                              <1> %endif
   742 00000841 C3                  <1>         ret
   743                              <1> 
   744                              <1> 
   745                              <1> L6460:  ; zero result
   746 00000842 C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   747 00000845 884401              <1>         mov     [si+sign],al            ;all regs are zero
   748 00000848 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   749 0000084B EBE5                <1>         jmp     L6458
   750                              <1> 
   751                              <1> ;load_I64    endp
   752                              <1> 
   753                              <1> 
   754                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   755                              <1> ;   Store a REAL 32-bit value
   756                              <1> ;
   757                              <1> ;       ES:DI is the destination address
   758                              <1> ;       SI is the source address
   759                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   760                              <1> store_R32:		;   proc    near
   761 0000084D 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test for problem tags
   762 00000850 7338                <1>         jae     str3270             ;jump if not tag_valid
   763 00000852 8B4402              <1>         mov     ax,[si+expon]       ;get exponent
   764 00000855 8B5C04              <1>         mov     bx,[si+mantis]      ;get high order mantissa
   765 00000858 8B4C06              <1>         mov     cx,[si+mantis+2]    ;get lower order mantissa
   766 0000085B 81C18000            <1>         add     cx,0080H            ;round to nearest for now
   767 0000085F 83D300              <1>         adc     bx,0                ;continue
   768 00000862 7221                <1>         jc      str3250             ;jump if carry
   769                              <1> str3210:
   770 00000864 83E881              <1>         sub     ax,-127             ;bias the exponent
   771 00000867 7E37                <1>         jle     str3279             ;go store +0.0
   772 00000869 3DFF00              <1>         cmp     ax,255              ;check for overflow
   773 0000086C 7342                <1>         jae     str3285             ;overflow
   774 0000086E 88C6                <1>         mov     dh,al               ;exponent to DH
   775 00000870 88FA                <1>         mov     dl,bh               ;hi-mantissa to DL
   776 00000872 D0E2                <1>         shl     dl,1                ;hide hi-bit
   777 00000874 0A5401              <1>         or      dl,[si+sign]        ;get sign in low order
   778 00000877 D1CA                <1>         ror     dx,1                ;get high word of result
   779 00000879 26895502            <1>   es    mov     [di+2],dx        ;store it
   780 0000087D 88D9                <1>         mov     cl,bl               ;form low word
   781 0000087F 86CD                <1>         xchg    cl,ch               ;swap bytes
   782 00000881 26890D              <1>   es    mov     [di],cx          ;store low word of result
   783                              <1> str3299:
   784 00000884 C3                  <1>         ret
   785                              <1> ; 
   786                              <1> ; carry occurred on round to nearest; fix the exponent and result
   787                              <1> str3250:
   788 00000885 D1DB                <1>         rcr     bx,1                ;put hi-bit back
   789 00000887 40                  <1>         inc     ax                  ;increment the exponent
   790 00000888 EBDA                <1>         jmp     str3210             ;CX is zero
   791                              <1> str3270:
   792 0000088A 771D                <1>         ja      str3280             ;jump if not tag_zero
   793                              <1> str3275:
   794                              <1> ; store signed zero
   795 0000088C 31C0                <1>         xor     ax,ax
   796                              <1> str3276:
   797 0000088E 8A5C01              <1>         mov     bl,[si+sign]        ;get the sign
   798 00000891 D0EB                <1>         shr     bl,1
   799 00000893 D1D8                <1>         rcr     ax,1                ;move sign to hi-bit
   800                              <1> str3277:
   801 00000895 26894502            <1>   es    mov     [di+2],ax        ;
   802 00000899 31C0                <1>         xor     ax,ax               ;zap it out
   803 0000089B 268905              <1>   es    mov     [di],ax          ;store low zero
   804 0000089E EBE4                <1>         jmp     str3299
   805                              <1> 
   806                              <1> ; store absolute zero
   807                              <1> str3279:
   808 000008A0 6A10                <1>         push    Uexcept             ;underflow
   809 000008A2 E84C13              <1>         call    exception
   810                              <1> 
   811 000008A5 31C0                <1>         xor     ax,ax               ;zap hi-word
   812 000008A7 EBEC                <1>         jmp     str3277
   813                              <1> 
   814                              <1> ; tag is not zero
   815                              <1> str3280:
   816 000008A9 803C02              <1>         cmp     byte [si+tag], tag_infin ;test for infinity
   817 000008AC 7407                <1>         je      str3286
   818 000008AE 770A                <1>         ja      str3290
   819                              <1> ; store signed infinity
   820                              <1> str3285:
   821 000008B0 6A08                <1>         push    Oexcept             ;overflow
   822 000008B2 E83C13              <1>         call    exception
   823                              <1> str3286:
   824 000008B5 B800FF              <1>         mov     ax,0FF00h           ;following code will store sign
   825 000008B8 EBD4                <1>         jmp     str3276             ;go put on sign
   826                              <1> 
   827                              <1> ; store indefinite
   828                              <1> str3290:
   829 000008BA B8C0FF              <1>         mov     ax,0FFC0h           ;get indefinite code
   830 000008BD 6A01                <1>         push    Iexcept             ;invalid operation
   831 000008BF E82F13              <1>         call    exception
   832 000008C2 EBD1                <1>         jmp     str3277             ;go store it
   833                              <1> ;store_R32   endp
   834                              <1> 
   835                              <1> 
   836                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   837                              <1> ;
   838                              <1> ;   FCHS        change the sign of ST
   839                              <1> ;
   840                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   841                              <1> gFCHS:
   842 000008C4 30DB                <1>         xor     bl,bl               ;get ST pointer
   843 000008C6 E895FD              <1>         call    regptr              ; in BX
   844 000008C9 80770101            <1>         xor     byte [bx+sign],1         ;invert the sign
   845 000008CD E9E6F8              <1>         jmp     restore_segs
   846                              <1> 
   847                              <1> 
   848                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   849                              <1> ;
   850                              <1> ;   FABS        absolute value of ST
   851                              <1> ;
   852                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   853                              <1> gFABS:
   854 000008D0 30DB                <1>         xor     bl,bl               ;get ST pointer
   855 000008D2 E889FD              <1>         call    regptr              ; in BX
   856 000008D5 C6470100            <1>         mov     byte [bx+sign],0         ;clear the sign
   857 000008D9 E9DAF8              <1>         jmp     restore_segs
   858                              <1> 
   859                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   860                              <1> ;
   861                              <1> ;   FADD    mem         add memory to ST
   862                              <1> ;
   863                              <1> ;       ES:DI is pointer to memory location
   864                              <1> ;
   865                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   866                              <1> genFADD:
   867 000008DC BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   868 000008DF BB0600              <1>         mov     bx,FMbits           ;get format mask
   869 000008E2 20EB                <1>         and     bl,ch
   870 000008E4 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   871 000008E9 30DB                <1>         xor     bl,bl
   872 000008EB E870FD              <1>         call    regptr              ;get ST pointer in BX
   873 000008EE 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   874                              <1> ;  call to  do_add  returns to  restore_segs
   875 000008F0 68[B601]            <1>         push    restore_segs
   876 000008F3 E9A9FA              <1>         JMP     do_add
   877                              <1> 
   878                              <1> 
   879                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   880                              <1> ;
   881                              <1> ;   FSUB    mem         ST := ST - mem
   882                              <1> ;
   883                              <1> ;       ES:DI is pointer to memory location
   884                              <1> ;
   885                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   886                              <1> genFSUB:
   887 000008F6 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   888 000008F9 BB0600              <1>         mov     bx,FMbits           ;get format mask
   889 000008FC 20EB                <1>         and     bl,ch
   890 000008FE 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   891 00000903 30DB                <1>         xor     bl,bl
   892 00000905 E856FD              <1>         call    regptr              ;get ST pointer in BX
   893 00000908 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   894 0000090A 80740101            <1>         xor     byte [si+sign],01h       ;invert the sign
   895                              <1> ;  call to  do_add  returns to  restore_segs
   896 0000090E 68[B601]            <1>         push    restore_segs
   897 00000911 E98BFA              <1>         JMP     do_add
   898                              <1> 
   899                              <1> 
   900                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   901                              <1> ;
   902                              <1> ;   FSUBR   mem         ST := mem - ST
   903                              <1> ;
   904                              <1> ;       ES:DI is pointer to memory location
   905                              <1> ;
   906                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   907                              <1> genFSUBR:
   908 00000914 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   909 00000917 BB0600              <1>         mov     bx,FMbits           ;get format mask
   910 0000091A 20EB                <1>         and     bl,ch
   911 0000091C 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   912 00000921 30DB                <1>         xor     bl,bl
   913 00000923 E838FD              <1>         call    regptr              ;get ST pointer in BX
   914 00000926 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   915 00000928 80750101            <1>         xor     byte [di+sign],01h       ;invert the sign
   916                              <1> 
   917                              <1> ;  call to  do_add  returns to  restore_segs
   918 0000092C 68[B601]            <1>         push    restore_segs
   919 0000092F E96DFA              <1>         JMP     do_add
   920                              <1> 
   921                              <1> 
   922                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   923                              <1> ;
   924                              <1> ;   FDECSTP         decrement the stack pointer
   925                              <1> ;
   926                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   927                              <1> gFDECSTP:
   928 00000932 FE0E1000            <1>         dec     byte [tos]
   929 00000936 8026100007          <1>         and     byte [tos],7           ;mask to 3 bits
   930 0000093B E978F8              <1>         jmp     restore_segs
   931                              <1> 
   932                              <1> 
   933                              <1> 
   934                              <1> 
   935                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   936                              <1> ;
   937                              <1> ;   FINCSTP         increment the stack pointer
   938                              <1> ;
   939                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   940                              <1> gFINCSTP:
   941 0000093E FE061000            <1>         inc     byte [tos]
   942 00000942 8026100007          <1>         and     byte [tos],7           ;mask to 3 bits
   943 00000947 E96CF8              <1>         jmp     restore_segs
   944                              <1> 
   945                              <1> 
   946                              <1> 
   947                              <1>         even
   948                              <1> %if BIG
   949                              <1> ptanCon:
   950                              <1> ;	ACCUM   <tag_valid, 0, 4, 087c0H, 0, 0, 0>
   951 0000094A 0000                <1> 	db	tag_valid, 0
   952 0000094C 0400C0870000000000- <1> 	dw	4, 087c0H, 0, 0, 0
   952 00000955 00                  <1>
   953                              <1> ;       ACCUM   <tag_valid, 1, 3, 0f000H, 0, 0, 0>
   954 00000956 0001                <1> 	db	tag_valid, 1
   955 00000958 030000F00000000000- <1> 	dw	3, 0f000H, 0, 0, 0
   955 00000961 00                  <1>
   956                              <1> ;       ACCUM   <tag_valid, 0, 3, 0d000H, 0, 0, 0>
   957 00000962 0000                <1> 	db	tag_valid, 0
   958 00000964 030000D00000000000- <1> 	dw	3, 0d000H, 0, 0, 0
   958 0000096D 00                  <1>
   959                              <1> ;       ACCUM   <tag_valid, 1, 3, 0b000H, 0, 0, 0>
   960 0000096E 0001                <1> 	db	tag_valid, 1
   961 00000970 030000B00000000000- <1> 	dw	3, 0b000H, 0, 0, 0
   961 00000979 00                  <1>
   962                              <1> ;       ACCUM   <tag_valid, 0, 3, 09000H, 0, 0, 0>
   963 0000097A 0000                <1> 	db	tag_valid, 0
   964 0000097C 030000900000000000- <1> 	dw	3, 09000H, 0, 0, 0
   964 00000985 00                  <1>
   965                              <1> ;       ACCUM   <tag_valid, 1, 2, 0e000H, 0, 0, 0>
   966 00000986 0001                <1> 	db	tag_valid, 1
   967 00000988 020000E00000000000- <1> 	dw	2, 0e000H, 0, 0, 0
   967 00000991 00                  <1>
   968                              <1> ;       ACCUM   <tag_valid, 0, 2, 0a000H, 0, 0, 0>
   969 00000992 0000                <1> 	db	tag_valid, 0
   970 00000994 020000A00000000000- <1> 	dw	2, 0a000H, 0, 0, 0
   970 0000099D 00                  <1>
   971                              <1> ;       ACCUM   <tag_valid, 1, 1, 0c000H, 0, 0, 0>
   972 0000099E 0001                <1> 	db	tag_valid, 1
   973 000009A0 010000C00000000000- <1> 	dw	1, 0c000H, 0, 0, 0
   973 000009A9 00                  <1>
   974                              <1> ;       ACCUM   <tag_valid, 0, 0, 08000H, 0, 0, 0>
   975 000009AA 0000                <1> 	db	tag_valid, 0
   976 000009AC 000000800000000000- <1> 	dw	0, 08000H, 0, 0, 0
   976 000009B5 00                  <1>
   977                              <1> %else
   978                              <1> ptanCon:
   979                              <1> ;	ACCUM   <tag_valid, 0, 3, 08f20H, 0>
   980                              <1> 	db	tag_valid, 0
   981                              <1> 	dw	3, 08f20H, 0
   982                              <1> ;       ACCUM   <tag_valid, 1, 2, 0e000H, 0>
   983                              <1> 	db	tag_valid, 1
   984                              <1> 	dw	2, 0e000H, 0
   985                              <1> ;       ACCUM   <tag_valid, 0, 2, 0a000H, 0>
   986                              <1> 	db	tag_valid, 0
   987                              <1> 	dw	2, 0a000H, 0
   988                              <1> ;       ACCUM   <tag_valid, 1, 1, 0c000H, 0>
   989                              <1> 	db	tag_valid, 1
   990                              <1> 	dw	1, 0c000H, 0
   991                              <1> ;       ACCUM   <tag_valid, 0, 0, 08000H, 0>
   992                              <1> 	db	tag_valid, 0
   993                              <1> 	dw	0, 08000H, 0
   994                              <1> %endif
   995                              <1> ptanConLen equ $-ptanCon
   996                              <1> %if (ptanConLen > lenCreg)
   997                              <1> 	%error not enough constant space in Creg
   998                              <1> %endif
   999                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1000                              <1> ;
  1001                              <1> ;   FPTAN           8087 partial tangent
  1002                              <1> ;
  1003                              <1> ;       use the continued fraction approximation:
  1004                              <1> ;
  1005                              <1> ;       abs(x) <= pi/4
  1006                              <1> ;
  1007                              <1> ;   tan(x)/x = 1/1-xx/3-xx/5-xx/7-xx/9-...
  1008                              <1> ;       where xx = x*x
  1009                              <1> ;
  1010                              <1> ;   Enter with X on the top of the stack.  Leave it there
  1011                              <1> ;   and compute the denominator 1-xx/3-xx/5-... and push it
  1012                              <1> ;   on the stack.  A following FDIV instruction will yield
  1013                              <1> ;   the tangent.
  1014                              <1> ;
  1015                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1016                              <1> gFPTAN:
  1017 000009B6 B93600              <1>         mov     cx,ptanConLen/2         ;number of words to move
  1018 000009B9 BE[4A09]            <1>         mov     si,ptanCon       ;start of constant list
  1019 000009BC E83B10              <1>         call    moveconsts              ;address constants from DS
  1020                              <1> 
  1021 000009BF 30DB                <1>         xor     bl,bl                   ;get ST pointer
  1022 000009C1 E89AFC              <1>         call    regptr                  ;  in BX
  1023 000009C4 803F01              <1>         cmp     byte [bx+tag], tag_zero
  1024 000009C7 774E                <1>         ja      PT100                   ;error
  1025                              <1> %if BIG
  1026 000009C9 837F02E0            <1>         cmp     word [bx+expon], -32
  1027                              <1> %else
  1028                              <1>         cmp     word [bx+expon], -16
  1029                              <1> %endif
  1030 000009CD 7C45                <1>         jl      PT070                   ;value is very small
  1031                              <1> 
  1032 000009CF 89DE                <1>         mov     si,bx                   ;set for multiplication
  1033 000009D1 89DF                <1>         mov     di,bx                   ; **
  1034 000009D3 E862FC              <1>         call    alloc                   ;get new stack location
  1035 000009D6 891E1800            <1>         mov     [trptr2],bx               ;save XX ptr
  1036 000009DA E89306              <1>         call    do_mul                  ;SI is ptr to  XX
  1037 000009DD 89F7                <1>         mov     di,si                   ;DI->XX
  1038 000009DF 8B361600            <1>         mov     si,[trptr]                ;get constant pointer
  1039 000009E3 C6061B0008          <1>         mov     byte [trctr],ptanConLen/lenAccum - 1   ;count thru constants
  1040 000009E8 EB09                <1>         jmp     PT030
  1041                              <1> PT020:
  1042 000009EA 89F3                <1>         mov     bx,si                   ;sum to Areg
  1043 000009EC E8B0F9              <1>         call    do_add                  ;SI->denom
  1044 000009EF 8B3E1800            <1>         mov     di,[trptr2]               ;DI->XX
  1045                              <1> PT030:
  1046 000009F3 BB2C00              <1>         mov     bx,Areg          ;
  1047 000009F6 E85408              <1>         call    do_div                  ;SI->XX/denom (Areg)
  1048 000009F9 8B3E1600            <1>         mov     di,[trptr]
  1049 000009FD 83C70C              <1>         add     di,lenAccum             ;point at next constant
  1050 00000A00 893E1600            <1>         mov     [trptr],di
  1051 00000A04 FE0E1B00            <1>         dec     byte [trctr]
  1052 00000A08 75E0                <1>         jnz     PT020
  1053                              <1> 
  1054 00000A0A 8B1E1800            <1>         mov     bx,[trptr2]               ;sum to ST
  1055 00000A0E E88EF9              <1>         call    do_add                  ;DI->denom
  1056                              <1> PT099:
  1057 00000A11 E9A2F7              <1>         jmp     restore_segs
  1058                              <1> 
  1059                              <1> PT070:      ; exponent is so very small
  1060 00000A14 E949FB              <1>         jmp     gFLD1                   ;
  1061                              <1> 
  1062                              <1> PT100:      ; top of stack is not valid
  1063 00000A17 E81EFC              <1>         call    alloc
  1064 00000A1A C60706              <1>         mov     byte [bx+tag], tag_invalid
  1065                              <1> 
  1066 00000A1D 6A01                <1>         push    Iexcept
  1067 00000A1F E8CF11              <1>         call    exception
  1068 00000A22 EBED                <1>         jmp     PT099
  1069                              <1> 
  1070                              <1> 
  1071                              <1> 	even
  1072                              <1> %if BIG
  1073                              <1> f2xm1Con:
  1074                              <1> ;	ACCUM	<tag_valid, 1, 6, 0cfbfH, 0828eH, 0879aH, 0eed4H>
  1075 00000A24 0001                <1> 	db	tag_valid, 1
  1076 00000A26 0600BFCF8E829A87D4- <1> 	dw	6, 0cfbfH, 0828eH, 0879aH, 0eed4H
  1076 00000A2F EE                  <1>
  1077                              <1> ;	ACCUM	<tag_valid, 0, 12, 0a3e8H, 0660eH, 063d3H, 01526H>
  1078 00000A30 0000                <1> 	db	tag_valid, 0
  1079 00000A32 0C00E8A30E66D36326- <1> 	dw	12, 0a3e8H, 0660eH, 063d3H, 01526H
  1079 00000A3B 15                  <1>
  1080                              <1> ;	ACCUM	<tag_valid, 1, 17, 0a292H, 08a64H, 0d703H, 074a4H>
  1081 00000A3C 0001                <1> 	db	tag_valid, 1
  1082 00000A3E 110092A2648A03D7A4- <1> 	dw	17, 0a292H, 08a64H, 0d703H, 074a4H
  1082 00000A47 74                  <1>
  1083                              <1> ;	ACCUM	<tag_valid, 0, 21, 0dbe2H, 02ee9H, 08949H, 0c206H>
  1084 00000A48 0000                <1> 	db	tag_valid, 0
  1085 00000A4A 1500E2DBE92E498906- <1> 	dw	21, 0dbe2H, 02ee9H, 08949H, 0c206H
  1085 00000A53 C2                  <1>
  1086                              <1> ;	ACCUM	<tag_valid, 1, 25, 0ce32H, 03827H, 0285dH, 05fdcH>
  1087 00000A54 0001                <1> 	db	tag_valid, 1
  1088 00000A56 190032CE27385D28DC- <1> 	dw	25, 0ce32H, 03827H, 0285dH, 05fdcH
  1088 00000A5F 5F                  <1>
  1089                              <1> ;	ACCUM	<tag_valid, 0, 29, 08225H, 08eb0H, 0c7e7H, 09b90H>
  1090 00000A60 0000                <1> 	db	tag_valid, 0
  1091 00000A62 1D002582B08EE7C790- <1> 	dw	29, 08225H, 08eb0H, 0c7e7H, 09b90H
  1091 00000A6B 9B                  <1>
  1092                              <1> ;	ACCUM	<tag_valid, 1, 31, 0c92cH, 06ff2H, 0ed46H, 050cbH>
  1093 00000A6C 0001                <1> 	db	tag_valid, 1
  1094 00000A6E 1F002CC9F26F46EDCB- <1> 	dw	31, 0c92cH, 06ff2H, 0ed46H, 050cbH
  1094 00000A77 50                  <1>
  1095                              <1> ;	ACCUM	<tag_valid, 0, 33, 0911dH, 0b676H, 0b025H, 0cdc2H>
  1096 00000A78 0000                <1> 	db	tag_valid, 0
  1097 00000A7A 21001D9176B625B0C2- <1> 	dw	33, 0911dH, 0b676H, 0b025H, 0cdc2H
  1097 00000A83 CD                  <1>
  1098                              <1> 
  1099                              <1> ;	ACCUM	<tag_valid, 0, 10, 0c854H, 0ee83H, 05d90H, 0364bH>
  1100 00000A84 0000                <1> 	db	tag_valid, 0
  1101 00000A86 0A0054C883EE905D4B- <1> 	dw	10, 0c854H, 0ee83H, 05d90H, 0364bH
  1101 00000A8F 36                  <1>
  1102                              <1> ;	ACCUM	<tag_valid, 0, 18, 0fe16H, 06f19H, 03deeH, 0d4d4H>
  1103 00000A90 0000                <1> 	db	tag_valid, 0
  1104 00000A92 120016FE196FEE3DD4- <1> 	dw	18, 0fe16H, 06f19H, 03deeH, 0d4d4H
  1104 00000A9B D4                  <1>
  1105                              <1> ;	ACCUM	<tag_valid, 0, 24, 0f7e6H, 00399H, 0de4bH, 07174H>
  1106 00000A9C 0000                <1> 	db	tag_valid, 0
  1107 00000A9E 1800E6F799034BDE74- <1> 	dw	24, 0f7e6H, 00399H, 0de4bH, 07174H
  1107 00000AA7 71                  <1>
  1108                              <1> 
  1109                              <1> %else
  1110                              <1> f2xm1Con:
  1111                              <1> ;	ACCUM   <tag_valid, 0, 6, 0aed5H, 0c231H>
  1112                              <1> 	db	tag_valid, 0
  1113                              <1> 	dw	6, 0aed5H, 0c231H
  1114                              <1> ;	ACCUM   <tag_valid, 0, 9, 09a7eH, 039aaH>
  1115                              <1> 	db	tag_valid, 0
  1116                              <1> 	dw	9, 09a7eH, 039aaH
  1117                              <1> ;	ACCUM   <tag_valid, 0, -5, 08df4H, 0dff9H>
  1118                              <1> 	db	tag_valid, 0
  1119                              <1> 	dw	-5, 08df4H, 0dff9H
  1120                              <1> ;	ACCUM   <tag_valid, 0, 3, 09f46H, 0063aH>
  1121                              <1> 	db	tag_valid, 0
  1122                              <1> 	dw	3, 09f46H, 0063aH
  1123                              <1> %endif
  1124                              <1> f2xm1ConLen equ $-f2xm1Con
  1125                              <1> %if (f2xm1ConLen > lenCreg)
  1126                              <1>     %error not enough constant space in Creg
  1127                              <1> %endif
  1128                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1129                              <1> ;
  1130                              <1> ;   F2XM1	2**X - 1
  1131                              <1> ;
  1132                              <1> ;	-1 < X < 1  --  for the 187/387
  1133                              <1> ;
  1134                              <1> ;	Enter with X on the stack top.  Compute 2**X-1, replacing
  1135                              <1> ;	stack top with output.
  1136                              <1> ;
  1137                              <1> ;    Method:
  1138                              <1> ;	To compute  exp(x),  take the Gaussian continued fraction:
  1139                              <1> ;	 x 
  1140                              <1> ;	e  =  1/1 - x/1 + x/2 - x/3 + x/2 - x/5 + x/2 - x/7 + x/2 -+ ...
  1141                              <1> ;
  1142                              <1> ;	and truncate at the ninth term.  Rearrange to:
  1143                              <1> ;
  1144                              <1> ;			    2 	    3    4
  1145                              <1> ;	1680 + 840 x + 180 x  + 20 x  + x
  1146                              <1> ;       -----------------------------------
  1147                              <1> ;			    2 	    3    4
  1148                              <1> ;	1680 - 840 x + 180 x  - 20 x  + x
  1149                              <1> ;
  1150                              <1> ;	which becomes:
  1151                              <1> ;
  1152                              <1> ;	1 + 2x / (b3 * x**2 - x + b4 -  b2 / (x**2 + b1) )
  1153                              <1> ;
  1154                              <1> ;	where b1..b4 are constants.  Finally substitute x = y * ln 2
  1155                              <1> ;	and derive the constants C1..C4.  Compute as above, omitting the
  1156                              <1> ;	" 1 + ".
  1157                              <1> ;
  1158                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1159                              <1> FX100:
  1160 00000AA8 6A01                <1>         push    Iexcept
  1161 00000AAA E84411              <1>         call    exception
  1162 00000AAD E99400              <1>         jmp     FX099
  1163                              <1> 
  1164                              <1> gF2XM1:
  1165 00000AB0 B94200              <1>         mov     cx,f2xm1ConLen/2        ;number of words to move
  1166 00000AB3 BE[240A]            <1>         mov     si,f2xm1Con      ;start of constant list
  1167 00000AB6 E8410F              <1>         call    moveconsts              ;address constants from DS
  1168                              <1> 
  1169 00000AB9 30DB                <1>         xor     bl,bl                   ;get ST pointer
  1170 00000ABB E8A0FB              <1>         call    regptr                  ;  in BX
  1171 00000ABE 803F01              <1>         cmp     byte [bx+tag], tag_zero
  1172 00000AC1 77E5                <1>         ja      FX100			;error
  1173                              <1> 
  1174 00000AC3 891E1800            <1> 	mov	[trptr2],bx		;save ST pointer
  1175                              <1> 
  1176                              <1> %if BIG
  1177                              <1> ; 64-bit mantissa version
  1178 00000AC7 89DE                <1> 	mov	si,bx			;SI = X ptr
  1179 00000AC9 BB2C00              <1> 	mov	bx,Areg
  1180 00000ACC C6061B0008          <1> 	mov	byte [trctr],8			;count 8 coefficients
  1181                              <1> ; DI has trptr
  1182 00000AD1 EB0B                <1> 	jmp	short FX020
  1183                              <1> 
  1184                              <1> FX010:
  1185 00000AD3 89F3                <1> 	mov	bx,si			;point to destination
  1186 00000AD5 8B3E1800            <1> 	mov	di,[trptr2]		;get X pointer
  1187 00000AD9 E89405              <1> 	call	do_mul			; * X
  1188 00000ADC 89F3                <1> 	mov	bx,si			; set to add another Coeff
  1189                              <1> FX020:
  1190 00000ADE 8B3E1600            <1> 	mov	di,[trptr]		; get next trptr
  1191 00000AE2 E8BAF8              <1> 	call	do_add
  1192 00000AE5 830616000C          <1> 	add	word [trptr],lenAccum		;bump the coeff ptr
  1193 00000AEA FE0E1B00            <1> 	dec	byte [trctr]
  1194 00000AEE 75E3                <1> 	jnz	FX010
  1195                              <1> 
  1196                              <1> ; now compute X*X to the Breg
  1197 00000AF0 8B361800            <1> 	mov	si,[trptr2]		;get ST pointer
  1198 00000AF4 89F7                <1> 	mov	di,si			;copy it
  1199 00000AF6 BB3800              <1> 	mov	bx,Breg
  1200 00000AF9 E87405              <1> 	call	do_mul			;Breg is X*X
  1201 00000AFC BBBC00              <1> 	mov	bx,Creg + lenAccum*2	;place to put it
  1202 00000AFF C6061B0003          <1> 	mov	byte [trctr],3			;count 3 coefficients
  1203 00000B04 EB0A                <1> 	jmp	short FX040
  1204                              <1> 
  1205                              <1> FX030:
  1206 00000B06 89F3                <1> 	mov	bx,si			;point to destination
  1207 00000B08 BF3800              <1> 	mov	di,Breg		;get X pointer
  1208 00000B0B E86205              <1> 	call	do_mul			; * X
  1209 00000B0E 89F3                <1> 	mov	bx,si			; set to add another Coeff
  1210                              <1> FX040:
  1211 00000B10 8B3E1600            <1> 	mov	di,[trptr]		; get next trptr
  1212 00000B14 E888F8              <1> 	call	do_add
  1213 00000B17 830616000C          <1> 	add	word [trptr],lenAccum		;bump the coeff ptr
  1214 00000B1C FE0E1B00            <1> 	dec	byte [trctr]
  1215 00000B20 75E4                <1> 	jnz	FX030
  1216                              <1> 
  1217 00000B22 8B3E1800            <1> 	mov	di,[trptr2]		;get stack top
  1218 00000B26 89FB                <1> 	mov	bx,di			;result there
  1219 00000B28 E84505              <1> 	call	do_mul			;ST = X * num
  1220 00000B2B 89F3                <1> 	mov	bx,si
  1221 00000B2D BFA400              <1> 	mov	di,Creg		;get first coeff ptr
  1222 00000B30 C6450100            <1> 	mov	byte [di+sign],0		;set positive
  1223 00000B34 E83905              <1> 	call	do_mul			; ST = coeff * X * num
  1224 00000B37 89F7                <1> 	mov	di,si
  1225 00000B39 BE2C00              <1> 	mov	si,Areg		;denominator ptr
  1226 00000B3C 89FB                <1> 	mov	bx,di			;put result in stack top
  1227 00000B3E E80C07              <1> 	call	do_div
  1228 00000B41 FF4402              <1> 	inc	word [si+expon]		;double it
  1229                              <1> %else
  1230                              <1> ; 32-bit mantissa version
  1231                              <1> 	mov	si,bx			;set to get X*X
  1232                              <1> 	mov	di,bx			; **
  1233                              <1> 	mov	bx,Areg		;put X*X in Areg
  1234                              <1> 	call	do_mul			;SI points at Areg
  1235                              <1> 	mov	di,[trptr]		;get Creg ptr
  1236                              <1> 	mov	bx,di			;result to Creg
  1237                              <1> 	call	do_add			;C1 + X*X in Creg
  1238                              <1> 	mov	di,si			;Creg ptr to DI
  1239                              <1> 	add	di,lenAccum		;C2 ptr to DI
  1240                              <1> 	mov	bx,di
  1241                              <1> 	call	do_div			;C2 = C2/(x*x + C1)
  1242                              <1> 	push	si			;save C2 ptr
  1243                              <1> 	add	si,lenAccum		;get c3 pointer
  1244                              <1> 	mov	di,Areg		;get X*X pointer
  1245                              <1> 	mov	bx,si			;result to C3
  1246                              <1> 	call	do_mul			;C3 = C3 * X*X
  1247                              <1> 	mov	di,si			;
  1248                              <1> 	add	di,lenAccum		;get C4 pointer in DI
  1249                              <1> 	mov	bx,di			;result to C4
  1250                              <1> 	call	do_add
  1251                              <1> 	pop	di			;restore C2 pointer
  1252                              <1> 	push	si			;save C4 pointer
  1253                              <1> 	mov	si,[trptr2]		;get ST pointer
  1254                              <1> 	mov	bx,di			;C2 gets sum
  1255                              <1> 	call	do_add			;C2 = X + C2/()
  1256                              <1> 	xor	byte [si+sign],01		;negate it
  1257                              <1> 	pop	di			;get C4 pointer
  1258                              <1> 	mov	bx,di
  1259                              <1> 	call	do_add			;result to C4
  1260                              <1> 	mov	di,[trptr2]		;get ST pointer again
  1261                              <1> 	mov	bx,di
  1262                              <1> 	call	do_div			;get half of result
  1263                              <1> 	inc	word [si+expon]		;get result
  1264                              <1> %endif
  1265                              <1> FX099:
  1266 00000B44 E96FF6              <1> 	jmp	restore_segs		;and exit
  1267                              <1> 
  1268                              <1> 
  1269                              <1> 
  1270 00000B47 90                  <1> 	even
  1271                              <1> %if BIG
  1272                              <1> fl2xCon1:
  1273 00000B48 0001                <1> 	db	tag_valid, 1
  1274 00000B4A 010004B533F3DEF984- <1> 	dw	1, 0b504H, 0f333H, 0f9deH, 06484H;-sqrt(0.5)
  1274 00000B53 64                  <1>
  1275 00000B54 0000                <1> 	db	tag_valid, 0
  1276 00000B56 04007680F06B104078- <1> 	dw	4, 08076H, 06bf0H, 04010H, 0a778H	;c23
  1276 00000B5F A7                  <1>
  1277 00000B60 0000                <1> 	db	tag_valid, 0
  1278 00000B62 0400B28C3776A4E4A8- <1> 	dw	4, 08cb2H, 07637H, 0e4a4H, 086a8H	;c21
  1278 00000B6B 86                  <1>
  1279 00000B6C 0000                <1> 	db	tag_valid, 0
  1280 00000B6E 0400819BFAE07F6825- <1> 	dw	4, 09b81H, 0e0faH, 0687fH, 0f325H	;c19
  1280 00000B77 F3                  <1>
  1281 00000B78 0000                <1> 	db	tag_valid, 0
  1282 00000B7A 0400CDADDB64F8A11A- <1> 	dw	4, 0adcdH, 064dbH, 0a1f8H, 06a1aH	;c17
  1282 00000B83 6A                  <1>
  1283 00000B84 0000                <1> 	db	tag_valid, 0
  1284 00000B86 0400F9C4B4D87FA6B7- <1> 	dw	4, 0c4f9H, 0d8b4H, 0a67fH, 0efb7H	;c15
  1284 00000B8F EF                  <1>
  1285 00000B90 0000                <1> 	db	tag_valid, 0
  1286 00000B92 040047E346ABBB98E7- <1> 	dw	4, 0e347H, 0ab46H, 098bbH, 000e7H	;c13
  1286 00000B9B 00                  <1>
  1287 00000B9C 0000                <1> 	db	tag_valid, 0
  1288 00000B9E 03004D864C4211A043- <1> 	dw	3, 0864dH, 0424cH, 0a011H, 06943H	;c11
  1288 00000BA7 69                  <1>
  1289 00000BA8 0000                <1> 	db	tag_valid, 0
  1290 00000BAA 030025A4EB8915E0C4- <1> 	dw	3, 0a425H, 089ebH, 0e015H, 047c4H	;c9
  1290 00000BB3 47                  <1>
  1291 00000BB4 0000                <1> 	db	tag_valid, 0
  1292 00000BB6 03000BD353B1F6D6FB- <1> 	dw	3, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;c7
  1292 00000BBF C9                  <1>
  1293 00000BC0 0000                <1> 	db	tag_valid, 0
  1294 00000BC2 0200BB938762DF7CCA- <1> 	dw	2, 093bbH, 06287H, 07cdfH, 0f3caH	;c5
  1294 00000BCB F3                  <1>
  1295 00000BCC 0000                <1> 	db	tag_valid, 0
  1296 00000BCE 020038F6E14E1FD0A5- <1> 	dw	2, 0f638H, 04ee1H, 0d01fH, 0eba5H	;c3
  1296 00000BD7 EB                  <1>
  1297 00000BD8 0000                <1> 	db	tag_valid, 0
  1298 00000BDA 0000AAB8293B175CBC- <1> 	dw	0, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;c1
  1298 00000BE3 F0                  <1>
  1299 00000BE4 0000                <1> 	db	tag_valid, 0
  1300 00000BE6 010000800000000000- <1> 	dw	1, 08000H, 0H, 0H, 0H		; 1/2
  1300 00000BEF 00                  <1>
  1301                              <1> 
  1302                              <1> fl2xCon1Len equ $-fl2xCon1
  1303                              <1> %if (fl2xCon1Len > lenCreg)
  1304                              <1>     %error not enough constant space in Creg
  1305                              <1> %endif
  1306                              <1> 
  1307                              <1> fl2xCon2:
  1308 00000BF0 0000                <1> 	db	tag_valid, 0
  1309 00000BF2 0400F9C4B4D87FA6B7- <1> 	dw	4, 0c4f9H, 0d8b4H, 0a67fH, 0efb7H	;c15
  1309 00000BFB EF                  <1>
  1310 00000BFC 0001                <1> 	db	tag_valid, 1
  1311 00000BFE 04000BD353B1F6D6FB- <1> 	dw	4, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;m14
  1311 00000C07 C9                  <1>
  1312 00000C08 0000                <1> 	db	tag_valid, 0
  1313 00000C0A 040047E346ABBB98E7- <1> 	dw	4, 0e347H, 0ab46H, 098bbH, 000e7H	;c13
  1313 00000C13 00                  <1>
  1314 00000C14 0001                <1> 	db	tag_valid, 1
  1315 00000C16 040038F6E14E1FD0A5- <1> 	dw	4, 0f638H, 04ee1H, 0d01fH, 0eba5H	;m12
  1315 00000C1F EB                  <1>
  1316 00000C20 0000                <1> 	db	tag_valid, 0
  1317 00000C22 03004D864C4211A043- <1> 	dw	3, 0864dH, 0424cH, 0a011H, 06943H	;c11
  1317 00000C2B 69                  <1>
  1318 00000C2C 0001                <1> 	db	tag_valid, 1
  1319 00000C2E 0300BB938762DF7CCA- <1> 	dw	3, 093bbH, 06287H, 07cdfH, 0f3caH	;m10
  1319 00000C37 F3                  <1>
  1320 00000C38 0000                <1> 	db	tag_valid, 0
  1321 00000C3A 030025A4EB8915E0C4- <1> 	dw	3, 0a425H, 089ebH, 0e015H, 047c4H	;c9
  1321 00000C43 47                  <1>
  1322 00000C44 0001                <1> 	db	tag_valid, 1
  1323 00000C46 0300AAB8293B175CBC- <1> 	dw	3, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m8
  1323 00000C4F F0                  <1>
  1324 00000C50 0000                <1> 	db	tag_valid, 0
  1325 00000C52 03000BD353B1F6D6FB- <1> 	dw	3, 0d30bH, 0b153H, 0d6f6H, 0c9fbH	;c7
  1325 00000C5B C9                  <1>
  1326 00000C5C 0001                <1> 	db	tag_valid, 1
  1327 00000C5E 030038F6E14E1FD0A5- <1> 	dw	3, 0f638H, 04ee1H, 0d01fH, 0eba5H	;m6
  1327 00000C67 EB                  <1>
  1328 00000C68 0000                <1> 	db	tag_valid, 0
  1329 00000C6A 0200BB938762DF7CCA- <1> 	dw	2, 093bbH, 06287H, 07cdfH, 0f3caH	;c5
  1329 00000C73 F3                  <1>
  1330 00000C74 0001                <1> 	db	tag_valid, 1
  1331 00000C76 0200AAB8293B175CBC- <1> 	dw	2, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m4
  1331 00000C7F F0                  <1>
  1332 00000C80 0000                <1> 	db	tag_valid, 0
  1333 00000C82 020038F6E14E1FD0A5- <1> 	dw	2, 0f638H, 04ee1H, 0d01fH, 0eba5H	;c3
  1333 00000C8B EB                  <1>
  1334 00000C8C 0001                <1> 	db	tag_valid, 1
  1335 00000C8E 0100AAB8293B175CBC- <1> 	dw	1, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;m2
  1335 00000C97 F0                  <1>
  1336 00000C98 0000                <1> 	db	tag_valid, 0
  1337 00000C9A 0000AAB8293B175CBC- <1> 	dw	0, 0b8aaH, 03b29H, 05c17H, 0f0bcH	;c1
  1337 00000CA3 F0                  <1>
  1338                              <1> fl2xCon2Len equ $-fl2xCon2
  1339                              <1> %if (fl2xCon2Len > lenCreg)
  1340                              <1>     %error not enough constant space in Creg
  1341                              <1> %endif
  1342                              <1> 
  1343                              <1> %else
  1344                              <1> fl2xCon1:
  1345                              <1> 	db	tag_valid, 1
  1346                              <1> 	dw	1, 0b504H, 0f334H	; -sqrt(0.5)
  1347                              <1> 	db	tag_valid, 1
  1348                              <1> 	dw	0, 0b2e3H, 03d74H
  1349                              <1> 	db	tag_valid, 1
  1350                              <1> 	dw	0, 0c9a1H, 058dcH
  1351                              <1> 	db	tag_valid, 0
  1352                              <1> 	dw	3, 09f05H, 0d27cH
  1353                              <1> 	db	tag_valid, 0
  1354                              <1> 	dw	0, 0e10eH, 08d9dH
  1355                              <1> 	db	tag_valid, 0
  1356                              <1> 	dw	1, 08000H, 00000H	; 1/2
  1357                              <1> fl2xCon1Len equ $-fl2xCon1
  1358                              <1> %if (fl2xCon1Len > lenCreg)
  1359                              <1>     %error not enough constant space in Creg
  1360                              <1> %endif
  1361                              <1> 
  1362                              <1> fl2xCon2:
  1363                              <1> 	db	tag_valid, 1
  1364                              <1> 	dw	2, 0b8aaH, 03b29H
  1365                              <1> 	db	tag_valid, 0
  1366                              <1> 	dw	2, 0f638H, 04ee2H
  1367                              <1> 	db	tag_valid, 1
  1368                              <1> 	dw	1, 0b8aaH, 03b29H
  1369                              <1> 	db	tag_valid, 0
  1370                              <1> 	dw	0, 0b8aaH, 03b29H
  1371                              <1> fl2xCon2Len equ $-fl2xCon2
  1372                              <1> %if (fl2xCon2Len > lenCreg)
  1373                              <1>     %error not enough constant space in Creg
  1374                              <1> %endif
  1375                              <1> %endif
  1376                              <1> 
  1377                              <1> 
  1378                              <1> 
  1379                              <1> ;
  1380                              <1> ;   exceptions for FYL2X
  1381                              <1> ;
  1382 00000CA4 7414                <1> FY200:	je	FY250		;test for zero
  1383 00000CA6 B301                <1> FY210:	mov	bl,1		;tag is infinity, invalid, empty, etc.
  1384 00000CA8 E8B3F9              <1> 	call	regptr
  1385 00000CAB C60706              <1> 	mov	byte [bx+tag], tag_invalid
  1386                              <1> FY240:
  1387 00000CAE 6A01                <1>         push    Iexcept
  1388                              <1> %if BIG
  1389                              <1> FYexception:
  1390                              <1> %endif
  1391 00000CB0 E83E0F              <1>         call    exception
  1392 00000CB3 8B1E1800            <1> 	mov	bx,[trptr2]
  1393 00000CB7 E94201              <1> 	jmp	FY999
  1394                              <1> 
  1395                              <1> FY250:	 ;tag is zero
  1396 00000CBA B301                <1> 	mov	bl,1		;result is - infinity
  1397 00000CBC E89FF9              <1> 	call	regptr
  1398 00000CBF C60702              <1> 	mov	byte [bx+tag], tag_infin
  1399 00000CC2 C6470101            <1> 	mov	byte [bx+sign],01	;minus
  1400 00000CC6 C74702FF7F          <1> 	mov	word [bx+expon], exp_of_FPinf	;set exponent
  1401 00000CCB 31C0                <1> 	xor	ax,ax
  1402 00000CCD 894704              <1> 	mov	[bx+mantis],ax
  1403 00000CD0 894706              <1> 	mov	[bx+mantis+2],ax
  1404                              <1> %if BIG
  1405 00000CD3 894708              <1> 	mov	[bx+mantis+4],ax
  1406 00000CD6 89470A              <1> 	mov	[bx+mantis+6],ax
  1407                              <1> %endif
  1408 00000CD9 EBD3                <1> 	jmp	FY240
  1409                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1410                              <1> ;
  1411                              <1> ;    FYL2X	Y times LOG2(X)
  1412                              <1> ;
  1413                              <1> ;	Y multiplier is in ST(1)
  1414                              <1> ;	X argument is at stack top, ST
  1415                              <1> ;
  1416                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1417                              <1> gFYL2X:
  1418 00000CDB 31DB                <1> 	xor	bx,bx		;get ST pointer
  1419 00000CDD E87EF9              <1> 	call	regptr		; in BX
  1420 00000CE0 891E1800            <1> 	mov	[trptr2],bx	;save stack top pointer
  1421 00000CE4 803F01              <1> 	cmp	byte [bx+tag], tag_zero	;test for valid tag
  1422 00000CE7 73BB                <1> 	jae	FY200
  1423 00000CE9 807F0100            <1> 	cmp	byte [bx+sign],0	;test for +
  1424 00000CED 75B7                <1> 	jne	FY210
  1425                              <1> 
  1426 00000CEF 8B4702              <1> 	mov	ax,[bx+expon]	;get X exponent
  1427 00000CF2 40                  <1> 	inc	ax		;test against 0 or 1
  1428 00000CF3 D1E8                <1> 	shr	ax,1
  1429 00000CF5 7565                <1> 	jnz	FY100		;not zero or 1, do long computation
  1430                              <1> ; exponent is zero or 1, further test needed
  1431 00000CF7 BE2C00              <1> 	mov	si,Areg	;get -1 in Areg
  1432 00000CFA C60400              <1> 	mov	byte [si+tag], tag_valid	;tag and sign to zero
  1433 00000CFD C6440101            <1> 	mov	byte [si+sign],01	; minus
  1434 00000D01 C744040080          <1> 	mov	word [si+mantis],8000h	;
  1435 00000D06 31C0                <1> 	xor	ax,ax
  1436 00000D08 894402              <1> 	mov	[si+expon],ax
  1437 00000D0B 894406              <1> 	mov	[si+mantis+2],ax
  1438                              <1> %if BIG
  1439 00000D0E 894408              <1> 	mov	[si+mantis+4],ax
  1440 00000D11 89440A              <1> 	mov	[si+mantis+6],ax
  1441                              <1> %endif
  1442 00000D14 89DF                <1> 	mov	di,bx		; ST is arg
  1443 00000D16 89F3                <1> 	mov	bx,si		;result to Areg
  1444 00000D18 E884F6              <1> 	call	do_add		;Areg = X - 1.0
  1445 00000D1B 8B1E1800            <1> 	mov	bx,[trptr2]	;restore ST pointer
  1446                              <1> %if BIG
  1447 00000D1F 837C02FB            <1> 	cmp	word [si+expon],-5	;test exponent
  1448                              <1> %else
  1449                              <1> 	cmp	word [si+expon],-8	;test exponent
  1450                              <1> %endif
  1451 00000D23 7F37                <1> 	jg	FY100		;larger values go thru long computation
  1452                              <1> ; have Areg is X-1, very near zero
  1453 00000D25 BE[F00B]            <1> 	mov	si,fl2xCon2	;get second set of constants
  1454 00000D28 B95A00              <1> 	mov	cx,fl2xCon2Len/2	;words to move
  1455 00000D2B E8CC0C              <1> 	call	moveconsts	;put constants in data segment
  1456                              <1> 
  1457 00000D2E 8B1E1800            <1> 	mov	bx,[trptr2]	;accumulate in ST
  1458 00000D32 8B361600            <1> 	mov	si,[trptr]
  1459 00000D36 C6061B000F          <1> 	mov	byte [trctr],fl2xCon2Len/lenAccum	;count 4/15 multiplies
  1460 00000D3B EB10                <1> 	jmp	short FY030
  1461                              <1> 
  1462                              <1> FY020:
  1463 00000D3D 830616000C          <1> 	add	word [trptr],lenAccum	;bump to next constant
  1464 00000D42 8B3E1600            <1> 	mov	di,[trptr]	;set to add next constant
  1465 00000D46 89F3                <1> 	mov	bx,si		;accumulate same place
  1466 00000D48 E854F6              <1> 	call	do_add		;add another constant
  1467 00000D4B 89F3                <1> 	mov	bx,si		;
  1468                              <1> FY030:
  1469 00000D4D BF2C00              <1> 	mov	di,Areg	;X-1 is here
  1470 00000D50 E81D03              <1> 	call	do_mul		;multiply
  1471 00000D53 FE0E1B00            <1> 	dec	byte [trctr]		;count thru constants
  1472 00000D57 75E4                <1> 	jnz	FY020
  1473 00000D59 E99200              <1> 	jmp	FY150		;multiply ST by ST(1)
  1474                              <1> 
  1475                              <1> 
  1476                              <1> FY100:
  1477 00000D5C BE[480B]            <1> 	mov	si,fl2xCon1	;get source constants
  1478 00000D5F B95400              <1> 	mov	cx,fl2xCon1Len/2	;get words to move
  1479 00000D62 E8950C              <1> 	call	moveconsts	;move to data segment
  1480 00000D65 8D7F02              <1> 	lea	di,[bx+expon]	;get address of integer exponent
  1481 00000D68 BE3800              <1> 	mov	si,Breg	;put it in the Breg
  1482 00000D6B E8AFF9              <1> 	call	load_I16	;load the integer
  1483 00000D6E 8B361800            <1> 	mov	si,[trptr2]	;get X pointer
  1484 00000D72 C74402FFFF          <1> 	mov	word [si+expon],-1	; X in range [0.5 ... 1.0)
  1485 00000D77 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
  1486 00000D7B BB2C00              <1> 	mov	bx,Areg	;put sum in Areg
  1487 00000D7E E81EF6              <1> 	call	do_add		;do the add
  1488 00000D81 8B361800            <1> 	mov	si,[trptr2]	;get X pointer
  1489 00000D85 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
  1490 00000D89 C6450100            <1> 	mov	byte [di+sign],0	;make constant +
  1491 00000D8D 89F3                <1> 	mov	bx,si		;result to stack top
  1492 00000D8F E80DF6              <1> 	call	do_add		;get denominator
  1493 00000D92 BF2C00              <1> 	mov	di,Areg	;get numerator pointer
  1494 00000D95 89F3                <1> 	mov	bx,si		;form Z in stack top
  1495 00000D97 E8B304              <1> 	call	do_div		;ST = Z
  1496 00000D9A 89F7                <1> 	mov	di,si		;set to get Z**2
  1497 00000D9C BB2C00              <1> 	mov	bx,Areg	;Z**2 will be in Areg
  1498 00000D9F E8CE02              <1> 	call	do_mul		;Areg = Z**2
  1499 00000DA2 830616000C          <1> 	add	word [trptr],lenAccum	;bump to C4 or C23
  1500                              <1> %if BIG
  1501 00000DA7 C6061B000B          <1> 	mov	byte [trctr],fl2xCon1Len/lenAccum-3	;count 11 terms
  1502 00000DAC 8B3E1600            <1> 	mov	di,[trptr]	;get constant pointer
  1503 00000DB0 89FB                <1> 	mov	bx,di		;accumulate in Const area
  1504                              <1> FY120:
  1505 00000DB2 E8BB02              <1> 	call	do_mul		; * Z*Z
  1506 00000DB5 830616000C          <1> 	add	word [trptr],lenAccum	;bump to next constant
  1507 00000DBA 8B3E1600            <1> 	mov	di,[trptr]	;
  1508 00000DBE 89F3                <1> 	mov	bx,si		;accumulate in const area
  1509 00000DC0 E8DCF5              <1> 	call	do_add		; add on constant
  1510 00000DC3 89F3                <1> 	mov	bx,si
  1511 00000DC5 BF2C00              <1> 	mov	di,Areg
  1512 00000DC8 FE0E1B00            <1> 	dec	byte [trctr]		;count terms
  1513 00000DCC 75E4                <1> 	jnz	FY120
  1514                              <1> 
  1515 00000DCE 8B1E1800            <1> 	mov	bx,[trptr2]	;form 2*Z*(c1...) in ST
  1516 00000DD2 FF4702              <1> 	inc	word [bx+expon]
  1517                              <1> %else
  1518                              <1> 	mov	di,[trptr]	;
  1519                              <1> 	mov	bx,di		;accumulate in Const area
  1520                              <1> 	call	do_add		;
  1521                              <1> 	add	word [trptr],lenAccum	;bump to C3
  1522                              <1> 	mov	di,[trptr]
  1523                              <1> 	mov	bx,si		;accumulate at C4 position
  1524                              <1> 	call	do_div
  1525                              <1> 	add	word [trptr],lenAccum	;bump to C2
  1526                              <1> 	push	si		;save C3/...
  1527                              <1> 	mov	si,Areg	;get Z**2 ptr
  1528                              <1> 	mov	di,[trptr]	;get C2 pointer
  1529                              <1> 	mov	bx,si		;accumulate in Areg
  1530                              <1> 	call	do_mul		;Areg = C2 * Z**2
  1531                              <1> 	pop	di
  1532                              <1> 	mov	bx,si		;Add in C3 stuff
  1533                              <1> 	call	do_add		;Areg = C2*Z**2 ...
  1534                              <1> 	add	word [trptr],lenAccum	;bump to C1
  1535                              <1> 	mov	di,[trptr]	;get C1 pointer
  1536                              <1> 	mov	bx,si		;result to Areg
  1537                              <1> 	call	do_add		;add it on
  1538                              <1> 	mov	bx,[trptr2]	;form Z*(c1...) in ST
  1539                              <1> %endif
  1540 00000DD5 89DF                <1> 	mov	di,bx		;
  1541 00000DD7 E89602              <1> 	call	do_mul		;got part of it in ST
  1542 00000DDA 89F3                <1> 	mov	bx,si		;
  1543 00000DDC 8B3E1600            <1> 	mov	di,[trptr]	;get pointer to 1/2
  1544 00000DE0 83C70C              <1> 	add	di,lenAccum	; **
  1545 00000DE3 E8B9F5              <1> 	call	do_add		;got LOG2(x) in ST
  1546 00000DE6 BF3800              <1> 	mov	di,Breg	;get extracted exponent
  1547 00000DE9 89F3                <1> 	mov	bx,si		;result to stack top
  1548 00000DEB E8B1F5              <1> 	call	do_add
  1549                              <1> 
  1550                              <1> FY150:
  1551 00000DEE B301                <1> 	mov	bl,1		;get ST(1) pointer
  1552 00000DF0 E86BF8              <1> 	call	regptr		; in BX
  1553 00000DF3 89DF                <1> 	mov	di,bx		;set for product
  1554 00000DF5 E87802              <1> 	call	do_mul		;do the product
  1555 00000DF8 8B1E1800            <1> 	mov	bx,[trptr2]	;set to pop the stack
  1556                              <1> FY999:
  1557 00000DFC E9A6F3              <1> 	jmp	pop_stack	; go do the pop
  1558                              <1> 
  1559                              <1> 
  1560                              <1> 
  1561                              <1> 
  1562                              <1> 
  1563                              <1> ; end em187c.asm
   521                                  %include "em187e.asm"
   522                              <1> ; em187e.asm
   523                              <1> 
   524                              <1> 
   525                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   526                              <1> ;
   527                              <1> ; load IEEE 8-byte real to accumulator
   528                              <1> ;       es:di   points to value to load
   529                              <1> ;       si      points to accumulator to receive value
   530                              <1> ; uses: ax & dx
   531                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   532                              <1> load_R64:	;	    proc    near
   533 00000DFF 268B5506            <1>   es    mov     dx, word [di+6]     ;get exponent
   534 00000E03 31C0                <1>         xor     ax,ax
   535 00000E05 D1E2                <1>         shl     dx,1            ; sign goes to carry
   536 00000E07 D0D0                <1>         rcl     al,1            ; sign goes to AL
   537 00000E09 884401              <1>         mov     byte [si+sign], al
   538 00000E0C C1EA05              <1>         shr     dx,5            ;dx is biased exponent
   539 00000E0F 09D2                <1>         or      dx,dx           ; test for zero
   540 00000E11 7446                <1>         jz      lr6401
   541 00000E13 81FAFF07            <1>         cmp     dx,2047         ; test for max exponent
   542 00000E17 7467                <1>         je      lr6411
   543 00000E19 C60400              <1>         mov     byte [si+tag], tag_valid
   544                              <1> 
   545 00000E1C 81EAFF03            <1>         sub     dx,1023         ; get correct exponent
   546 00000E20 895402              <1>         mov     word [si+expon],dx   ;set the exponent
   547 00000E23 268A5506            <1>   es    mov     dl,[di+6]    ;get hi-part of mantissa
   548 00000E27 268B4504            <1>   es    mov     ax,[di+4]    ;get second 16 bits
   549 00000E2B 268B5D02            <1>   es    mov     bx,[di+2]    ;get third 16 bits
   550                              <1> %if BIG
   551 00000E2F 268B3D              <1>   es    mov     di,[di]      ;get lowest order 16 bits
   552 00000E32 31ED                <1>         xor     bp,bp           ;zap lo-bit receiver
   553                              <1> %endif
   554 00000E34 B90400              <1>         mov     cx,4            ;count 4 shifts
   555                              <1> lr6493:
   556 00000E37 D1EA                <1>         shr     dx,1            ;shift into carry
   557 00000E39 D1D8                <1>         rcr     ax,1            ;shift into ax
   558 00000E3B D1DB                <1>         rcr     bx,1            ;shift into bx
   559                              <1> %if BIG
   560 00000E3D D1DF                <1>         rcr     di,1            ;shift into di
   561 00000E3F D1DD                <1>         rcr     bp,1            ;shift into bp
   562                              <1> %endif
   563 00000E41 E2F4                <1>         loop    lr6493
   564                              <1> ; have mantissa in AX:BX[:DI:BP]
   565 00000E43 F9                  <1>         stc
   566 00000E44 D1D8                <1>         rcr     ax,1            ;shift into ax
   567 00000E46 D1DB                <1>         rcr     bx,1            ;shift into bx
   568                              <1> %if BIG
   569 00000E48 D1DF                <1>         rcr     di,1            ;shift into di
   570 00000E4A D1DD                <1>         rcr     bp,1            ;shift into bp
   571 00000E4C 896C0A              <1>         mov     [si+mantis+6],bp
   572                              <1> lr6495:
   573 00000E4F 897C08              <1>         mov     [si+mantis+4],di
   574 00000E52 895C06              <1>         mov     [si+mantis+2],bx    ; **
   575 00000E55 894404              <1>         mov     [si+mantis],ax  ;set the internal form
   576                              <1> %else
   577                              <1> lr6495:
   578                              <1>         mov     [si+mantis+2],bx    ; **
   579                              <1>         mov     [si+mantis],ax  ;set the internal form
   580                              <1> %endif
   581                              <1> 
   582                              <1> lr6499:
   583 00000E58 C3                  <1>         ret
   584                              <1> 
   585                              <1> 
   586                              <1> ; biased exponent was 0
   587                              <1> lr6401:
   588 00000E59 268A4506            <1>   es    mov     al,[di+6]            ;get highest mantissa
   589 00000E5D 260B4504            <1>   es    or      ax,[di+4]
   590 00000E61 260B4502            <1>   es    or      ax,[di+2]            ;test for real zero
   591 00000E65 260B05              <1>   es    or      ax,[di]
   592 00000E68 7540                <1>         jnz     lr6402           ; not a real zero
   593                              <1> ; got real zero
   594 00000E6A C60401              <1>         mov     byte [si+tag], tag_zero
   595 00000E6D C744020180          <1>         mov     word [si+expon], exp_of_FPzero
   596                              <1> lr64015:
   597 00000E72 894404              <1>         mov     [si+mantis], ax
   598 00000E75 894406              <1>         mov     [si+mantis+2], ax
   599                              <1> %if  BIG
   600 00000E78 894408              <1>         mov     [si+mantis+4], ax
   601 00000E7B 89440A              <1>         mov     [si+mantis+6], ax
   602                              <1> %endif
   603 00000E7E EBD8                <1>         jmp     lr6499
   604                              <1> 
   605                              <1> ; biased exponent was 2047 -- possible infinity
   606                              <1> lr6411:
   607 00000E80 31C0                <1>         xor     ax,ax
   608 00000E82 268A5507            <1>   es    mov     dl, [di+7]
   609 00000E86 83E20F              <1>         and     dx,000Fh            ;check for zero mantissa
   610 00000E89 260B5504            <1>   es    or      dx,[di+4]
   611 00000E8D 260B5502            <1>   es    or      dx,[di+2]
   612 00000E91 260B15              <1>   es    or      dx,[di]
   613 00000E94 750A                <1>         jnz     lr6415              ; if not zero in packed form, NaN
   614 00000E96 C60402              <1>         mov     byte [si+tag], tag_infin
   615                              <1> lr6413:
   616 00000E99 C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   617 00000E9E EBD2                <1>         jmp     lr64015
   618                              <1> 
   619                              <1> lr6415:
   620 00000EA0 6A01                <1>         push    Iexcept             ;Invalid operation
   621 00000EA2 E84C0D              <1>         call    exception           ;   exception
   622 00000EA5 C60406              <1>         mov     byte [si+tag], tag_invalid
   623 00000EA8 EBEF                <1>         jmp     lr6413
   624                              <1> 
   625                              <1> 
   626                              <1> ; not a real zero -- actually a denormal
   627                              <1> lr6402:
   628 00000EAA 6A02                <1>         push    Dexcept             ;Denormalized operand
   629 00000EAC E8420D              <1>         call    exception           ;  exception
   630                              <1> 
   631 00000EAF 268B4505            <1>   es    mov     ax,[di+5]            ;AH gets 4 highest bits of mantissa
   632 00000EB3 268B5D03            <1>   es    mov     bx,[di+3]
   633 00000EB7 268A35              <1>   es    mov     dh,[di]
   634 00000EBA 268B7D01            <1>   es    mov     di,[di+1]            ;destroy ES:DI as pointer
   635 00000EBE B90400              <1>         mov     cx,4                ;shift by 4, trying to normalize
   636                              <1> lr6405:
   637                              <1> %if BIG
   638 00000EC1 D0E6                <1>         shl     dh,1
   639 00000EC3 D1D7                <1>         rcl     di,1
   640                              <1> %else
   641                              <1>         shl     di,1
   642                              <1> %endif
   643 00000EC5 D1D3                <1>         rcl     bx,1
   644 00000EC7 D1D0                <1>         rcl     ax,1
   645 00000EC9 E2F6                <1>         loop    lr6405              ;now it may be normalized
   646                              <1> ; dl is zero at this point, shift until fraction is normalized
   647                              <1> lr6406:
   648 00000ECB F6C480              <1>         test    ah,80h              ;test the hi-bit
   649 00000ECE 750C                <1>         jnz     lr6407              ;jump when normalized
   650                              <1> %if BIG
   651 00000ED0 D0E6                <1>         shl     dh,1
   652 00000ED2 D1D7                <1>         rcl     di,1
   653                              <1> %else
   654                              <1>         shl     di,1
   655                              <1> %endif
   656 00000ED4 D1D3                <1>         rcl     bx,1
   657 00000ED6 D1D0                <1>         rcl     ax,1
   658 00000ED8 FEC2                <1>         inc     dl                  ;count the shifts needed
   659 00000EDA EBEF                <1>         jmp     lr6406              ;loop back
   660                              <1> lr6407:
   661                              <1> %if BIG
   662 00000EDC 89D5                <1>         mov     bp,dx               ;save away dx
   663                              <1> %endif
   664 00000EDE 30F6                <1>         xor     dh,dh               ;clear hi part of dh
   665 00000EE0 81C2FF03            <1>         add     dx,1023             ;bias the exponent
   666 00000EE4 F7DA                <1>         neg     dx                  ;really is negative
   667 00000EE6 895402              <1>         mov     word [si+expon],dx       ;set exponent
   668                              <1> %if BIG
   669 00000EE9 896C0A              <1>         mov     [si+mantis+6],bp    ;set highest part of mantissa
   670                              <1> %endif
   671 00000EEC E960FF              <1>         jmp     lr6495
   672                              <1> ;load_R64    endp
   673                              <1> 
   674                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   675                              <1> ;
   676                              <1> ;   Store 64-bit real at ES:DI
   677                              <1> ;   SI points at accumulator to store
   678                              <1> ;
   679                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   680                              <1> store_R64:	;	   proc    near
   681 00000EEF 803C01              <1>         cmp     byte [si+tag], tag_zero
   682 00000EF2 735D                <1>         jae     sr64100                 ;go check on funny tag
   683 00000EF4 8B6C02              <1>         mov     bp,word [si+expon]           ;get exponent
   684                              <1> 
   685 00000EF7 8B4404              <1>         mov     ax,[si+mantis]
   686 00000EFA 8B5C06              <1>         mov     bx,[si+mantis+2]        ;get entire mantissa
   687 00000EFD 8A5401              <1>         mov     dl,byte [si+sign]            ;sign to DL
   688                              <1> %if BIG
   689 00000F00 8A740B              <1>         mov     dh,byte [si+mantis+7]
   690 00000F03 8B7408              <1>         mov     si,[si+mantis+4]        ;mantissa in AX:BX[:SI:DX]
   691 00000F06 80C604              <1>         add     dh,04h                  ;round mantissa
   692 00000F09 83D600              <1>         adc     si,0
   693 00000F0C 83D300              <1>         adc     bx,0
   694 00000F0F 83D000              <1>         adc     ax,0
   695 00000F12 7209                <1>         jc      sr64030
   696                              <1> %else
   697                              <1>         xor     dh,dh
   698                              <1>         xor     si,si                   ;zero this word 
   699                              <1> %endif
   700                              <1> 
   701                              <1> ; discard the hidden bit
   702                              <1> %if BIG
   703 00000F14 D0E6                <1>         shl     dh,1
   704 00000F16 D1D6                <1>         rcl     si,1
   705 00000F18 D1D3                <1>         rcl     bx,1
   706                              <1> %else
   707                              <1>         shl     bx,1
   708                              <1> %endif
   709 00000F1A D1D0                <1>         rcl     ax,1
   710 00000F1C F8                  <1>         clc
   711                              <1> sr64030:
   712 00000F1D 83D500              <1>         adc     bp,0                    ;possible increment of exponent
   713                              <1> 
   714 00000F20 81ED01FC            <1>         sub     bp,-1023                ;bias the exponent
   715 00000F24 7E49                <1>         jle     sr64190                 ;return zero on underflow
   716 00000F26 81FDFF07            <1>         cmp     bp,2047                 ;test for maximum exponent
   717 00000F2A 7353                <1>         jae     sr64210                 ;return infinity if overflow
   718                              <1> 
   719                              <1> ;now move 4 bits into the result
   720 00000F2C B90400              <1>         mov     cx,4
   721                              <1> sr64060:
   722                              <1> %if BIG
   723 00000F2F D0E6                <1>         shl     dh,1
   724 00000F31 D1D6                <1>         rcl     si,1
   725 00000F33 D1D3                <1>         rcl     bx,1
   726                              <1> %else
   727                              <1>         shl     bx,1
   728                              <1> %endif
   729 00000F35 D1D0                <1>         rcl     ax,1
   730 00000F37 D1D5                <1>         rcl     bp,1
   731 00000F39 E2F4                <1>         loop    sr64060
   732                              <1> 
   733 00000F3B 30F6                <1>         xor     dh,dh                   ;clear part of fraction
   734 00000F3D D1CA                <1>         ror     dx,1                    ;sign bit to hi position in DX
   735 00000F3F 09EA                <1>         or      dx,bp                   ;form final hi-word
   736 00000F41 268935              <1>   es    mov     [di],si              ;store low order
   737 00000F44 26895D02            <1>   es    mov     [di+2],bx
   738 00000F48 26894504            <1>   es    mov     [di+4],ax
   739 00000F4C 26895506            <1>   es    mov     [di+6],dx            ;store sign & exponent
   740                              <1> sr64099:
   741 00000F50 C3                  <1>         ret
   742                              <1> 
   743                              <1> 
   744                              <1> ; skip to here on not (tag_valid)
   745                              <1> sr64100:
   746 00000F51 7725                <1>         ja      sr64200                 ;further tag checking is needed
   747                              <1> 
   748                              <1> ; store a real zero, signed if you please
   749                              <1> sr64110:
   750 00000F53 31C0                <1>         xor     ax,ax                   ;get a zero
   751                              <1> sr64120:
   752 00000F55 8A5C01              <1>         mov     bl,byte [si+sign]            ;get sign
   753 00000F58 D0EB                <1>         shr     bl,1                    ;sign to carry
   754 00000F5A D1D8                <1>         rcr     ax,1                    ;sign to hi-bit of word
   755                              <1> sr64150:
   756 00000F5C 26894506            <1>   es    mov     [di+6],ax            ;store hi-word
   757 00000F60 31DB                <1>         xor     bx,bx                   ;zap again for good measure
   758 00000F62 26895D04            <1>   es    mov     [di+4],bx            ;store second word
   759 00000F66 26895D02            <1>   es    mov     [di+2],bx
   760 00000F6A 26891D              <1>   es    mov     [di],bx
   761 00000F6D EBE1                <1>         jmp     sr64099                 ;go exit from one point
   762                              <1> 
   763                              <1> ; store plus zero
   764                              <1> sr64190:
   765 00000F6F 6A10                <1>         push    Uexcept                 ;underflow
   766 00000F71 E87D0C              <1>         call    exception
   767                              <1> 
   768 00000F74 31C0                <1>         xor     ax,ax                   ;get +0.0
   769 00000F76 EBE4                <1>         jmp     sr64150
   770                              <1> 
   771                              <1> ; tag is neither (tag_valid) nor (tag_zero)
   772                              <1> sr64200:
   773 00000F78 803C02              <1>         cmp     byte [si+tag], tag_infin     ;test for infinity
   774 00000F7B 7407                <1>         je      sr64220
   775 00000F7D EB0A                <1>         jmp     short sr64250           ;return indefinite
   776                              <1> ; return signed infinity
   777                              <1> sr64210:
   778 00000F7F 6A08                <1>         push    Oexcept                 ;overflow 
   779 00000F81 E86D0C              <1>         call    exception
   780                              <1> sr64220:
   781 00000F84 B8E0FF              <1>         mov     ax,7FF0h << 1          ;following code will put in sign
   782 00000F87 EBCC                <1>         jmp     sr64120
   783                              <1> ; return signed indefinite
   784                              <1> sr64250:
   785 00000F89 6A01                <1>         push    Iexcept                 ;invalid operation
   786 00000F8B E8630C              <1>         call    exception
   787                              <1> 
   788 00000F8E B8F8FF              <1>         mov     ax,0FFF8h               ;following code will store value
   789 00000F91 EBC9                <1>         jmp     sr64150
   790                              <1> 
   791                              <1> ;store_R64   endp
   792                              <1> 
   793                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   794                              <1> ;
   795                              <1> ;   Store 16-bit integer at ES:DI
   796                              <1> ;   SI points at accumulator to store
   797                              <1> ;
   798                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   799                              <1> store_I16:	;	   proc    near
   800 00000F93 803C01              <1>         cmp     byte [si+tag], tag_zero
   801 00000F96 7321                <1>         jae     s16100              ;go do further checking
   802 00000F98 8B4402              <1>         mov     ax,word [si+expon]       ;get exponent
   803 00000F9B 83F80F              <1>         cmp     ax,15
   804 00000F9E 7D23                <1>         jge     s16150              ;go store indefinite
   805 00000FA0 B93F00              <1>         mov     cx,63               ;get shift count
   806 00000FA3 29C1                <1>         sub     cx,ax               ; shift to lowest order
   807 00000FA5 89F3                <1>         mov     bx,si               ;get argument
   808 00000FA7 E85906              <1>         call    vloadsh64           ;get AX:BX:CX:DX
   809 00000FAA E80906              <1>         call    round_mag           ;
   810 00000FAD 807C0100            <1>         cmp     byte [si+sign],0         ;check for plus
   811 00000FB1 7402                <1>         je      s16050              ; **
   812 00000FB3 F7DA                <1>         neg     dx                  ;negate result
   813                              <1> s16050:
   814 00000FB5 268915              <1>   es    mov     [di],dx          ;store low order
   815 00000FB8 C3                  <1>         ret
   816                              <1> 
   817                              <1> ; tag is not (tag_valid), check for other tags
   818                              <1> s16100:
   819 00000FB9 7404                <1>         je      s16120              ;tag zero
   820 00000FBB 6A01                <1>         push    Iexcept             ;
   821 00000FBD EB06                <1>         jmp     short s16160        ;invalid, empty, or indefinite
   822                              <1> ; tag is (tag_zero)
   823                              <1> s16120:
   824 00000FBF 31D2                <1>         xor     dx,dx               ; **
   825 00000FC1 EBF2                <1>         jmp     s16050              ;store and exit
   826                              <1> 
   827                              <1> ; exponent is too big
   828                              <1> s16150:
   829 00000FC3 6A08                <1>         push    Oexcept             ;overflow
   830                              <1> s16160:
   831 00000FC5 E8290C              <1>         call    exception
   832 00000FC8 BA0080              <1>         mov     dx,08000h           ;indefinite result
   833 00000FCB EBE8                <1>         jmp     s16050
   834                              <1> 
   835                              <1> ;store_I16   endp
   836                              <1> 
   837                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   838                              <1> ;
   839                              <1> ;   Store 32-bit integer at ES:DI
   840                              <1> ;   SI points at accumulator to store
   841                              <1> ;
   842                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   843                              <1> store_I32:	;	   proc    near
   844 00000FCD 803C01              <1>         cmp     byte [si+tag], tag_zero
   845 00000FD0 732B                <1>         jae     s32100              ;go do further checking
   846 00000FD2 8B4402              <1>         mov     ax,word [si+expon]       ;get exponent
   847 00000FD5 83F81F              <1>         cmp     ax,31
   848 00000FD8 7D2F                <1>         jge     s32150              ;go store indefinite
   849 00000FDA B93F00              <1>         mov     cx,63               ;get shift count
   850 00000FDD 29C1                <1>         sub     cx,ax               ; shift to lowest order
   851 00000FDF 89F3                <1>         mov     bx,si               ;get argument
   852 00000FE1 E81F06              <1>         call    vloadsh64           ;get AX:BX:CX:DX
   853 00000FE4 E8CF05              <1>         call    round_mag           ;
   854                              <1> 
   855 00000FE7 807C0100            <1>         cmp     byte [si+sign],0         ;check for plus
   856 00000FEB 7408                <1>         je      s32050              ; **
   857 00000FED F7D1                <1>         not     cx                  ;is negative, negate the result
   858 00000FEF F7DA                <1>         neg     dx
   859 00000FF1 F5                  <1>         cmc
   860 00000FF2 83D100              <1>         adc     cx,0
   861                              <1> s32050:
   862 00000FF5 268915              <1>   es    mov     [di],dx          ;store low order
   863 00000FF8 26894D02            <1>   es    mov     [di+2],cx        ;store high order
   864 00000FFC C3                  <1>         ret
   865                              <1> 
   866                              <1> ; tag is not (tag_valid), check for other tags
   867                              <1> s32100:
   868 00000FFD 7404                <1>         je      s32120              ;tag zero
   869 00000FFF 6A01                <1>         push    Iexcept             ;invalid operation
   870 00001001 EB08                <1>         jmp     short s32160              ;invalid, empty, or indefinite
   871                              <1> ; tag is (tag_zero)
   872                              <1> s32120:
   873 00001003 31C9                <1>         xor     cx,cx               ;get zero result
   874 00001005 31D2                <1>         xor     dx,dx               ; **
   875 00001007 EBEC                <1>         jmp     s32050              ;store and exit
   876                              <1> s32150:
   877 00001009 6A08                <1>         push    Oexcept             ;overflow
   878                              <1> s32160:
   879 0000100B E8E30B              <1>         call    exception
   880 0000100E 31D2                <1>         xor     dx,dx               ;zero low order
   881 00001010 B90080              <1>         mov     cx,8000h           ;indefinite result
   882 00001013 EBE0                <1>         jmp     s32050
   883                              <1> 
   884                              <1> ;store_I32   endp
   885                              <1> 
   886                              <1> 
   887                              <1> 
   888                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   889                              <1> ;
   890                              <1> ;   FMUL    ST,ST(i)        R=0, P=0
   891                              <1> ;   FMUL    ST(i),ST        R=1, P=0
   892                              <1> ;   FMULP   ST(i),ST        R=1, P=1
   893                              <1> ;
   894                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   895                              <1> FMULrr:
   896 00001015 E865F3              <1>         call    RRsetup         ;get source and destination reg. ptrs
   897 00001018 89FB                <1>         mov     bx,di           ;BX is where final result will go
   898                              <1> 
   899 0000101A 68[9901]            <1>         push    test_pop ;fake call
   900 0000101D EB51                <1>         jmp     short do_mul          ;do the register to register MUL
   901                              <1> 
   902                              <1> 
   903                              <1> 
   904                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   905                              <1> ;
   906                              <1> ;   FMUL    mem         MUL memory to ST
   907                              <1> ;
   908                              <1> ;       ES:DI is pointer to memory location
   909                              <1> ;
   910                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   911                              <1> genFMUL:
   912 0000101F BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   913 00001022 BB0600              <1>         mov     bx,FMbits           ;get format mask
   914 00001025 20EB                <1>         and     bl,ch
   915 00001027 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   916 0000102C 30DB                <1>         xor     bl,bl
   917 0000102E E82DF6              <1>         call    regptr              ;get ST pointer in BX
   918 00001031 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   919                              <1> ;  call to  do_mul  returns to  restore_segs
   920 00001033 68[B601]            <1>         push    restore_segs
   921 00001036 EB38                <1>         JMP     short do_mul
   922                              <1> 
   923                              <1> 
   924                              <1> 
   925                              <1> 
   926                              <1> ; OR of the tags was not 0, meaning both valid and non-zero
   927                              <1> FM200:  
   928 00001038 80E1FE              <1>         and     cl,0FEh         ;save only hi-part (valid & zero are ok)
   929 0000103B 7516                <1>         jnz     FM210           ;allow zero
   930                              <1> ; one or both of the tags says zero
   931 0000103D 5E                  <1>         pop     si
   932 0000103E C60401              <1>         mov     byte [si+tag], tag_zero  ;tag is tag_zero
   933 00001041 C744020180          <1>         mov     word [si+expon], exp_of_FPzero
   934 00001046 31C9                <1>         xor     cx,cx           ;mantissa is zero
   935 00001048 31ED                <1>         xor     bp,bp           ;ditto
   936                              <1> %if BIG
   937 0000104A 894C0A              <1>         mov     [si+mantis+6],cx
   938 0000104D 894C08              <1>         mov     [si+mantis+4],cx
   939                              <1> %endif
   940 00001050 E9B800              <1>         jmp     FM085           ;go store mantissa
   941                              <1> 
   942                              <1> 
   943                              <1> 
   944                              <1> 
   945                              <1> ; error in tags, invalidate result
   946                              <1> FM210:
   947 00001053 5E                  <1>         pop     si                  ; clean up the stack for now
   948 00001054 C60406              <1>         mov     byte [si+tag], tag_invalid
   949 00001057 6A01                <1>         push    Iexcept             ;signal exception
   950 00001059 E8950B              <1>         call    exception
   951 0000105C E9B200              <1>         jmp     FM090
   952                              <1> 
   953                              <1> ; overflow occurred in adding the exponents
   954                              <1> FM220:
   955 0000105F 5E                  <1>         pop     si                  ; clean up the stack for now
   956 00001060 C60402              <1>         mov     byte [si+tag], tag_infin
   957 00001063 C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   958 00001068 6A08                <1>         push    Oexcept             ;signal exception
   959 0000106A E8840B              <1>         call    exception
   960 0000106D E9A100              <1>         jmp     FM090
   961                              <1> 
   962                              <1> 
   963                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   964                              <1> ;
   965                              <1> ;   Multiply register - register
   966                              <1> ;       SI and DI point to operands
   967                              <1> ;       BX is place to put result, may be same as SI or DI
   968                              <1> ;
   969                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   970                              <1> do_mul:		;	      proc    near
   971 00001070 53                  <1>         push    bx              ;save place to which to move result
   972 00001071 8A04                <1>         mov     al,byte [si+tag]     ;get source tag
   973 00001073 8A25                <1>         mov     ah,byte [di+tag]     ;get dest tag
   974 00001075 88C1                <1>         mov     cl,al           ;copy tag
   975 00001077 08E1                <1>         or      cl,ah           ;or tags together
   976 00001079 75BD                <1>         jnz     FM200           ;if not both valid, something needs checking
   977                              <1> ; both tags are valid
   978 0000107B 8A4401              <1>         mov     al,byte [si+sign]    ;exclusive or the signs
   979 0000107E 324501              <1>         xor     al,byte [di+sign]    ; **
   980 00001081 884701              <1>         mov     byte [bx+sign],al    ;
   981                              <1> 
   982 00001084 8B4402              <1>         mov     ax,word [si+expon]   ;add the exponents
   983 00001087 F9                  <1>         stc                     ; plus bias of 1
   984 00001088 134502              <1>         adc     ax,word [di+expon]   ;
   985 0000108B 70D2                <1>         jo      FM220           ;infintiy result
   986 0000108D 894702              <1>         mov     word [bx+expon],ax   ;store result exponent
   987                              <1> 
   988                              <1> %if BIG
   989 00001090 8D740A              <1>         lea     si,[si+mantis+6]    ;final mantissa address
   990 00001093 8D5D0A              <1>         lea     bx,[di+mantis+6]    ; **
   991 00001096 89361400            <1>         mov     word [mptr],si         ;save starting pointer value
   992 0000109A FD                  <1>         std
   993 0000109B 31C0                <1>         xor     ax,ax           ;get zero
   994 0000109D B90800              <1>         mov     cx,8
   995 000010A0 BF2A00              <1>         mov     di,mtemp+14  ;get final word in temporary
   996 000010A3 8CDA                <1>         mov     dx,ds           ;set up ES register
   997 000010A5 8EC2                <1>         mov     es,dx           ; **
   998 000010A7 F3AB                <1>     rep     stosw               ;clear the temporary
   999 000010A9 89DF                <1>         mov     di,bx           ;
  1000 000010AB BB2200              <1>         mov     bx,mtemp+6   ;get address of mantissa temporary
  1001 000010AE 31ED                <1>         xor     bp,bp           ;clear carry word
  1002 000010B0 C6061A0004          <1>         mov     byte [ctr],4           ;loop 4 times
  1003 000010B5 90                  <1>         even
  1004                              <1> FM030:
  1005 000010B6 83C308              <1>         add     bx,8            ;point at lowest order word
  1006 000010B9 B90400              <1>         mov     cx,4            ;loop 4 times
  1007                              <1>         even
  1008                              <1> FM040:
  1009 000010BC AD                  <1>         lodsw                   ;get multiplicand
  1010 000010BD F725                <1>         mul     word [di]   ;form product
  1011 000010BF 0107                <1>         add     [bx],ax         ;add in low order
  1012 000010C1 4B                  <1>         dec     bx              ;don't disturb carry
  1013 000010C2 4B                  <1>         dec     bx              ; **
  1014 000010C3 11EA                <1>         adc     dx,bp           ;carry from this add is possible
  1015 000010C5 D1DD                <1>         rcr     bp,1            ;save carry, get previous carry
  1016 000010C7 D1C5                <1>         rol     bp,1            ;to low bit
  1017 000010C9 0117                <1>         add     [bx],dx         ;
  1018 000010CB 83D500              <1>         adc     bp,0            ;get carry to next stage
  1019 000010CE E2EC                <1>         loop    FM040           ;loop back
  1020                              <1> 
  1021                              <1> ; the carry out of this stage (in BP) is always 0
  1022                              <1> 
  1023 000010D0 8B361400            <1>         mov     si,word [mptr]         ;get multiplicand start pointer
  1024 000010D4 4B                  <1>         dec     bx
  1025 000010D5 4B                  <1>         dec     bx
  1026 000010D6 4F                  <1>         dec     di
  1027 000010D7 4F                  <1>         dec     di
  1028 000010D8 FE0E1A00            <1>         dec     byte [ctr]
  1029 000010DC 75D8                <1>         jnz     FM030
  1030                              <1> 
  1031 000010DE 5E                  <1>         pop     si              ;get place to store mantissa
  1032 000010DF 8B0E1C00            <1>         mov     cx,[mtemp]      ;get mantissa
  1033 000010E3 8B2E1E00            <1>             mov     bp,word [mtemp+2]
  1034 000010E7 8B162000            <1>         mov     dx,word [mtemp+4]
  1035 000010EB A12200              <1>         mov     ax,word [mtemp+6]
  1036 000010EE F6C580              <1>         test    ch,80H          ;is it normalized?
  1037 000010F1 750F                <1>         jnz     FM060
  1038                              <1> 
  1039 000010F3 FF4C02              <1>         dec     word [si+expon]      ;must shift by 1 to normalize
  1040 000010F6 D1262400            <1>         shl     word [mtemp+8],1       ;get low order bit to carry
  1041 000010FA D1D0                <1>         rcl     ax,1            ;do the normalization
  1042 000010FC D1D2                <1>         rcl     dx,1            ;
  1043 000010FE D1D5                <1>         rcl     bp,1
  1044 00001100 D1D1                <1>         rcl     cx,1            ;last of normalization
  1045                              <1> FM060:
  1046 00001102 89440A              <1>         mov     [si+mantis+6],ax    ;store the result
  1047 00001105 895408              <1>         mov     [si+mantis+4],dx    ; **
  1048                              <1> %else
  1049                              <1>         mov     bx,[si+mantis]  ;get hi-word of source
  1050                              <1>         mov     ax,[di+mantis]  ;get hi-word of dest
  1051                              <1>         mul     bx              ;DX:AX is  H*H
  1052                              <1>         mov     cx,dx           ;
  1053                              <1>         mov     bp,ax           ;CX:BP is  H*H
  1054                              <1>         mov     ax,[di+mantis+2]    ;get second word of dest
  1055                              <1>         mul     bx              ;CX:BP
  1056                              <1>                                 ;   DX:AX
  1057                              <1>         add     bp,dx           ;CX:BP:AX
  1058                              <1>         adc     cx,0            ; account for any carry
  1059                              <1>         mov     bx,[si+mantis+2]    ;get second part of source
  1060                              <1>         mov     si,ax           ;CX:BP:SI
  1061                              <1>         mov     ax,[di+mantis]  ;get hi-word of dest
  1062                              <1>         mul     bx
  1063                              <1>         add     si,ax           ;align properly
  1064                              <1>         adc     bp,dx           ; **
  1065                              <1>         adc     cx,0            ;
  1066                              <1>         mov     ax,[di+mantis+2]    ;get low word of dest
  1067                              <1>         mul     bx              ;form low part of product
  1068                              <1>         add     dx,si           ;CX:BP:DX is now the result
  1069                              <1>         adc     bp,0            ;
  1070                              <1>         adc     cx,0            ;CX:BP is the manitssa
  1071                              <1>         pop     si              ;pointer to where to put it
  1072                              <1>         test    ch,80H          ;test for normalization
  1073                              <1>         jnz     FM080           ;go store if normalized
  1074                              <1>         dec     word [si+expon]      ;adjust the exponent
  1075                              <1>         shl     dx,1            ;get lowest bit
  1076                              <1>         rcl     bp,1            ;rotate into low order
  1077                              <1>         rcl     cx,1            ;rotate into high order
  1078                              <1> %endif
  1079                              <1> FM080:
  1080 00001108 C60400              <1>         mov     byte [si+tag], tag_valid ;validate the result
  1081                              <1> FM085:
  1082 0000110B 896C06              <1>         mov     [si+mantis+2],bp    ;store low-part
  1083 0000110E 894C04              <1>         mov     [si+mantis],cx      ;store hi-part
  1084                              <1> FM090:
  1085 00001111 FC                  <1> 	cld
  1086 00001112 C3                  <1>         ret
  1087                              <1> 
  1088                              <1> 
  1089                              <1> ;do_mul  endp
  1090                              <1> 
  1091                              <1> 
  1092                              <1> ; end em187e.asm
   522                                  %include "em187f.asm"
   523                              <1> ; em187f.asm
   524                              <1> 
   525                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   526                              <1> ;
   527                              <1> ;   FXAM                examine ST
   528                              <1> ;
   529                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   530                              <1> gFXAM:
   531 00001113 30DB                <1>         xor     bl,bl
   532 00001115 E846F5              <1>         call    regptr              ;get ST pointer in BX
   533 00001118 8A6701              <1>         mov     ah,byte [bx+sign]        ;get sign flag to C1
   534 0000111B D0E4                <1>         shl     ah,1                ; **
   535 0000111D 8A07                <1>         mov     al,byte [bx+tag]         ;get tag value
   536 0000111F 3C00                <1>         cmp     al,tag_valid        ;try valid first
   537 00001121 7420                <1>         je      gfx090
   538 00001123 3C01                <1>         cmp     al,tag_zero         ;try zero next
   539 00001125 7417                <1>         je      gfx080
   540 00001127 3C02                <1>         cmp     al,tag_infin        ;try infinity next
   541 00001129 740E                <1>         je      gfx070
   542 0000112B 3C03                <1>         cmp     al,tag_empty        ;try empty next
   543 0000112D 7405                <1>         je      gfx060
   544                              <1> 
   545 0000112F 80CC01              <1>         or      ah,C0               ;C0 flags invalid (NaN)
   546 00001132 EB12                <1>         jmp     short gfx095
   547                              <1> gfx060:
   548 00001134 80CC41              <1>         or      ah,C3+C0            ;C3+C0 for empty
   549 00001137 EB0D                <1>         jmp     short gfx095
   550                              <1> gfx070:
   551 00001139 80CC05              <1>         or      ah,C2+C0            ;C2+C0 flags infinity
   552 0000113C EB08                <1>         jmp     short gfx095
   553                              <1> gfx080:
   554 0000113E 80CC40              <1>         or      ah,C3               ;C3 flags zero
   555 00001141 EB03                <1>         jmp     short gfx095
   556                              <1> gfx090:
   557 00001143 80CC04              <1>         or      ah,C2               ;C2 flags normal
   558                              <1> gfx095:
   559 00001146 80260300B8          <1>         and     byte [codes],~(C3+C2+C1+C0)    ;clear Status bits
   560 0000114B 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   561 0000114F E964F0              <1>         jmp     restore_segs
   562                              <1> 
   563                              <1> 
   564                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   565                              <1> ;
   566                              <1> ;   FTST                compare ST to 0.0
   567                              <1> ;
   568                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   569                              <1> gFTST:
   570 00001152 30DB                <1>         xor     bl,bl
   571 00001154 E807F5              <1>         call    regptr              ;get ST pointer in BX
   572 00001157 89DE                <1>         mov     si,bx               ;point SI at stack top
   573 00001159 E82702              <1>         call    do_test             ;compare [SI] to 0.0
   574                              <1> 
   575 0000115C 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
   576 00001161 08260300            <1>         or      byte [codes],ah            ;set condition code bits
   577 00001165 E94EF0              <1>         jmp     restore_segs
   578                              <1> 
   579                              <1> 
   580                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   581                              <1> ;
   582                              <1> ;   FDIV    mem         ST := ST / mem
   583                              <1> ;
   584                              <1> ;       ES:DI is pointer to memory location
   585                              <1> ;
   586                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   587                              <1> genFDIV:
   588 00001168 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   589 0000116B BB0600              <1>         mov     bx,FMbits           ;get format mask
   590 0000116E 20EB                <1>         and     bl,ch
   591 00001170 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   592 00001175 30DB                <1>         xor     bl,bl
   593 00001177 E8E4F4              <1>         call    regptr              ;get ST pointer in BX
   594 0000117A 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   595                              <1> ;  call to  do_div  returns to  restore_segs
   596 0000117C 68[B601]            <1>         push    restore_segs
   597 0000117F E9CB00              <1>         JMP     do_div
   598                              <1> 
   599                              <1> 
   600                              <1> 
   601                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   602                              <1> ;
   603                              <1> ;   FDIVR   mem         ST := mem / ST
   604                              <1> ;
   605                              <1> ;       ES:DI is pointer to memory location
   606                              <1> ;
   607                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   608                              <1> genFDIVR:
   609 00001182 BE2C00              <1>         mov     si,Areg      ;load first into the Areg
   610 00001185 BB0600              <1>         mov     bx,FMbits           ;get format mask
   611 00001188 20EB                <1>         and     bl,ch
   612 0000118A 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
   613 0000118F 30DB                <1>         xor     bl,bl
   614 00001191 E8CAF4              <1>         call    regptr              ;get ST pointer in BX
   615 00001194 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
   616 00001196 87F7                <1>         xchg    si,di               ;change sense of divide, ST (in BX)
   617                              <1>                                     ; still gets the result
   618                              <1> ;  call to  do_div  returns to  restore_segs
   619 00001198 68[B601]            <1>         push    restore_segs
   620 0000119B E9AF00              <1>         JMP     do_div
   621                              <1> 
   622                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   623                              <1> ;
   624                              <1> ;   FDIV    ST,ST(i)        R=0, P=0
   625                              <1> ;   FDIVR   ST(i),ST        R=1, P=0
   626                              <1> ;   FDIVRP  ST(i),ST        R=1, P=1
   627                              <1> ;
   628                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   629                              <1> FDIVi:
   630 0000119E 88CB                <1>         mov     bl,cl           ;get ST(i) pointer
   631 000011A0 E8BBF4              <1>         call    regptr          ;BX is ST(i) pointer
   632 000011A3 89DE                <1>         mov     si,bx           ;divisor in SI is ST(i)
   633 000011A5 31DB                <1>         xor     bx,bx           ;get ST pointer
   634 000011A7 E8B4F4              <1>         call    regptr          ;BX is ST pointer
   635 000011AA 89DF                <1>         mov     di,bx           ;dividend pointer in DI is ST
   636 000011AC F6C504              <1>         test    ch,Rbit         ;see who gets the result
   637 000011AF 7408                <1>         jz      FDIVi01         ;ST will get result
   638                              <1> ; ST(i) gets the result
   639 000011B1 89F3                <1>         mov     bx,si           ;BX points to destination
   640 000011B3 68[9901]            <1>         push    test_pop
   641 000011B6 E99400              <1>         jmp     do_div
   642                              <1> FDIVi01:    ; ST will get the result, no pop possible
   643 000011B9 68[B601]            <1>         push    restore_segs
   644 000011BC E98E00              <1>         jmp     do_div
   645                              <1> 
   646                              <1> 
   647                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   648                              <1> ;
   649                              <1> ;   FDIVR    ST,ST(i)        R=0, P=0
   650                              <1> ;   FDIV     ST(i),ST        R=1, P=0
   651                              <1> ;   FDIVP    ST(i),ST        R=1, P=1
   652                              <1> ;
   653                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   654                              <1> FDIV0:
   655 000011BF 88CB                <1>         mov     bl,cl           ;get ST(i) pointer
   656 000011C1 E89AF4              <1>         call    regptr          ;BX is ST(i) pointer
   657 000011C4 89DF                <1>         mov     di,bx           ;dividend pointer in DI is ST(i)
   658 000011C6 31DB                <1>         xor     bx,bx           ;get ST pointer
   659 000011C8 E893F4              <1>         call    regptr          ;BX is ST pointer
   660 000011CB 89DE                <1>         mov     si,bx           ;divisor in SI is ST
   661 000011CD F6C504              <1>         test    ch,Rbit         ;see who gets the result
   662 000011D0 7407                <1>         jz      FDIV001         ;ST will get result
   663                              <1> ; ST(i) gets the result
   664 000011D2 89FB                <1>         mov     bx,di           ;BX points to destination
   665 000011D4 68[9901]            <1>         push    test_pop
   666 000011D7 EB74                <1>         jmp     short do_div
   667                              <1> 
   668                              <1> FDIV001:    ; ST will get the result, no pop possible
   669 000011D9 68[B601]            <1>         push    restore_segs
   670 000011DC EB6F                <1>         jmp     short do_div
   671                              <1> 
   672                              <1> 
   673                              <1> 
   674                              <1> ; error in tags, handle in FADD for now
   675                              <1> FD210:
   676 000011DE 5E                  <1>         pop     si                  ; clean up the stack for now
   677 000011DF C60406              <1>         mov     byte [si+tag], tag_invalid
   678 000011E2 6A01                <1>         push    Iexcept             ;signal exception
   679 000011E4 E80A0A              <1>         call    exception
   680 000011E7 E93801              <1>         jmp     FD099
   681                              <1> 
   682                              <1> 
   683                              <1> FD220:
   684 000011EA 5E                  <1>         pop     si              ;get result pointer
   685 000011EB 803D01              <1>         cmp     byte [di+tag], tag_zero
   686 000011EE 7417                <1>         je      FD230           ;jump if zero divided by zero
   687                              <1> ; have  tag_valid  divided by zero
   688 000011F0 6A04                <1>         push    Zexcept         ;zero divide exception
   689 000011F2 E8FC09              <1>         call    exception
   690 000011F5 8A4501              <1>         mov     al,byte [di+sign]    ;get sign of numerator
   691 000011F8 884401              <1>         mov     byte [si+sign],al    ;store it
   692 000011FB C60402              <1>         mov     byte [si+tag], tag_infin ;set infinity
   693                              <1> FD225:
   694 000011FE C74402FF7F          <1>         mov     word [si+expon], exp_of_FPinf
   695 00001203 31C0                <1>         xor     ax,ax           ;get zero
   696 00001205 EB22                <1>         jmp     short FD250           ;clear mantissa
   697                              <1> FD230:
   698 00001207 6A01                <1>         push    Iexcept         ; 0/0 -- invalid operation
   699 00001209 E8E509              <1>         call    exception
   700 0000120C C60406              <1>         mov     byte [si+tag], tag_invalid
   701 0000120F EBED                <1>         jmp     FD225
   702                              <1> 
   703                              <1> 
   704                              <1> ; exception handling for do_div
   705                              <1> FD200:
   706 00001211 F6C6FE              <1>         test    dh,0FEh         ;check for other than zero
   707 00001214 75C8                <1>         jnz     FD210           ;have invalid, infinity, or empty
   708                              <1> ; one or both of the tags is zero
   709 00001216 803C01              <1>         cmp     byte [si+tag], tag_zero
   710 00001219 74CF                <1>         je      FD220           ;divisor is zero
   711                              <1> ;divisor is non-zero, therefore the dividend is zero
   712 0000121B 5E                  <1>         pop     si              ;get result pointer
   713 0000121C C60401              <1>         mov     byte [si+tag], tag_zero
   714 0000121F 31C0                <1>         xor     ax,ax           ;get zap value
   715 00001221 884401              <1>         mov     byte [si+sign],al    ;set to +0.0
   716 00001224 C744020180          <1>         mov     word [si+expon],exp_of_FPzero
   717                              <1> FD250:
   718 00001229 894404              <1>         mov     [si+mantis],ax  ;zero out the mantissa
   719 0000122C 894406              <1>         mov     [si+mantis+2],ax
   720                              <1> %if BIG
   721 0000122F 894408              <1>         mov     [si+mantis+4],ax
   722 00001232 89440A              <1>         mov     [si+mantis+6],ax
   723                              <1> %endif
   724 00001235 E9EA00              <1>         jmp     FD099           ;go exit from the same point
   725                              <1> 
   726                              <1> ; underflow subtracting exponents
   727                              <1> FD205:
   728 00001238 5E                  <1>         pop     si                  ; clean up the stack for now
   729 00001239 C60401              <1>         mov     byte [si+tag], tag_zero
   730 0000123C C6440100            <1>         mov     byte [si+sign], 0
   731 00001240 C744020180          <1>         mov     word [si+expon],exp_of_FPzero
   732                              <1> 
   733 00001245 6A10                <1>         push    Uexcept             ;signal exception
   734 00001247 E8A709              <1>         call    exception
   735 0000124A E9D500              <1>         jmp     FD099
   736                              <1> 
   737                              <1> 
   738                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   739                              <1> ;
   740                              <1> ;   Divide accumulator DI by SI
   741                              <1> ;       SI and DI point to operands
   742                              <1> ;       BX is place to put result, may be same as SI or DI
   743                              <1> ;
   744                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   745                              <1> do_div:		;      proc    near
   746 0000124D 53                  <1>         push    bx              ;save place to which to move result
   747 0000124E 8A34                <1>         mov     dh,byte [si+tag]     ;get source tag
   748 00001250 0A35                <1>         or      dh,byte [di+tag]     ;get dest tag
   749 00001252 75BD                <1>         jnz     FD200           ;if not both valid, something needs checking
   750                              <1> ; both tags are valid
   751 00001254 8A4401              <1>         mov     al,byte [si+sign]    ;exclusive or the signs
   752 00001257 324501              <1>         xor     al,byte [di+sign]    ; **
   753 0000125A 884701              <1>         mov     byte [bx+sign],al    ;
   754                              <1> 
   755 0000125D 8B4502              <1>         mov     ax,word [di+expon]   ;subtract the exponents
   756 00001260 2B4402              <1>         sub     ax,word [si+expon]   ;
   757 00001263 70D3                <1>         jo      FD205           ;signal underflow
   758 00001265 894702              <1>         mov     word [bx+expon],ax   ;store result exponent
   759                              <1> 
   760                              <1> %if BIG
   761 00001268 8B5504              <1>         mov     dx,[di+mantis]      ;move fraction to mtemp for the divide
   762 0000126B 8B4506              <1>         mov     ax,[di+mantis+2]    ;get 2nd part
   763 0000126E 8B5D08              <1>         mov     bx,[di+mantis+4]    ;get third part
   764 00001271 8B4D0A              <1>         mov     cx,[di+mantis+6]    ;get final part
   765                              <1> 
   766 00001274 8B6C06              <1>         mov     bp,[si+mantis+2]    ;get high order part
   767 00001277 89EF                <1>         mov     di,bp               ;copy for test
   768 00001279 0B7C08              <1>         or      di,[si+mantis+4]    ;test for divide by integer
   769 0000127C 0B7C0A              <1>         or      di,[si+mantis+6]    ;
   770 0000127F 8B7C04              <1>         mov     di,[si+mantis]      ;get hi part
   771 00001282 745C                <1>         jz      FD010               ;go do fast divide
   772                              <1> 
   773                              <1> ;not so lucky, must do the entire mess
   774                              <1> ;  DX:AX:BX:CX / DI:BP:mem:mem
   775 00001284 C6061A0040          <1>         mov     byte [ctr],64              ;count 64 bits
   776 00001289 EB0A                <1>         jmp     short FD004         ;save a shift
   777                              <1> FD003:
   778 0000128B D1E1                <1>         shl     cx,1                ;the long rotate
   779 0000128D D1D3                <1>         rcl     bx,1
   780 0000128F D1D0                <1>         rcl     ax,1
   781 00001291 D1D2                <1>         rcl     dx,1
   782 00001293 7218                <1>         jc      FD005               ;go do the subtract
   783                              <1> FD004:
   784 00001295 39FA                <1>         cmp     dx,di
   785 00001297 7714                <1>         ja      FD005
   786 00001299 721D                <1>         jb      FD007               ;no subtract, but CF=1
   787 0000129B 39E8                <1>         cmp     ax,bp
   788 0000129D 770E                <1>         ja      FD005
   789 0000129F 7217                <1>         jb      FD007
   790 000012A1 3B5C08              <1>         cmp     bx,[si+mantis+4]
   791 000012A4 7707                <1>         ja      FD005
   792 000012A6 7210                <1>         jb      FD007
   793 000012A8 3B4C0A              <1>         cmp     cx,[si+mantis+6]
   794 000012AB 720B                <1>         jb      FD007
   795                              <1> FD005:
   796 000012AD 2B4C0A              <1>         sub     cx,[si+mantis+6]
   797 000012B0 1B5C08              <1>         sbb     bx,[si+mantis+4]
   798 000012B3 19E8                <1>         sbb     ax,bp
   799 000012B5 19FA                <1>         sbb     dx,di
   800 000012B7 F8                  <1>         clc                             ;needed for bullet proofing
   801                              <1> FD007:
   802 000012B8 F5                  <1>         cmc
   803 000012B9 D1162200            <1>         rcl     word [mtemp+6],1               ;accumulate the result a bit at a time
   804 000012BD D1162000            <1>         rcl     word [mtemp+4],1
   805 000012C1 D1161E00            <1>         rcl     word [mtemp+2],1
   806 000012C5 D1161C00            <1>         rcl     word [mtemp],1
   807 000012C9 FE0E1A00            <1>         dec     byte [ctr]
   808 000012CD 75BC                <1>         jnz     FD003
   809                              <1> 
   810                              <1> ; done with division
   811 000012CF 8B1E1C00            <1>         mov     bx,word [mtemp]                ;load up the resulting fraction
   812 000012D3 8B0E1E00            <1>         mov     cx,word [mtemp+2]              ;in the right place
   813 000012D7 8B2E2000            <1>         mov     bp,word [mtemp+4]
   814 000012DB A12200              <1>         mov     ax,word [mtemp+6]              ;BX:CX:BP:AX
   815 000012DE EB15                <1>         jmp     short FD018             ;go round it
   816                              <1> 
   817                              <1> ; integer division -- the low 3 words of the source are zero
   818                              <1> FD010:
   819                              <1> ;;;        xor     bp,bp               ;get zero at low end of word
   820 000012E0 D1EA                <1>         shr     dx,1                ;make sure DX < DI
   821 000012E2 D1D8                <1>         rcr     ax,1
   822 000012E4 D1DB                <1>         rcr     bx,1
   823 000012E6 D1D9                <1>         rcr     cx,1
   824 000012E8 D1DD                <1>         rcr     bp,1                ;last bit retained in BP
   825                              <1> 
   826 000012EA F7F7                <1>         div     di
   827 000012EC 93                  <1>         xchg    ax,bx               ;high quotient to BX
   828 000012ED F7F7                <1>         div     di
   829 000012EF 91                  <1>         xchg    ax,cx               ;second quotient to CX
   830 000012F0 F7F7                <1>         div     di
   831 000012F2 95                  <1>         xchg    ax,bp               ;third quotient to BP
   832 000012F3 F7F7                <1>         div     di                  ;fourth quotient to AX
   833                              <1> ; round the result
   834                              <1> FD018:
   835 000012F5 D1EF                <1>         shr     di,1                ;divide by 2
   836 000012F7 29D7                <1>         sub     di,dx               ;borrow if dx is greater (set carry)
   837 000012F9 83D000              <1>         adc     ax,0
   838 000012FC 83D500              <1>         adc     bp,0
   839 000012FF 83D100              <1>         adc     cx,0
   840 00001302 83D300              <1>         adc     bx,0                ;set the sign flag
   841 00001305 5E                  <1>         pop     si                  ;get place to store it
   842 00001306 780B                <1>         js      FD020               ;no normalization needed
   843 00001308 FF4C02              <1>         dec     word [si+expon]          ;adjust exponent
   844 0000130B D1E0                <1>         shl     ax,1
   845 0000130D D1D5                <1>         rcl     bp,1
   846 0000130F D1D1                <1>         rcl     cx,1
   847 00001311 D1D3                <1>         rcl     bx,1
   848                              <1> FD020:
   849 00001313 895C04              <1>         mov     [si+mantis],bx
   850 00001316 894C06              <1>         mov     [si+mantis+2],cx
   851 00001319 896C08              <1>         mov     [si+mantis+4],bp
   852 0000131C 89440A              <1>         mov     [si+mantis+6],ax
   853                              <1> 
   854                              <1> %else
   855                              <1> ; implement Knuth algorithm for (A+b)/(C+d)
   856                              <1>         mov     cx,[si+mantis]      ;get C in CX
   857                              <1>         mov     ax,[si+mantis+2]    ;get d in AX
   858                              <1>         mov     si,[di+mantis]      ;get A in SI
   859                              <1>         mov     bx,[di+mantis+2]    ;get b in BX
   860                              <1>         or      ax,ax               ;test d
   861                              <1>         jz      FD010               ;skip correction if d==0
   862                              <1>         mul     si                  ;DX:AX is  A*d
   863                              <1>         cmp     dx,cx               ;see if overflow occurs
   864                              <1>         jb      FD005               ;no it doesn't
   865                              <1> ; got overflow problem
   866                              <1>         sub     dx,cx               ;guarantee no overflow
   867                              <1>         div     cx                  ;okay
   868                              <1> 
   869                              <1>         sub     bx,ax               ;BX is b-A*d/C
   870                              <1>         sbb     si,1                ;correct A if borrow needed
   871                              <1>         jmp     short FD010         ;rejoin main line code
   872                              <1> 
   873                              <1> FD005:
   874                              <1>         div     cx                  ;AX is A*d/C and DX is lower order
   875                              <1> 
   876                              <1>         sub     bx,ax               ;BX is b-A*d/C
   877                              <1>         sbb     si,0                ;correct A if borrow needed
   878                              <1> 
   879                              <1> FD010:
   880                              <1>         mov     dx,si               ;DX is now A
   881                              <1>         xor     si,si
   882                              <1> 
   883                              <1>         mov     ax,bx               ;AX is now B
   884                              <1>         shr     dx,1                ;make sure DX is < CX
   885                              <1>         rcr     ax,1                ;shift again
   886                              <1>         rcr     si,1                ;shift third part
   887                              <1>         div     cx                  ;AX is quotient, DX is remainder
   888                              <1>         xchg    ax,si               ;SI is hi-part of result
   889                              <1>         div     cx                  ;AX is lo-part of result
   890                              <1>         shr     cx,1                ;divide by 2
   891                              <1>         sub     cx,dx               ;borrow if dx is greater (carry set)
   892                              <1>         adc     ax,0                ;round the result
   893                              <1>         adc     si,0                ; sets/clears the Sign flag
   894                              <1> 
   895                              <1>         mov     dx,si               ;DX:AX is result
   896                              <1>         pop     si                  ;get pointer of where to put it
   897                              <1> 
   898                              <1>         js      FD060               ;go store it if already normalized
   899                              <1>         dec     word [si+expon]          ;adjust exponent
   900                              <1>         shl     ax,1                ;normalize
   901                              <1>         rcl     dx,1                ;
   902                              <1> FD060:
   903                              <1>         mov     [si+mantis],dx      ;store hi-part
   904                              <1>         mov     [si+mantis+2],ax    ;store lo-part
   905                              <1> %endif
   906 0000131F C60400              <1>         mov     byte [si+tag], tag_valid ;say destination is valid
   907                              <1> FD099:
   908 00001322 C3                  <1>         ret                     ;return to caller
   909                              <1> ;do_div  endp
   910                              <1> 
   911                              <1> 
   912                              <1> 
   913                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   914                              <1> ;
   915                              <1> ; Name:  do_compare
   916                              <1> ;
   917                              <1> ;   compare [DI] to [SI]
   918                              <1> ;   returns result of comparison in AH
   919                              <1> ;
   920                              <1> ;   AH bit settings:
   921                              <1> ;           7  6  5  4  3  2  1  0
   922                              <1> ;              Z           P     C  --  80186 flag register
   923                              <1> ;             C3          C2 C1 C0  --  80187 condition codes
   924                              <1> ;
   925                              <1> ;       [DI] = [SI]     returns  C3                 JE
   926                              <1> ;       [DI] > [SI]     returns all flags clear     JA
   927                              <1> ;       [DI] < [SI]     returns  C0                 JB
   928                              <1> ;   [DI] not comparable to [SI] returns  C3+C2+C0
   929                              <1> ;
   930                              <1> ;   uses:  AX, DX, SI, DI   (may be trashed)
   931                              <1> ;   preserves BX, CX
   932                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   933                              <1> do_compare:	;	  proc    near
   934 00001323 8A05                <1>         mov     al,byte [di+tag]         ;get destination tag
   935 00001325 0A04                <1>         or      al,byte [si+tag]         ;get source tag
   936 00001327 7541                <1>         jnz     DC100               ;tags are not both valid
   937                              <1> ; tags are valid, check signs of operands
   938 00001329 8A4401              <1>         mov     al,byte [si+sign]        ;get sign of source
   939 0000132C 3A4501              <1>         cmp     al,byte [di+sign]        ; if sS > sD,  D > S; if sS < sD,  D < S
   940 0000132F 7534                <1>         jne     DC080               ;done if not equal
   941                              <1> ; signs are the same, swap source and destination if negative
   942 00001331 08C0                <1>         or      al,al
   943 00001333 7402                <1>         jz      DC010               ;both signs are positive
   944 00001335 87F7                <1>         xchg    si,di               ;for negative, magnitude 
   945                              <1>                                     ; comparison is reversed
   946                              <1> DC010:
   947 00001337 8B4502              <1>         mov     ax,word [di+expon]       ;get destination exponent
   948 0000133A 8B5402              <1>         mov     dx,word [si+expon]       ;get source exponent
   949 0000133D 80F480              <1>         xor     ah,80h              ;bias for unsigned comparison
   950 00001340 80F680              <1>         xor     dh,80h              ; **
   951 00001343 39D0                <1>         cmp     ax,dx               ;unsigned comparison
   952 00001345 751E                <1>         jne     DC080               ;if eD > eS,  D > S; and vice versa
   953                              <1> 
   954                              <1> ; exponents are the same, compare mantissas
   955 00001347 8B4504              <1>         mov     ax,[di+mantis]      ;get high order mantissa
   956 0000134A 3B4404              <1>         cmp     ax,[si+mantis]      ;unsigned comparison
   957 0000134D 7516                <1>         jne     DC080
   958                              <1> 
   959 0000134F 8B4506              <1>         mov     ax,[di+mantis+2]      ;get high order mantissa
   960 00001352 3B4406              <1>         cmp     ax,[si+mantis+2]    ;unsigned comparison
   961                              <1> %if BIG
   962 00001355 750E                <1>         jne     DC080
   963                              <1> 
   964 00001357 8B4508              <1>         mov     ax,[di+mantis+4]    ;get high order mantissa
   965 0000135A 3B4408              <1>         cmp     ax,[si+mantis+4]    ;unsigned comparison
   966 0000135D 7506                <1>         jne     DC080
   967                              <1> 
   968 0000135F 8B450A              <1>         mov     ax,[di+mantis+6]    ;get high order mantissa
   969 00001362 3B440A              <1>         cmp     ax,[si+mantis+6]    ;unsigned comparison
   970                              <1> %endif
   971                              <1> 
   972                              <1> DC080:
   973 00001365 9F                  <1>         lahf                        ;get flags to AH
   974 00001366 80E441              <1>         and     ah,C3+C0            ;mask to Zero and Carry
   975                              <1> DC099:
   976 00001369 C3                  <1>         ret
   977                              <1> ;
   978                              <1> ; tags are not both zero; i.e., not both (tag_valid)
   979                              <1> ;
   980 0000136A A8FE                <1> DC100:  test    al,0FEh             ;test for tag_zero as only exception
   981 0000136C 7511                <1>         jnz     DC150               ;not comparable
   982 0000136E 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test source for tag_zero
   983 00001371 7504                <1>         jne     DC110
   984                              <1> ; source is tag zero
   985 00001373 89FE                <1>         mov     si,di               ;FTST  [SI]
   986 00001375 EB0C                <1>         JMP     short do_test       ;do_test will do the return
   987                              <1> 
   988                              <1> DC110:      ; SI is tag_valid, DI must be tag_zero
   989 00001377 E80900              <1>         call    do_test             ;FTST  [SI]
   990 0000137A 80F401              <1>         xor     ah,C0               ;invert comparison bit
   991 0000137D EBEA                <1>         jmp     DC099
   992                              <1>     
   993                              <1> ; one of the operands is infinity, or NaN, or empty
   994                              <1> DC150:
   995 0000137F B445                <1>         mov     ah,C3+C2+C0
   996 00001381 EBE6                <1>         jmp     DC099
   997                              <1> 
   998                              <1> ;do_compare  endp
   999                              <1> 
  1000                              <1> 
  1001                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1002                              <1> ;
  1003                              <1> ;   do_test     compare [SI] to 0.0
  1004                              <1> ;
  1005                              <1> ;   uses:  AX
  1006                              <1> ;   preserves all other registers
  1007                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1008                              <1> do_test:	;	 proc    near
  1009 00001383 803C01              <1>         cmp     byte [si+tag], tag_zero
  1010 00001386 740B                <1>         je      DT090
  1011 00001388 770E                <1>         ja      DT070
  1012                              <1> ; tag_valid
  1013 0000138A 31C0                <1>         xor     ax,ax
  1014 0000138C 3A4401              <1>         cmp     al,byte [si+sign]    ;know AL=0, it is (tag_valid)
  1015 0000138F 7202                <1>         jb      DT090           ; if 0 < sS,  S < 0.0
  1016                              <1> ;;;;      mov     ah,al           ;clear all the flags, S > 0.0
  1017 00001391 EB04                <1>         jmp     short DT099
  1018                              <1> DT090:
  1019 00001393 9F                  <1>         lahf                    ;get flags to AH
  1020 00001394 80E441              <1>         and     ah,C3+C0        ;mask to required flags
  1021                              <1> DT099:
  1022 00001397 C3                  <1>         ret                     ;and return to caller
  1023                              <1> 
  1024                              <1> ; tag is infinity, NaN, or empty
  1025                              <1> DT070:
  1026 00001398 B445                <1>         mov     ah,C3+C2+C0
  1027 0000139A EBFB                <1>         jmp     DT099
  1028                              <1> 
  1029                              <1> ;do_test endp
  1030                              <1> 
  1031                              <1> 
  1032                              <1> 
  1033                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1034                              <1> ;
  1035                              <1> ;   FCOM    mem         ST : mem
  1036                              <1> ;
  1037                              <1> ;       ES:DI is pointer to memory location
  1038                              <1> ;
  1039                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1040                              <1> genFCOM:
  1041 0000139C BE2C00              <1>         mov     si,Areg      ;load first into the Areg
  1042 0000139F BB0600              <1>         mov     bx,FMbits           ;get format mask
  1043 000013A2 20EB                <1>         and     bl,ch
  1044 000013A4 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
  1045 000013A9 30DB                <1>         xor     bl,bl
  1046 000013AB E8B0F2              <1>         call    regptr              ;get ST pointer in BX
  1047 000013AE 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
  1048 000013B0 E870FF              <1>         call    do_compare          ;return condition codes in AH
  1049                              <1> 
  1050 000013B3 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
  1051 000013B8 08260300            <1>         or      byte [codes],ah            ;set condition code bits
  1052 000013BC E9F7ED              <1>         jmp     restore_segs
  1053                              <1> 
  1054                              <1> 
  1055                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1056                              <1> ;
  1057                              <1> ;   FCOMP   mem         ST : mem
  1058                              <1> ;
  1059                              <1> ;       ES:DI is pointer to memory location
  1060                              <1> ;
  1061                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1062                              <1> genFCOMP:
  1063 000013BF BE2C00              <1>         mov     si,Areg      ;load first into the Areg
  1064 000013C2 BB0600              <1>         mov     bx,FMbits           ;get format mask
  1065 000013C5 20EB                <1>         and     bl,ch
  1066 000013C7 2EFF97[3603]        <1>   cs    call    [vecFLD+bx]          ;get the input argument
  1067 000013CC 30DB                <1>         xor     bl,bl
  1068 000013CE E88DF2              <1>         call    regptr              ;get ST pointer in BX
  1069 000013D1 89DF                <1>         mov     di,bx               ;DI is destination, SI is source
  1070                              <1> ; tos pointer is in BX
  1071 000013D3 E84DFF              <1>         call    do_compare          ;return condition codes in AH
  1072                              <1> 
  1073 000013D6 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
  1074 000013DB 08260300            <1>         or      byte [codes],ah            ;set condition code bits
  1075 000013DF E9C3ED              <1>         jmp     pop_stack           ;BX is set
  1076                              <1> 
  1077                              <1> 
  1078                              <1> 
  1079                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1080                              <1> ;
  1081                              <1> ;   FCOM    ST,ST(i)        R=0, P=0
  1082                              <1> ;
  1083                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1084                              <1> FCOMrr:
  1085 000013E2 E898EF              <1>         call    RRsetup         ;get source and destination reg. ptrs
  1086                              <1> 
  1087 000013E5 E83BFF              <1>         call    do_compare      ;do the comparison
  1088                              <1> 
  1089 000013E8 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
  1090 000013ED 08260300            <1>         or      byte [codes],ah            ;set condition code bits
  1091                              <1> ; and exit
  1092 000013F1 E9C2ED              <1>         jmp     restore_segs
  1093                              <1> 
  1094                              <1> 
  1095                              <1> 
  1096                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1097                              <1> ;
  1098                              <1> ;   FCOMP   ST,ST(i)        R=0, P=0
  1099                              <1> ;   FCOMPP  ST,ST(1)        R=1, P=1        watch out for R-bit
  1100                              <1> ;
  1101                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1102                              <1> FCOMPrr:
  1103 000013F4 88CB                <1>         mov     bl,cl           ;get source register
  1104 000013F6 E865F2              <1>         call    regptr          ;get pointer to source
  1105 000013F9 89DE                <1>         mov     si,bx           ;source ptr to SI
  1106 000013FB 31DB                <1>         xor     bx,bx           ;get ST(0)
  1107 000013FD E85EF2              <1>         call    regptr          ;get pointer to destination
  1108 00001400 89DF                <1>         mov     di,bx           ;dest. ptr to DI
  1109                              <1> ; tos pointer is in BX
  1110 00001402 E81EFF              <1>         call    do_compare          ;return condition codes in AH
  1111 00001405 80260300BA          <1>         and     byte [codes],~ (C3+C2+C0)    ;clear Status bits
  1112 0000140A 08260300            <1>         or      byte [codes],ah            ;set condition code bits
  1113                              <1> 
  1114                              <1> ; pop the tos
  1115 0000140E 803F03              <1>         cmp     byte [bx+tag], tag_empty ;test for empty register
  1116 00001411 740F                <1>         je      under2
  1117                              <1> pop002:
  1118 00001413 C60703              <1>         mov     byte [bx+tag], tag_empty     ;tag it empty
  1119 00001416 FE061000            <1>         inc     byte [tos]                 ;pop the stack
  1120 0000141A 8026100007          <1>         and     byte [tos],7               ; **
  1121                              <1> 
  1122                              <1> ; and exit
  1123 0000141F E977ED              <1>         jmp     test_pop        ;test for second pop
  1124                              <1> 
  1125                              <1> 
  1126                              <1> ; signal stack underflow
  1127                              <1> under2:
  1128 00001422 80260300FD          <1>         and     byte [codes],~ C1                ;indicate underflow
  1129 00001427 684110              <1>         push    errStkUnderflow+Sflag+Iexcept
  1130 0000142A E8C407              <1>         call    exception
  1131 0000142D EBE4                <1>         jmp     short pop002
  1132                              <1> 
  1133                              <1> 
  1134                              <1> ; end em187f.asm
   523                                  %include "em187g.asm"
   524                              <1> ; em187g.asm
   525                              <1> 
   526                              <1> ;
   527                              <1> ; handle Indefinite input to FBLD
   528                              <1> ;
   529                              <1> BL190:
   530 0000142F 6A01                <1>         push    Iexcept                 ;invalid operation
   531 00001431 E8BD07              <1>         call    exception               ;   exception
   532 00001434 C60406              <1>         mov     byte [si+tag], tag_invalid   ;flag as invalid input
   533 00001437 2401                <1>         and     al,01h                  ;mask to low bit
   534 00001439 884401              <1>         mov     byte [si+sign],al            ;store the sign as put in
   535 0000143C E977ED              <1>         jmp     restore_segs
   536                              <1> 
   537                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   538                              <1> ;
   539                              <1> ;   FBLD    mem         load Tbyte BCD number
   540                              <1> ;
   541                              <1> ;       enter with ES:DI pointing at memory operand
   542                              <1> ;
   543                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   544                              <1> gFBLD:
   545 0000143F E8F6F1              <1>         call    alloc                   ;get new ST pointer in BX
   546 00001442 89DE                <1>         mov     si,bx                   ;destination pointer to SI
   547 00001444 83C709              <1>         add     di,9                    ;point at highest order byte
   548 00001447 268A05              <1>   es    mov     al,[di]                 ;get sign byte
   549 0000144A D0E0                <1>         shl     al,1                    ;sign to carry flag
   550 0000144C D0D0                <1>         rcl     al,1                    ;sign to low byte
   551 0000144E 3C01                <1>         cmp     al,1                    ;test for indefinite
   552 00001450 77DD                <1>         ja      BL190                   ;sign is valid only if 0 or 1
   553 00001452 884401              <1>         mov     byte [si+sign],al            ;store sign
   554 00001455 C60400              <1>         mov     byte [si+tag], tag_valid     ;store tag
   555 00001458 C6061A0009          <1>         mov     byte [ctr],9                   ;count 9 bytes
   556 0000145D 31C0                <1>         xor     ax,ax                   ;clear the result
   557 0000145F 31ED                <1>         xor     bp,bp                   ;
   558 00001461 31DB                <1>         xor     bx,bx
   559 00001463 31C9                <1>         xor     cx,cx
   560 00001465 31D2                <1>         xor     dx,dx
   561                              <1> BL010:
   562 00001467 4F                  <1>         dec     di                      ;get two digits
   563 00001468 268A05              <1>   es    mov     al,[di]              ; **
   564 0000146B 08C0                <1>         or      al,al                   ;check for both zero
   565 0000146D 750F                <1>         jnz     BL030                   ;one is above zero
   566 0000146F FE0E1A00            <1>         dec     byte [ctr]                     ;count thru 9 bytes
   567 00001473 75F2                <1>         jne     BL010                   ;loop back
   568 00001475 7445                <1>         je      BL040                   ;all digits are zero
   569                              <1> 
   570                              <1> BL020:
   571 00001477 E84D00              <1>         call    times10                 ;result * 10
   572 0000147A 4F                  <1>         dec     di                      ;get next digit
   573 0000147B 268A05              <1>   es    mov     al,[di]              ; **
   574                              <1> BL030:
   575 0000147E C0E804              <1>         shr     al,4                    ;use high digit
   576 00001481 01C2                <1>         add     dx,ax                   ;add it to the result
   577 00001483 83D100              <1>         adc     cx,0                    ; **
   578 00001486 83D300              <1>         adc     bx,0                    ;  **
   579 00001489 83D500              <1>         adc     bp,0                    ;   **
   580                              <1> 
   581 0000148C E83800              <1>         call    times10                 ;result * 10
   582 0000148F 268A05              <1>   es    mov     al,[di]              ;get low digit
   583 00001492 240F                <1>         and     al,0Fh                  ; **
   584 00001494 01C2                <1>         add     dx,ax                   ;add it to the result
   585 00001496 83D100              <1>         adc     cx,0                    ;
   586 00001499 83D300              <1>         adc     bx,0
   587 0000149C 83D500              <1>         adc     bp,0
   588                              <1> 
   589 0000149F FE0E1A00            <1>         dec     byte [ctr]                     ;count thru the bytes
   590 000014A3 75D2                <1>         jne     BL020                   ;loop if some remain
   591                              <1> 
   592 000014A5 89E8                <1>         mov     ax,bp                   ;prepare to normalize
   593 000014A7 BF3F00              <1>         mov     di,63                   ;exponent
   594                              <1> %if BIG
   595 000014AA 68[B601]            <1>         push    restore_segs     ;simulate call
   596 000014AD E9AAF2              <1>         jmp     normalize_and_exit      ;will return
   597                              <1> %else
   598                              <1> 
   599                              <1> BL055:
   600                              <1>         or      ax,ax               ;test for hi zero
   601                              <1>         jnz     short BL056
   602                              <1>         xchg    bx,ax
   603                              <1>         xchg    cx,bx
   604                              <1>         xchg    dx,cx
   605                              <1>         sub     di,16               ;decrease exponent
   606                              <1>         jmp     BL055
   607                              <1> BL056:
   608                              <1>         or      ah,ah               ;test for hi zero byte
   609                              <1>         jnz     short   BL057
   610                              <1>         xchg    al,ah
   611                              <1>         xchg    bh,al
   612                              <1>         xchg    bl,bh
   613                              <1>         xchg    ch,bl
   614                              <1>         xchg    cl,ch
   615                              <1> ;;;        xchg    dh,cl
   616                              <1> ;;;        xchg    dl,dh
   617                              <1>         sub     di,8                ;adjust exponent
   618                              <1> BL057:
   619                              <1>         test    ah,80H              ;test for normalized bit
   620                              <1>         jnz     BL058
   621                              <1> 
   622                              <1> ;;;        shl     dx,1                ;normalize a bit at a time
   623                              <1> ;;;        rcl     cx,1
   624                              <1>            shl     ch,1
   625                              <1> 
   626                              <1>         rcl     bx,1
   627                              <1>         rcl     ax,1
   628                              <1>         dec     di                  ;decrease exponent
   629                              <1>         jmp     BL057
   630                              <1> %endif
   631                              <1> 
   632                              <1> BL058:  ; non-zero result
   633 000014B0 897C02              <1>         mov     word [si+expon],di       ;store new exponent
   634 000014B3 894404              <1>         mov     [si+mantis],ax
   635 000014B6 895C06              <1>         mov     [si+mantis+2],bx
   636 000014B9 E9FAEC              <1>         jmp     restore_segs
   637                              <1> 
   638                              <1> 
   639                              <1> BL040:  ; zero result
   640 000014BC C60401              <1>         mov     byte [si+tag], tag_zero      ;result was zero
   641 000014BF 884401              <1>         mov     byte [si+sign],al            ;all regs are zero
   642 000014C2 BF0180              <1>         mov     di,exp_of_FPzero        ;zero has funny exponent
   643 000014C5 EBE9                <1>         jmp     BL058
   644                              <1> 
   645                              <1> 
   646                              <1> ; internal subroutine to multiply BP:BX:CX:DX by 10
   647                              <1> 
   648                              <1> times10:	;	 proc    near
   649 000014C7 89161C00            <1>         mov     word [mtemp],dx
   650 000014CB 890E1E00            <1>         mov     word [mtemp+2],cx
   651 000014CF 891E2000            <1>         mov     word [mtemp+4],bx
   652 000014D3 892E2200            <1>         mov     word [mtemp+6],bp
   653                              <1> 
   654 000014D7 D1E2                <1>         shl     dx,1                    ;times 2 to begin
   655 000014D9 D1D1                <1>         rcl     cx,1
   656 000014DB D1D3                <1>         rcl     bx,1
   657 000014DD D1D5                <1>         rcl     bp,1
   658                              <1> 
   659 000014DF D1E2                <1>         shl     dx,1                    ;times 4 to begin
   660 000014E1 D1D1                <1>         rcl     cx,1
   661 000014E3 D1D3                <1>         rcl     bx,1
   662 000014E5 D1D5                <1>         rcl     bp,1
   663                              <1> 
   664 000014E7 03161C00            <1>         add     dx,word [mtemp]                ;times 5
   665 000014EB 130E1E00            <1>         adc     cx,word [mtemp+2]
   666 000014EF 131E2000            <1>         adc     bx,word [mtemp+4]
   667 000014F3 132E2200            <1>         adc     bp,word [mtemp+6]
   668                              <1> 
   669 000014F7 D1E2                <1>         shl     dx,1                    ;times 10
   670 000014F9 D1D1                <1>         rcl     cx,1
   671 000014FB D1D3                <1>         rcl     bx,1
   672 000014FD D1D5                <1>         rcl     bp,1
   673 000014FF C3                  <1>         ret                             ;done
   674                              <1> ;times10 endp
   675                              <1> 
   676                              <1> 
   677                              <1> 
   678                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   679                              <1> ;
   680                              <1> ;   FBSTP   mem         store Tbyte BCD number
   681                              <1> ;
   682                              <1> ;       enter with ES:DI pointing at memory destination
   683                              <1> ;
   684                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   685                              <1> gFBSTP:
   686 00001500 1E                  <1>         push    ds                  ;save DS
   687                              <1> 
   688 00001501 30DB                <1>         xor     bl,bl               ;ST(0) needed
   689 00001503 E858F1              <1>         call    regptr              ;get BX pointing to stact top
   690 00001506 53                  <1>         push    bx                  ;save pointer for later pop
   691                              <1> 
   692 00001507 8A7701              <1>         mov     dh,byte [bx+sign]        ;get sign of operand
   693 0000150A D0EE                <1>         shr     dh,1                ;sign to carry
   694 0000150C D0DE                <1>         rcr     dh,1                ;sign to hi-bit
   695 0000150E 52                  <1>         push    dx                  ;save sign byte in DH
   696                              <1> 
   697 0000150F 8A07                <1>         mov     al,byte [bx+tag]         ;get tag
   698 00001511 3C01                <1>         cmp     al,tag_zero         ;test for special tag
   699 00001513 7611                <1>         jbe     BS010               ;if okay
   700                              <1> ; tag is funny, store indefinite
   701                              <1> BS005:
   702 00001515 6A01                <1>         push    Iexcept             ;invalid operation
   703 00001517 EB02                <1>         jmp     short BS008
   704                              <1> BS006:
   705 00001519 6A09                <1>         push    Iexcept+Oexcept     ;overflow & invalid
   706                              <1> BS008:
   707 0000151B E8D306              <1>         call    exception
   708 0000151E 26C74508FFFF        <1>   es    mov     word [di+8],0FFFFh   ;store indefinite
   709 00001524 EB76                <1>         jmp     short BS090         ;go do the proper pops
   710                              <1> 
   711                              <1> BS010:      ;tag was valid
   712 00001526 B93F00              <1>         mov     cx,63               ;get max. shift
   713 00001529 2B4F02              <1>         sub     cx,word [bx+expon]       ;subtract exponent
   714 0000152C 7EEB                <1>         jle     BS006               ;signal invalid and overflow
   715                              <1> 
   716 0000152E 89DE                <1>         mov     si,bx               ;point SI at input, for 'round_mag'
   717 00001530 E8D000              <1>         call    vloadsh64           ;load 64 bits, extend if necessary
   718 00001533 E88000              <1>         call    round_mag           ;round as specified
   719                              <1> 
   720 00001536 06                  <1>         push    es
   721 00001537 1F                  <1>         pop     ds                      
   722                              <1> 
   723 00001538 89D5                <1>         mov     bp,dx           ;move low order word to BP
   724 0000153A 31D2                <1>         XOR     DX,DX           ;DX = 0
   725 0000153C BE1027              <1>         MOV     si,10000        ;WILL USE THIS CONSTANT QUITE A LOT
   726                              <1> 
   727                              <1> ; START WITH 63 MAGNITUDE BITS
   728 0000153F F7F6                <1>         DIV     si              ;AX = Q4, DX = R4
   729                              <1> ; AX MUST BE ZERO AT THIS POINT
   730 00001541 93                  <1>         XCHG    AX,BX           ;AX = 3, BX = Q4
   731 00001542 F7F6                <1>         DIV     si              ;DX = R3
   732 00001544 91                  <1>         XCHG    AX,CX           ;AX = 2, CX = Q3
   733 00001545 F7F6                <1>         DIV     si              ;DX = R2
   734 00001547 95                  <1>         XCHG    AX,BP           ;AX = 1, BP = Q2
   735 00001548 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   736                              <1> ;;;        MOV     ds:[di],DX       ;SAVE LOWEST 4 DIGITS IN BINARY
   737 0000154A 8915                <1>         MOV     [di],DX       ;SAVE LOWEST 4 DIGITS IN BINARY
   738                              <1> 
   739                              <1> ;CONTINUE WITH 50 MAGNITUDE BITS
   740 0000154C 89DA                <1>         MOV     DX,BX           ;DX = 2 BITS OR LESS
   741 0000154E 91                  <1>         XCHG    AX,CX           ;CX = 1
   742 0000154F F7F6                <1>         DIV     si              ;DX = R3
   743 00001551 95                  <1>         XCHG    AX,BP           ;BP = Q3
   744 00001552 F7F6                <1>         DIV     si              ;DX = R2
   745 00001554 91                  <1>         XCHG    AX,CX           ;CX = Q2
   746 00001555 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   747                              <1> ;;;        MOV     ds:[di]+2,DX     ;SAVE SECOND SET OF 4 DIGITS IN BINARY
   748 00001557 895502              <1>         MOV     [di+2],DX     ;SAVE SECOND SET OF 4 DIGITS IN BINARY
   749                              <1> 
   750                              <1> ;CONTINUE WITH 37 MAGNITUDE BITS
   751 0000155A 89EA                <1>         MOV     DX,BP           ;DX = 5 BITS OR LESS
   752 0000155C 91                  <1>         XCHG    AX,CX           ;CX = 1
   753 0000155D F7F6                <1>         DIV     si              ;DX = R2
   754 0000155F 91                  <1>         XCHG    AX,CX           ;CX = Q2
   755 00001560 F7F6                <1>         DIV     si              ;DX = R1, AX = Q1
   756 00001562 895504              <1>         MOV     [di+4],DX     ;SAVE THIRD SET OF 4 DIGITS IN BINARY
   757                              <1> 
   758                              <1> ;CONTINUE WITH 23 MAGNITUDE BITS
   759 00001565 89CA                <1>         MOV     DX,CX           ;DX = 7 BITS OR LESS
   760 00001567 F7F6                <1>         DIV     si              ;DX = R1
   761 00001569 895506              <1>         MOV     [di+6],DX     ;SAVE 4TH SET OF 4 DIGITS IN BINARY
   762                              <1> 
   763                              <1> ;QUOTIENT IN AX IS 10 BITS OR LESS
   764 0000156C 83F863              <1>         cmp     ax,99           ;must be .le. 99.
   765 0000156F 77A8                <1>         ja      BS006           ;error if above 99
   766                              <1> 
   767 00001571 8D7506              <1>         LEA     SI,[di+6]      ;POINT AT FOURTH WORD AS SOURCE
   768 00001574 8D7D09              <1>         LEA     DI,[di+9]      ;POINT AT HIGHEST BYTE (SIGN BYTE)
   769 00001577 FD                  <1>         STD                     ;SET TO GO FROM HIGH TO LOW
   770 00001578 B90500              <1>         MOV     CX,5            ;SET FOR 5 WORDS        
   771 0000157B BD6400              <1>         MOV     BP,100          ;DIVISOR OF 100
   772 0000157E B30A                <1>         MOV     BL,10           ;DIVISOR OF 10
   773 00001580 EB01                <1>         JMP     SHORT EMFBSTP11 ;ENTER LOOP AFTER LOAD
   774                              <1> 
   775                              <1> EMFBSTP10:
   776 00001582 AD                  <1>         LODSW                   ;GET 4 DIGITS IN BINARY
   777                              <1> EMFBSTP11:
   778 00001583 31D2                <1>         XOR     DX,DX           ;DX = 0 FOR DIVIDE
   779 00001585 F7F5                <1>         DIV     BP              ;DX IS LOW TWO DIGITS, AX IS HI DIGITS
   780                              <1> 
   781 00001587 F6F3                <1>         DIV     BL              ;AH IS LOWEST DIGIT, AL IS HIGH DIGIT
   782 00001589 C0E004              <1>         SHL     AL,4
   783 0000158C 08E0                <1>         OR      AL,AH           ;AL IS TWO DIGITS
   784 0000158E AA                  <1>         STOSB                   ;STORE DIGIT PAIR
   785                              <1> 
   786 0000158F 89D0                <1>         MOV     AX,DX           ;GET 2 LOWER DIGITS TO AX
   787 00001591 F6F3                <1>         DIV     BL              ;AH IS LOWEST DIGIT, AL IS HIGH DIGIT
   788 00001593 C0E004              <1>         SHL     AL,4
   789 00001596 08E0                <1>         OR      AL,AH           ;AL IS TWO DIGITS
   790 00001598 AA                  <1>         STOSB                   ;STORE DIGIT PAIR
   791 00001599 E2E7                <1>         LOOP    EMFBSTP10       ;LOOP BACK
   792                              <1>         
   793 0000159B 47                  <1>         INC     di              ;RESTORE di
   794                              <1> 
   795                              <1> ; ADD SIGN TO RESULT
   796                              <1> BS090:
   797 0000159C 5A                  <1>         POP     DX              ;GET SAVED SIGN
   798 0000159D 087509              <1>         OR      [di+9],DH       ;SET SIGN BYTE
   799                              <1> 
   800 000015A0 5B                  <1>         pop     bx                  ;restore the tos pointer
   801 000015A1 1F                  <1>         pop     ds                  ;restore DS pointer
   802 000015A2 E900EC              <1>         jmp     pop_stack           ;BX is set
   803                              <1> 
   804                              <1> 
   805 000015A5 90                  <1>         even
   806 000015A6 [C515][C515][F115]- <1> rnd_vec dw  nearest,nearest,  chop,up,  up,chop,  chop,chop
   806 000015AC [DA15][DA15][F115]- <1>
   806 000015B2 [F115][F115]        <1>
   807                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   808                              <1> ;   Name:  round_mag
   809                              <1> ;   Desc:  round the magnitude in AX:BX:CX:DX according to
   810                              <1> ;          the current rounding mode, and the Sign pointed at by
   811                              <1> ;          SI.
   812                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   813                              <1> round_mag:	;	   proc    near
   814 000015B6 53                  <1>         push    bx
   815 000015B7 8B1E0E00            <1>         mov     bx,word [round]        ;get rounding control (0,2,4,6)
   816 000015BB 025C01              <1>         add     bl,byte [si+sign]    ;get dispatch 0..7
   817 000015BE D0E3                <1>         shl     bl,1            ; ** 0,2,4,6,..,14
   818 000015C0 2EFFA7[A615]        <1>   cs    jmp     [rnd_vec+bx]     ;dispatch to proper rounding mode
   819                              <1> 
   820                              <1> ; round magnitude to nearest or even
   821                              <1> nearest:
   822 000015C5 F606130080          <1>         test    byte [guard],80h       ;see if guard bit is set
   823 000015CA 7425                <1>         jz      chop            ;do nothing if not set
   824                              <1> ; guard bit is set
   825 000015CC F6061200FF          <1>         test    byte [sticky],0FFh     ;see if sticky bit is set
   826 000015D1 750F                <1>         jnz     RM020           ;must increment if guard and sticky both set
   827                              <1> ; sticky is not set, round to even
   828 000015D3 F6C201              <1>         test    dl,01           ;see if low bit is set
   829 000015D6 750A                <1>         jnz     RM020           ;must increment to even if odd
   830 000015D8 7417                <1>         jz      chop            ;must leave even if already there
   831                              <1> 
   832                              <1> ; round magnitude toward  + infinity
   833                              <1> up:         ;increment magnitude if guard or sticky set
   834 000015DA 8B1E1200            <1>         mov     bx,word [guard_sticky] ;get guard and sticky bits
   835 000015DE 08FB                <1>         or      bl,bh           ;see if either set
   836 000015E0 740F                <1>         jz      chop            ;done if neither set
   837                              <1> ; must increment the magnitude
   838 000015E2 83C201              <1> RM020:  add     dx,1            ;must use ADD, not INC, to set carry flag
   839 000015E5 83D100              <1>         adc     cx,0
   840 000015E8 5B                  <1>         pop     bx
   841 000015E9 83D300              <1>         adc     bx,0
   842 000015EC 83D000              <1>         adc     ax,0
   843 000015EF EB01                <1>         jmp     short RM099     ;and exit
   844                              <1> 
   845                              <1> ; chop means do nothing to the magnitude
   846                              <1> chop:
   847 000015F1 5B                  <1>         pop     bx              ;restore register
   848                              <1> RM099:
   849 000015F2 C3                  <1>         ret                     ;and return
   850                              <1> ;round_mag   endp
   851                              <1> 
   852                              <1> 
   853                              <1> 
   854                              <1> 
   855                              <1> ; shift was so big (>64), zero mantissa is the result
   856                              <1> vl64100:
   857 000015F3 31C0                <1>         xor     ax,ax
   858 000015F5 31DB                <1>         xor     bx,bx
   859 000015F7 31C9                <1>         xor     cx,cx
   860 000015F9 31D2                <1>         xor     dx,dx
   861 000015FB C7061200FF00        <1>         mov     word [guard_sticky],00FFh  ;guard of zero, sticky set
   862 00001601 EB7A                <1>         jmp     vl64099
   863                              <1> 
   864                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   865                              <1> ;   Name:  vloadsh64
   866                              <1> ;   Desc:  get the mantissa pointed to by BX, and shift right by
   867                              <1> ;          the amount in CX.  If 32 bit mantissa, extend to 64 bits.
   868                              <1> ;       Return result in  AX:BX:CX:DX
   869                              <1> ;       Compute the 'guard' and 'sticky' bits, also
   870                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   871                              <1> vloadsh64:	;	  proc    near
   872 00001603 83F940              <1>         cmp     cx,64       ;shift of 63 is the max for 64-bit mantissa
   873 00001606 77EB                <1>         ja      vl64100     ;go return zero
   874                              <1> 
   875 00001608 56                  <1>         push    si          ;counter will be here for 64-bit mantissa
   876 00001609 57                  <1>         push    di          ;save register DI
   877                              <1> 
   878                              <1> %if BIG
   879                              <1> %else
   880                              <1>         cmp     cx,32       ;test for brief load
   881                              <1>         jb      vl64005
   882                              <1>         sub     cx,32       ;reduce by 32
   883                              <1>         xor     ax,ax
   884                              <1>         xor     di,di
   885                              <1>         mov     si,[bx+mantis]      ;get first word
   886                              <1>         mov     dx,[bx+mantis+2]    ;get the second
   887                              <1>         jmp     short vl64007
   888                              <1>         
   889                              <1> vl64005:
   890                              <1> %endif
   891                              <1> 
   892 0000160A 8B4704              <1>         mov     ax,[bx+mantis]      ;first word of mantissa
   893 0000160D 8B7F06              <1>         mov     di,[bx+mantis+2]    ;second word
   894                              <1> %if BIG
   895 00001610 8B7708              <1>         mov     si,[bx+mantis+4]    ;third word of mantissa
   896 00001613 8B570A              <1>         mov     dx,[bx+mantis+6]    ;fourth word of mantissa
   897                              <1> %else
   898                              <1>         xor     si,si               ;third word of mantissa
   899                              <1>         xor     dx,dx               ;fourth word of mantissa
   900                              <1> 
   901                              <1> vl64007:
   902                              <1> %endif
   903                              <1> 
   904 00001616 31DB                <1>         xor     bx,bx               ;BH is guard bit, BL is sticky bit
   905 00001618 80F910              <1>         cmp     cl,16               ;compare to 16
   906 0000161B 721A                <1>         jb      vl64020             ;skip 16 bit shifts if below 16
   907                              <1> vl64010:
   908 0000161D 08FB                <1>         or      bl,bh               ;guard into sticky
   909 0000161F D0E6                <1>         shl     dh,1                ;isolate new guard bit in carry
   910 00001621 D0DF                <1>         rcr     bh,1                ;guard bit to BH
   911 00001623 08F2                <1>         or      dl,dh               ;sticky in DL
   912 00001625 08D3                <1>         or      bl,dl               ;new sticky in BL
   913 00001627 89F2                <1>         mov     dx,si               ;shift by 16 bits
   914 00001629 89FE                <1>         mov     si,di               ;**
   915 0000162B 89C7                <1>         mov     di,ax               ; **
   916 0000162D 31C0                <1>         xor     ax,ax               ;  **
   917 0000162F 80E910              <1>         sub     cl,16
   918 00001632 80F910              <1>         cmp     cl,16               ;compare if another 16-bit shift is needed
   919 00001635 77E6                <1>         ja      vl64010             ;loop back if above zero
   920                              <1> vl64020:            ; check for 8 bit shift
   921 00001637 80F908              <1>         cmp     cl,8            
   922 0000163A 7223                <1>         jb      vl64040
   923                              <1> 
   924 0000163C 08FB                <1>         or      bl,bh           ;guard into sticky
   925 0000163E D0E2                <1>         shl     dl,1            ;isolate new guard bit in carry
   926 00001640 D0DF                <1>         rcr     bh,1            ;guard bit to BH
   927 00001642 08D3                <1>         or      bl,dl           ;new sticky in BL
   928                              <1> 
   929 00001644 87CE                <1>         xchg    cx,si           ;do a long 8 bit shift
   930 00001646 88F2                <1>         mov     dl,dh
   931 00001648 88CE                <1>         mov     dh,cl
   932 0000164A 87DF                <1>         xchg    bx,di           ;BX has 2 halves
   933 0000164C 88E9                <1>         mov     cl,ch
   934 0000164E 88DD                <1>         mov     ch,bl
   935 00001650 88FB                <1>         mov     bl,bh           ;do the short portion of an 8-bit shift
   936 00001652 88C7                <1>         mov     bh,al
   937 00001654 88E0                <1>         mov     al,ah
   938 00001656 30E4                <1>         xor     ah,ah
   939 00001658 87CE                <1>         xchg    cx,si           ;restore the exchanged registers
   940 0000165A 87DF                <1>         xchg    bx,di
   941                              <1> 
   942 0000165C 80E908              <1>         sub     cl,8
   943                              <1> vl64040:
   944 0000165F E30F                <1>         jcxz    vl64090         ;may have been reduced this far
   945 00001661 90                  <1>         even
   946                              <1> vl64050:
   947 00001662 08FB                <1>         or      bl,bh           ;guard into sticky
   948 00001664 D1E8                <1>         shr     ax,1            ;short right shift of 1 bit
   949 00001666 D1DF                <1>         rcr     di,1
   950 00001668 D1DE                <1>         rcr     si,1            ;long extension, right shift 1 bit
   951 0000166A D1DA                <1>         rcr     dx,1
   952 0000166C D0DF                <1>         rcr     bh,1            ;new guard bit
   953 0000166E E2F2                <1>         loop    vl64050
   954                              <1> vl64090:
   955 00001670 80E780              <1>         and     bh,80h          ;isolate the real guard bit
   956 00001673 891E1200            <1>         mov     word [guard_sticky],bx ;set guard and sticky bits
   957 00001677 89F1                <1>         mov     cx,si           ;result goes back in AX:BX:CX:DX
   958 00001679 89FB                <1>         mov     bx,di           ; **
   959 0000167B 5F                  <1>         pop     di              ;restore saved register
   960 0000167C 5E                  <1>         pop     si              ;restore saved register
   961                              <1> vl64099:
   962 0000167D C3                  <1>         ret
   963                              <1> 
   964                              <1> ;vloadsh64  endp
   965                              <1> 
   966                              <1> 
   967                              <1> 
   968                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   969                              <1> ;
   970                              <1> ;   FXTRACT             ST is operand
   971                              <1> ;
   972                              <1> ;       exponent replaces ST and significand is pushed,
   973                              <1> ;       with exponent of true 0
   974                              <1> ;
   975                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   976                              <1> gFXTRACT:
   977 0000167E 30DB                <1>         xor     bl,bl               ;get tos ptr
   978 00001680 E8DBEF              <1>         call    regptr              ;ST pointer to BX
   979 00001683 89DE                <1>         mov     si,bx               ;tos ptr to SI
   980 00001685 E8B0EF              <1>         call    alloc               ;get new ST pointer
   981                              <1> 
   982 00001688 8B04                <1>         mov     ax,[si]             ;move tag and sign
   983 0000168A 8907                <1>         mov     [bx],ax
   984 0000168C C747020000          <1>         mov     word [bx+expon],0        ;zero is final exponent
   985                              <1> 
   986 00001691 8B4404              <1>         mov     ax,[si+mantis]      ;move mantissa
   987 00001694 894704              <1>         mov     [bx+mantis],ax
   988 00001697 8B4406              <1>         mov     ax,[si+mantis+2]
   989 0000169A 894706              <1>         mov     [bx+mantis+2],ax
   990                              <1> %if BIG
   991 0000169D 8B4408              <1>         mov     ax,[si+mantis+4]
   992 000016A0 894708              <1>         mov     [bx+mantis+4],ax
   993 000016A3 8B440A              <1>         mov     ax,[si+mantis+6]
   994 000016A6 89470A              <1>         mov     [bx+mantis+6],ax
   995                              <1> %endif
   996 000016A9 8D7C02              <1>         lea     di,[si+expon]       ; ES:DI points at integer to load
   997 000016AC 1E                  <1>         push    ds                  ; SI points at accumulator to receive
   998 000016AD 07                  <1>         pop     es                  ;     the resulting value
   999 000016AE E86CF0              <1>         call    load_I16            ;
  1000 000016B1 E902EB              <1>         jmp     restore_segs
  1001                              <1> 
  1002                              <1> 
  1003                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1004                              <1> ;
  1005                              <1> ;   FSCALE          ST(1) is chopped to an integer
  1006                              <1> ;                   and added to the exponent of ST(0)
  1007                              <1> ;
  1008                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1009                              <1> gFSCALE:
  1010 000016B4 B301                <1>         mov     bl,1                ;get ST(1)
  1011 000016B6 E8A5EF              <1>         call    regptr              ; pointer in BX
  1012 000016B9 89DE                <1>         mov     si,bx               ;save pointer in SI
  1013                              <1> %if BIG
  1014 000016BB B93F00              <1>         mov     cx,63               ;truncate to integer
  1015                              <1> %else
  1016                              <1>         mov     cx,31               ;truncate to integer
  1017                              <1> %endif
  1018 000016BE 2B4F02              <1>         sub     cx,word [bx+expon]       ;form number to shift by
  1019 000016C1 E817EF              <1>         call    vloadshift          ;get the magnitude
  1020                              <1> %if  BIG
  1021 000016C4 89C8                <1>         mov     ax,cx               ;magnitude to ax
  1022                              <1> %endif
  1023 000016C6 F6440101            <1>         test    byte [si+sign],01h       ;test sign of ST(1)
  1024 000016CA 7402                <1>         jz      FSC10
  1025 000016CC F7D8                <1>         neg     ax                  ;value is negative
  1026                              <1> FSC10:
  1027 000016CE 30DB                <1>         xor     bl,bl
  1028 000016D0 E88BEF              <1>         call    regptr              ;get ST(0) pointer in BX
  1029 000016D3 014702              <1>         add     word [bx+expon],ax       ;modify exponent
  1030                              <1> 
  1031 000016D6 E9DDEA              <1>         jmp     restore_segs
  1032                              <1> 
  1033                              <1> 
  1034                              <1> 
  1035                              <1> 
  1036                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1037                              <1> ;
  1038                              <1> ;   FSTP        QWORD PTR mem
  1039                              <1> ;
  1040                              <1> ;       ES:DI points at 64 bit integer
  1041                              <1> ;
  1042                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1043                              <1> FSTPi64:
  1044 000016D9 30DB                <1>         xor     bl,bl               ;get ST(0) pointer in BX
  1045 000016DB E880EF              <1>         call    regptr              ; **
  1046 000016DE 89DE                <1>         mov     si,bx               ;save pointer in SI
  1047 000016E0 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;check the tag
  1048 000016E3 773E                <1>         ja      STI64160            ;problem tag, store indefinite
  1049                              <1> 
  1050 000016E5 B93F00              <1>         mov     cx,63               ;get max shift
  1051 000016E8 2B4F02              <1>         sub     cx,word [bx+expon]       ;get shift count
  1052 000016EB 7E32                <1>         jle     STI64150            ;shift is negative or zero, overflow occurs
  1053                              <1> 
  1054 000016ED E813FF              <1>         call    vloadsh64           ;get 64 bit mantissa, shifted
  1055                              <1> 
  1056 000016F0 E8C3FE              <1>         call    round_mag           ;round magnitude according to RC bits
  1057                              <1> 
  1058 000016F3 807C0100            <1>         cmp     byte [si+sign],0         ;test for minus
  1059 000016F7 7412                <1>         je      STI64050
  1060                              <1> ; must negate it
  1061 000016F9 F7D0                <1>         not     ax
  1062 000016FB F7D3                <1>         not     bx
  1063 000016FD F7D1                <1>         not     cx
  1064 000016FF F7DA                <1>         neg     dx
  1065 00001701 F5                  <1>         cmc
  1066 00001702 83D100              <1>         adc     cx,0
  1067 00001705 83D300              <1>         adc     bx,0
  1068 00001708 83D000              <1>         adc     ax,0
  1069                              <1> ; ready to store result
  1070                              <1> STI64050:
  1071 0000170B 26894506            <1>   es    mov     [di+6],ax            ;store high order
  1072 0000170F 26895D04            <1>   es    mov     [di+4],bx            ;store lower order
  1073 00001713 26894D02            <1>   es    mov     [di+2],cx            ;store third part
  1074 00001717 268915              <1>   es    mov     [di],dx              ;store lowest order part
  1075                              <1> STI64090:
  1076                              <1> ; pop the tos
  1077 0000171A 89F3                <1>         mov     bx,si                   ;set BX for pop
  1078 0000171C E986EA              <1>         jmp     pop_stack               ; go do pop
  1079                              <1> 
  1080                              <1> 
  1081                              <1> STI64150:   ; exponent too big
  1082 0000171F 6A08                <1>         push    Oexcept                 ;overflow
  1083 00001721 EB07                <1>         jmp     short STI64170
  1084                              <1> 
  1085                              <1> STI64160:   ; tag is infin, empty or invalid
  1086 00001723 803F02              <1>         cmp     byte [bx+tag], tag_infin     ;test for infinity
  1087 00001726 74F7                <1>         je      STI64150                ;signal overflow
  1088                              <1> 
  1089 00001728 6A01                <1>         push    Iexcept                 ;invalid operation
  1090                              <1> 
  1091                              <1> STI64170:   ;general problem exit, signal exception & store indefinite
  1092 0000172A E8C404              <1>         call    exception
  1093 0000172D 26C745060080        <1>   es    mov     word [di+6],8000h         ;integer indefinite
  1094 00001733 31C0                <1>         xor     ax,ax
  1095 00001735 26894504            <1>   es    mov     [di+4],ax
  1096 00001739 26894502            <1>   es    mov     [di+2],ax
  1097 0000173D 268905              <1>   es    mov     [di],ax
  1098 00001740 EBD8                <1>         jmp     STI64090                ;go pop and exit
  1099                              <1> 
  1100                              <1> 
  1101                              <1> 
  1102                              <1> ; end em187g.asm
   524                                  %include "em187h.asm"
   525                              <1> ; em187h.asm
   526                              <1> 
   527                              <1> 
   528                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   529                              <1> ;
   530                              <1> ;   FLD     tmpReal         load 10-byte real
   531                              <1> ;
   532                              <1> ;       ES:DI points at memory location
   533                              <1> ;
   534                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   535                              <1> FLDtmp:
   536 00001742 E8F3EE              <1>         call    alloc               ;get ST pointer in BX
   537 00001745 268B4508            <1>   es    mov     ax,[di+8]        ;get sign and exponent
   538 00001749 31D2                <1>         xor     dx,dx               ;clear DX
   539 0000174B D1E0                <1>         shl     ax,1                ;sign to carry
   540 0000174D D0D2                <1>         rcl     dl,1                ;sign to DL
   541 0000174F 885701              <1>         mov     byte [bx+sign],dl        ;store sign
   542 00001752 C60700              <1>         mov     byte [bx+tag], tag_valid ;set up valid tag
   543                              <1> 
   544 00001755 D1E8                <1>         shr     ax,1                ;biased exponent to AX
   545 00001757 3DFF7F              <1>         cmp     ax,7FFFh            ;check for infinity
   546 0000175A 7428                <1>         je      LT100               ;it may be
   547 0000175C 09C0                <1>         or      ax,ax               ;test for 0
   548 0000175E 744B                <1>         jz      LT150               ;may be a DeNormal or zero
   549 00001760 2DFF3F              <1>         sub     ax,3FFFh            ;get true exponent
   550                              <1> LT010:
   551 00001763 894702              <1>         mov     word [bx+expon],ax
   552 00001766 268B4506            <1>   es    mov     ax,[di+6]        ;get high mantissa
   553 0000176A 894704              <1>         mov     [bx+mantis],ax
   554 0000176D 268B4504            <1>   es    mov     ax,[di+4]        ;get second mantissa
   555 00001771 894706              <1>         mov     [bx+mantis+2],ax
   556                              <1> %if BIG
   557 00001774 268B4502            <1>   es    mov     ax,[di+2]        ;get third mantissa
   558 00001778 894708              <1>         mov     [bx+mantis+4],ax
   559 0000177B 268B05              <1>   es    mov     ax,[di]          ;get lowest mantissa
   560 0000177E 89470A              <1>         mov     [bx+mantis+6],ax
   561                              <1> %endif
   562                              <1> LT099:
   563 00001781 E932EA              <1>         jmp     restore_segs
   564                              <1> 
   565                              <1> LT100:      ;check for possible infinity
   566 00001784 26817D060080        <1>   es    cmp     word [di+6],8000h     ;check for infinity
   567 0000178A 7512                <1>         jne     LT120
   568 0000178C 268B5504            <1>   es    mov     dx,[di+4]        ;rest must be zero
   569 00001790 260B5502            <1>   es    or      dx,[di+2]        ;
   570 00001794 260B15              <1>   es    or      dx,[di]
   571 00001797 7505                <1>         jnz     LT120
   572 00001799 C60702              <1>         mov     byte [bx+tag], tag_infin
   573                              <1> ;       mov     ax,exp_of_FPinf
   574 0000179C EBC5                <1>         jmp     LT010               ;copy rest of mantissa
   575 0000179E C60706              <1> LT120:  mov     byte [bx+tag], tag_invalid
   576 000017A1 6A01                <1>         push    Iexcept             ;invalid operation
   577 000017A3 E84B04              <1>         call    exception
   578 000017A6 B8FF7F              <1>         mov     ax,exp_of_FPinf
   579 000017A9 EBB8                <1>         jmp     LT010               ;copy rest of mantissa        
   580                              <1> 
   581                              <1> LT150:      ;possible zero or denormal
   582 000017AB 268B5506            <1>   es    mov     dx,[di+6]        ;get high part of mantissa
   583 000017AF 260B5504            <1>   es    or      dx,[di+4]        ;rest must be zero
   584 000017B3 260B5502            <1>   es    or      dx,[di+2]        ;
   585 000017B7 260B15              <1>   es    or      dx,[di]
   586 000017BA B80180              <1>         mov     ax,exp_of_FPzero    ;get exponent of zero
   587 000017BD C60701              <1>         mov     byte [bx+tag], tag_zero
   588 000017C0 74A1                <1>         jz      LT010
   589                              <1> 
   590 000017C2 6A02                <1>         push    Dexcept             ;we don't try to normalize it
   591 000017C4 E82A04              <1>         call    exception
   592 000017C7 EBD5                <1>         jmp     LT120
   593                              <1> 
   594                              <1> 
   595                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   596                              <1> ;
   597                              <1> ;   FSTP    tmpReal         store 10-byte real
   598                              <1> ;
   599                              <1> ;       ES:DI points at memory location
   600                              <1> ;
   601                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   602                              <1> FSTPtmp:
   603 000017C9 30DB                <1>         xor     bl,bl               ;get ST(0) pointer to BX
   604 000017CB E890EE              <1>         call    regptr              ; **
   605 000017CE 8A5701              <1>         mov     dl,byte [bx+sign]        ;get sign
   606 000017D1 D0CA                <1>         ror     dl,1                ;sign to hi bit of DL
   607 000017D3 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;
   608 000017D6 7342                <1>         jae     STP100              ;may be zero or problem
   609 000017D8 8B4702              <1>         mov     ax,word [bx+expon]       ;get exponent
   610 000017DB 2D01C0              <1>         sub     ax,-16383           ;bias it
   611 000017DE 7C29                <1>         jl      STP095              ;too small
   612 000017E0 3DFF7F              <1>         cmp     ax,7FFFh            ;check for too big
   613 000017E3 732B                <1>         jae     STP097              ;too big
   614 000017E5 08D4                <1>         or      ah,dl               ;sign bit to AH
   615 000017E7 26894508            <1>   es    mov     [di+8],ax        ;store sign and exponent
   616                              <1> 
   617 000017EB 8B4704              <1>         mov     ax,[bx+mantis]
   618 000017EE 26894506            <1>   es    mov     [di+6],ax        ;store mantissa
   619 000017F2 8B4706              <1>         mov     ax,[bx+mantis+2]
   620 000017F5 26894504            <1>   es    mov     [di+4],ax
   621                              <1> %if BIG
   622 000017F9 8B4708              <1>         mov     ax,[bx+mantis+4]
   623 000017FC 26894502            <1>   es    mov     [di+2],ax
   624 00001800 8B470A              <1>         mov     ax,[bx+mantis+6]
   625 00001803 268905              <1>   es    mov     [di],ax
   626                              <1> %else
   627                              <1>         xor     ax,ax
   628                              <1>   es    mov     [di+2],ax
   629                              <1>   es    mov     [di],ax
   630                              <1> %endif
   631                              <1> STP090:
   632 00001806 E99CE9              <1>         jmp     pop_stack           ;BX is set ok
   633                              <1> 
   634                              <1> STP095:
   635 00001809 6A10                <1>         push    Uexcept             ;underflow
   636 0000180B E8E303              <1>         call    exception           ;
   637 0000180E EB0C                <1>         jmp     short STP105        ;store zero
   638                              <1> STP097:
   639 00001810 6A08                <1>         push    Oexcept             ;overflow
   640 00001812 E8DC03              <1>         call    exception
   641 00001815 B8FF7F              <1>         mov     ax,7FFFh            ;get largest exponent
   642 00001818 EB25                <1>         jmp     short STP160
   643                              <1> 
   644                              <1> 
   645                              <1> ; tag is .ge. tag_zero
   646                              <1> STP100:
   647 0000181A 771B                <1>         ja      STP150                  ;jump if problem
   648                              <1> ; tag is zero
   649                              <1> STP105:
   650 0000181C 31C0                <1>         xor     ax,ax
   651 0000181E 88D4                <1>         mov     ah,dl                   ;sign it
   652 00001820 26894508            <1>   es    mov     [di+8],ax            ;store signed zero
   653 00001824 30E4                <1>         xor     ah,ah
   654 00001826 26894506            <1>   es    mov     [di+6],ax
   655                              <1> STP130:
   656 0000182A 26894504            <1>   es    mov     [di+4],ax
   657 0000182E 26894502            <1>   es    mov     [di+2],ax
   658 00001832 268905              <1>   es    mov     [di],ax
   659 00001835 EBCF                <1>         jmp     STP090
   660                              <1> STP150:
   661 00001837 B8FF7F              <1>         mov     ax,7FFFH                ;get biased infinity exponent
   662 0000183A 803F02              <1>         cmp     byte [bx+tag], tag_infin     ;check for infinity
   663 0000183D 7510                <1>         jne     STP180
   664                              <1> STP160:
   665 0000183F 08D4                <1>         or      ah,dl                   ;sign the infinity
   666 00001841 26894508            <1>   es    mov     [di+8],ax            ;store sign and exponent
   667 00001845 26C745060080        <1>   es    mov     word [di+6],8000h         ;mantissa of infinity
   668                              <1> STP175:
   669 0000184B 31C0                <1>         xor     ax,ax
   670 0000184D EBDB                <1>         jmp     STP130                  ;store rest of mantissa
   671                              <1> STP180:
   672 0000184F 6A01                <1>         push    Iexcept                 ;tag is empty, or invalid
   673 00001851 E89D03              <1>         call    exception
   674 00001854 26C74508FFFF        <1>   es    mov     word [di+8],0FFFFh        ;store indefinite
   675 0000185A 26C7450600C0        <1>   es    mov     word [di+6],0C000h        ; **
   676 00001860 EBE9                <1>         jmp     STP175
   677                              <1> 
   678                              <1>         even
   679                              <1> %if BIG
   680                              <1> rndCon:
   681                              <1> ;	ACCUM   <tag_valid, 0, 0, 3FFFh, 0FFFFh, 0FFFFh, 0FFFFh>
   682 00001862 0000                <1> 	db	tag_valid, 0
   683 00001864 0000FF3FFFFFFFFFFF- <1> 	dw	0, 3FFFh, 0FFFFh, 0FFFFh, 0FFFFh
   683 0000186D FF                  <1>
   684                              <1> %else
   685                              <1> rndCon:
   686                              <1> ;	ACCUM   <tag_valid, 0, 0, 3FFFh, 0FFFFh>
   687                              <1> 	db	tag_valid, 0
   688                              <1> 	dw	0, 3FFFh, 0FFFFh
   689                              <1> %endif
   690                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   691                              <1> ;
   692                              <1> ;   FRNDINT             round ST to integer according
   693                              <1> ;                       to rounding control
   694                              <1> ;
   695                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   696                              <1> gFRNDINT:
   697 0000186E 30DB                <1>         xor     bl,bl                   ;get pointer to ST in BX
   698 00001870 E8EBED              <1>         call    regptr                  ; **
   699 00001873 803F01              <1>         cmp     byte [bx+tag], tag_zero      ;test the tag
   700 00001876 7431                <1>         je      RND100
   701 00001878 7732                <1>         ja      RND120
   702                              <1> 
   703                              <1> %if BIG
   704 0000187A B93F00              <1>         mov     cx,63               ;get max exponent
   705                              <1> %else
   706                              <1>         mov     cx,31               ;get max exponent
   707                              <1> %endif
   708 0000187D 2B4F02              <1>         sub     cx,word [bx+expon]       ;form shift count
   709 00001880 7E27                <1>         jle     RND100              ;already an integer
   710                              <1> %if BIG
   711                              <1> %else
   712                              <1>         add     cx,32               ;increase shift count
   713                              <1> %endif
   714 00001882 89DE                <1>         mov     si,bx               ;SI is destination pointer
   715 00001884 E87CFD              <1>         call    vloadsh64           ;integerize & compute guard & sticky
   716 00001887 E82CFD              <1>         call    round_mag           ;round magnitude
   717                              <1> %if BIG
   718 0000188A BF3F00              <1>         mov     di,63               ;get max exponent
   719                              <1> %else
   720                              <1>         mov     di,31               ;get smaller exponent
   721                              <1>         mov     ax,cx               ;shift by 32 bits
   722                              <1>         mov     bx,dx               ; **
   723                              <1> %endif
   724 0000188D 68[B601]            <1>         push    restore_segs
   725 00001890 E9C7EE              <1>         jmp     normalize_and_exit
   726                              <1> 
   727                              <1> 
   728                              <1> 
   729                              <1> ;
   730                              <1> ; exponent is small, return zero
   731                              <1> RND050:
   732 00001893 31C0                <1>         xor     ax,ax                   ;get zero
   733 00001895 C60701              <1>         mov     byte [bx+tag], tag_zero      ;set new tag
   734 00001898 C747020180          <1>         mov     word [bx+expon],exp_of_FPzero    ;set special exponent
   735 0000189D 894704              <1>         mov     [bx+mantis],ax          ;set mantissa
   736 000018A0 894706              <1>         mov     [bx+mantis+2],ax        ; **
   737                              <1> %if BIG
   738 000018A3 894708              <1>         mov     [bx+mantis+4],ax        ;  **
   739 000018A6 89470A              <1>         mov     [bx+mantis+6],ax        ;   **
   740                              <1> %endif
   741                              <1> RND100:
   742 000018A9 E90AE9              <1>         jmp     restore_segs        ;major exit point
   743                              <1> 
   744                              <1> 
   745                              <1> ; tag is infinity or above
   746                              <1> RND120:
   747 000018AC 803F02              <1>         cmp     byte [bx+tag],tag_infin      ;test for infinity
   748 000018AF 74F8                <1>         je      RND100
   749                              <1> 
   750 000018B1 6A01                <1>         push    Iexcept                 ;invalid operation
   751 000018B3 E83B03              <1>         call    exception
   752 000018B6 EBF1                <1>         jmp     RND100
   753                              <1> 
   754                              <1> 
   755                              <1> 
   756                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   757                              <1> ;
   758                              <1> ;   FSQRT           square root of stack top
   759                              <1> ;
   760                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   761                              <1> gFSQRT:
   762 000018B8 30DB                <1>         xor     bl,bl           ;get ST(0) pointer in BX
   763 000018BA E8A1ED              <1>         call    regptr          ; **
   764 000018BD 803F01              <1>         cmp     byte [bx+tag], tag_zero  ;test for unusual tags
   765 000018C0 736A                <1>         jae      SQ100           ;skip if okay
   766                              <1> ; tag is valid
   767 000018C2 807F0100            <1>         cmp     byte [bx+sign],0
   768 000018C6 7573                <1>         jne     SQ110           ;SQRT of neg. is indefinite        
   769                              <1> 
   770 000018C8 8B4702              <1>         mov     ax,word [bx+expon]   ;get exponent of argument
   771 000018CB 8B5704              <1>         mov     dx,[bx+mantis]  ;get high order mantissa
   772 000018CE D1C2                <1>         rol     dx,1            ;rotate mantissa
   773 000018D0 D1F8                <1>         sar     ax,1            ;divide exponent by 2, odd bit to carry
   774 000018D2 D1DA                <1>         rcr     dx,1            ;odd bit to high DX
   775 000018D4 D1DA                <1>         rcr     dx,1            ;normal 1 bit to high DX
   776 000018D6 A32E00              <1>         mov     [Areg+expon],ax   ;Areg is initial guess
   777 000018D9 89163000            <1>         mov     [Areg+mantis],dx  ; **
   778 000018DD 31C0                <1>         xor     ax,ax
   779 000018DF A32C00              <1>         mov     word [Areg],ax ;clear sign and tag (+, valid)
   780 000018E2 A33200              <1>         mov     [Areg+mantis+2],ax
   781                              <1> %if BIG
   782 000018E5 A33400              <1>         mov     [Areg+mantis+4],ax
   783 000018E8 A33600              <1>         mov     [Areg+mantis+6],ax
   784                              <1> %endif
   785                              <1> 
   786 000018EB 891E1600            <1>         mov     word [trptr],bx         ;save ST pointer
   787 000018EF BE2C00              <1>         mov     si,Areg
   788                              <1> %if BIG
   789 000018F2 C6061B0003          <1>         mov     byte [trctr],3           ;iterate 4 times with 64-bit mantissa
   790                              <1> %else
   791                              <1>         mov     byte [trctr],2           ;iterate 3 times with 32-bit mantissa
   792                              <1> %endif
   793                              <1> SQ040:
   794 000018F7 8B3E1600            <1>         mov     di,word [trptr]
   795 000018FB BB3800              <1>         mov     bx,Breg
   796 000018FE E84CF9              <1>         call    do_div          ;arg/guess --> temp
   797                              <1> 
   798 00001901 BF2C00              <1>         mov     di,Areg  ;
   799 00001904 89FB                <1>         mov     bx,di
   800 00001906 E896EA              <1>         call    do_add          ; Areg is new guess * 2
   801                              <1> ; SI points at Areg
   802 00001909 FF4C02              <1>         dec     word [si+expon]      ;divide by 2
   803 0000190C FE0E1B00            <1>         dec     byte [trctr]
   804 00001910 75E5                <1>         jnz     SQ040
   805                              <1> 
   806                              <1> ; last iteration has ST as final destination
   807 00001912 8B3E1600            <1>         mov     di,word [trptr]
   808 00001916 BB3800              <1>         mov     bx,Breg
   809 00001919 E831F9              <1>         call    do_div          ;arg/guess --> temp
   810                              <1> 
   811 0000191C BF2C00              <1>         mov     di,Areg  ;
   812 0000191F 8B1E1600            <1>         mov     bx,word [trptr]         ;ST is final destination
   813 00001923 E879EA              <1>         call    do_add          ; Areg is new guess * 2
   814                              <1> ; SI points at ST
   815 00001926 FF4C02              <1>         dec     word [si+expon]      ;divide by 2
   816                              <1> 
   817                              <1> SQ099:
   818 00001929 E98AE8              <1>         jmp     restore_segs
   819                              <1> 
   820                              <1> SQ100:
   821 0000192C 74FB                <1>         je      SQ099               ;+/- 0.0  -->  +/- 0.0
   822 0000192E 803F02              <1>         cmp     byte [bx+tag], tag_infin ;check for an infinity
   823 00001931 7508                <1>         jne     SQ110
   824 00001933 807F0100            <1>         cmp     byte [bx+sign],0
   825 00001937 7502                <1>         jne     SQ110                   ;-inf --> indefinite
   826 00001939 EBEE                <1>         jmp     SQ099                   ;+inf --> +inf
   827                              <1> SQ110:
   828 0000193B C60706              <1>         mov     byte [bx+tag], tag_invalid ;
   829 0000193E 680102              <1>         push    errSqrt+Iexcept
   830 00001941 E8AD02              <1>         call    exception
   831 00001944 EBE3                <1>         jmp     SQ099
   832                              <1> 
   833                              <1> 
   834                              <1> 
   835                              <1> 
   836                              <1> ;
   837                              <1> ; handle FPREM errors here
   838                              <1> ;
   839                              <1> FR200:      ;divisor is zero or otherwise bad
   840 00001946 6A04                <1>         push    Zexcept
   841 00001948 E8A602              <1>         call    exception
   842                              <1> FR300:      ;dividend is infin, empty, or invalid
   843 0000194B 6A01                <1>         push    Iexcept
   844 0000194D E8A102              <1>         call    exception
   845 00001950 C60406              <1>         mov     byte [si+tag], tag_invalid
   846                              <1> FR085:
   847 00001953 80260300B8          <1>         and     byte [codes], ~(C3+C2+C1+C0) ;clear condition codes
   848 00001958 E95BE8              <1>         jmp     restore_segs
   849                              <1> 
   850                              <1> 
   851                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   852                              <1> ;
   853                              <1> ;   FPREM           remainder of ST / ST(1)
   854                              <1> ;
   855                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   856                              <1> gFPREM:
   857 0000195B 30DB                <1>         xor     bl,bl               ;get ST(0) pointer
   858 0000195D E8FEEC              <1>         call    regptr              ; in BX
   859 00001960 89DE                <1>         mov     si,bx               ;save ST pointer in SI
   860                              <1> 
   861 00001962 B301                <1>         mov     bl, 1               ;get ST(1) pointer
   862 00001964 E8F7EC              <1>         call    regptr              ; in BX
   863 00001967 89DF                <1>         mov     di,bx               ;save ST(1) pointer in DI
   864                              <1> 
   865 00001969 803D01              <1>         cmp     byte [di+tag], tag_zero  ;test tag of divisor
   866 0000196C 73D8                <1>         jae     FR200               ; divisor is bad
   867 0000196E 803C01              <1>         cmp     byte [si+tag], tag_zero  ;test tag of dividend
   868 00001971 77D8                <1>         ja      FR300               ; dividend is funny
   869                              <1> ; both tags are valid
   870 00001973 C6061A0000          <1>         mov     byte [ctr],0               ;zero the divide counter
   871 00001978 8B4C02              <1>         mov     cx,word [si+expon]       ;get exponent of dividend
   872 0000197B 8B4502              <1>         mov     ax,word [di+expon]       ;get exponent of divisor
   873 0000197E 29C1                <1>         sub     cx,ax               ;get difference E.dividend - E.divisor
   874 00001980 7CD1                <1>         jl      FR085               ;dividend exponent is less than divisor
   875 00001982 894402              <1>         mov     word [si+expon],ax       ;dividend exponent is updated
   876                              <1> 
   877 00001985 8B4404              <1>         mov     ax,[si+mantis]      ;get dividend in AX:BX[:BP:SI]
   878 00001988 8B5C06              <1>         mov     bx,[si+mantis+2]
   879                              <1> %if BIG
   880 0000198B 8B6C08              <1>         mov     bp,[si+mantis+4]    ; **
   881 0000198E 56                  <1>         push    si                  ;save SI
   882 0000198F 8B740A              <1>         mov     si,[si+mantis+6]
   883                              <1> %endif
   884 00001992 8B5504              <1>         mov     dx,[di+mantis]      ;get divisor in DX:mem[:mem:mem]
   885 00001995 41                  <1>         inc     cx
   886 00001996 EB0E                <1>         jmp     short FR004         ;go do the compare
   887                              <1> 
   888                              <1> FR003:
   889 00001998 D0261A00            <1>         shl     byte [ctr],1               ;shift the counter
   890                              <1> %if BIG
   891 0000199C D1E6                <1>         shl     si,1                ;left shift of the dividend
   892 0000199E D1D5                <1>         rcl     bp,1                ; **
   893 000019A0 D1D3                <1>         rcl     bx,1                ;
   894                              <1> %else
   895                              <1>         shl     bx,1                ; start of short shift
   896                              <1> %endif
   897 000019A2 D1D0                <1>         rcl     ax,1                ;final shift of dividend
   898 000019A4 7219                <1>         jc      FR005               ;dividend is considered greater if CF=1
   899                              <1> FR004:
   900 000019A6 39D0                <1>         cmp     ax,dx               ;compare dividend to divisor
   901 000019A8 7715                <1>         ja      FR005
   902 000019AA 7222                <1>         jb      FR007
   903 000019AC 3B5D06              <1>         cmp     bx,[di+mantis+2]    ;compare
   904                              <1> %if BIG
   905 000019AF 770E                <1>         ja      FR005
   906 000019B1 721B                <1>         jb      FR007
   907 000019B3 3B6D08              <1>         cmp     bp,[di+mantis+4]    ;compare
   908 000019B6 7707                <1>         ja      FR005
   909 000019B8 7214                <1>         jb      FR007
   910 000019BA 3B750A              <1>         cmp     si,[di+mantis+6]    ;compare
   911                              <1> %endif
   912 000019BD 720F                <1>         jb      FR007
   913                              <1> FR005:
   914                              <1> %if BIG
   915 000019BF 2B750A              <1>         sub     si,[di+mantis+6]    ;subtract
   916 000019C2 1B6D08              <1>         sbb     bp,[di+mantis+4]
   917 000019C5 1B5D06              <1>         sbb     bx,[di+mantis+2]
   918                              <1> %else
   919                              <1>         sub     bx,[di+mantis+2]
   920                              <1> %endif
   921 000019C8 19D0                <1>         sbb     ax,dx               ;finish the subtract
   922 000019CA FE061A00            <1>         inc     byte [ctr]                 ;count the subtraction
   923                              <1> FR007:
   924 000019CE E2C8                <1>         loop    FR003
   925                              <1> 
   926                              <1> %if BIG
   927 000019D0 89F2                <1>         mov     dx,si
   928 000019D2 5E                  <1>         pop     si                  ;restore saved destination pointer
   929                              <1> %endif
   930 000019D3 8A0E1A00            <1>         mov     cl,byte [ctr]              ;get quotient bits
   931                              <1> ;;;        cmp     byte [si+sign],0
   932                              <1> ;;;        je      FR050
   933                              <1> ;;;        neg     cl
   934                              <1> FR050:
   935 000019D7 80E107              <1>         and     cl,7                ;mask to 3 bits
   936 000019DA D0E9                <1>         shr     cl,1                ;1's bit to carry
   937 000019DC D0D5                <1>         rcl     ch,1                ;1's bit in b0 of CH
   938 000019DE D0C9                <1>         ror     cl,1                ;4's bit in b0 of CL
   939 000019E0 D0E9                <1>         shr     cl,1                ;4's bit in carry, 2's bit in position
   940 000019E2 D0D5                <1>         rcl     ch,1                ;1's bit in b1, 4's bit in b0 of CH
   941 000019E4 08CD                <1>         or      ch,cl               ;CH is flag byte
   942 000019E6 80260300B8          <1>         and     byte [codes], ~(C3+C2+C1+C0) ;clear condition codes
   943 000019EB 082E0300            <1>         or      byte [codes],ch            ;set codes as appropriate
   944                              <1> 
   945                              <1> %if BIG
   946 000019EF 89E9                <1>         mov     cx,bp
   947                              <1> %endif
   948 000019F1 8B7C02              <1>         mov     di,word [si+expon]       ;get saved exponent
   949                              <1> 
   950 000019F4 68[B601]            <1>         push    restore_segs
   951 000019F7 E960ED              <1>         jmp     normalize_and_exit
   952                              <1> 
   953                              <1> 
   954                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;
   955                              <1> ;
   956                              <1> ;   moveconsts -- move constants to data segment
   957                              <1> ;
   958                              <1> ;   Enter with:
   959                              <1> ;       ES already points at data segment
   960                              <1> ;       SI points at code segment offset from which to move
   961                              <1> ;       CX contains the WORD count to move
   962                              <1> ;
   963                              <1> ;   Return with:
   964                              <1> ;       ES and DS intact
   965                              <1> ;       AX, DX, CX, SI, DI are trashed
   966                              <1> ;       'trptr' points at first constant in Creg
   967                              <1> ;
   968                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;
   969                              <1> moveconsts:	;	  proc    near
   970 000019FA BFA400              <1>         mov     di,Creg  ;destination offset
   971 000019FD 893E1600            <1>         mov     word [trptr],di        ;set for return
   972                              <1> 
   973 00001A01 8CC8                <1>         mov     ax,cs           ;source will be code segment
   974 00001A03 8CDA                <1>         mov     dx,ds           ;save DS in DX
   975 00001A05 8ED8                <1>         mov     ds,ax           ;set up DS for source DS:SI
   976 00001A07 F3A5                <1>     rep     movsw
   977 00001A09 8EDA                <1>         mov     ds,dx           ;restore DS
   978                              <1> 
   979 00001A0B C3                  <1>         ret
   980                              <1> ;moveconsts  endp
   981                              <1> 
   982                              <1> 
   983                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   984                              <1> ;
   985                              <1> ;   FSTENV   mem         ; store Environment
   986                              <1> ;
   987                              <1> ;       ES:DI is the destination address
   988                              <1> ;		of a 14 byte storage area
   989                              <1> ;
   990                              <1> ;	         ; 001 110       14 bytes
   991                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   992                              <1> ;*** gFSTENV:
   993 00001A0C A10000              <1> 	mov	ax,[Control]	; get the full Control word
   994 00001A0F AB                  <1> 	stosw
   995                              <1> 
   996 00001A10 A10200              <1> 	mov	ax,[Status]	; get status word with no TOS
   997 00001A13 8A3E1000            <1> 	mov	bh,[tos]	; get TOS bits
   998 00001A17 C0E703              <1> 	shl	bh,3		; shift to position
   999 00001A1A 30E7                <1> 	xor	bh,ah
  1000 00001A1C 80E738              <1> 	and	bh,00111000b
  1001 00001A1F 30FC                <1> 	xor	ah,bh		; store the TOS bits
  1002 00001A21 AB                  <1> 	stosw
  1003 00001A22 BBA400              <1> 	mov	bx,fp7+lenAccum		; address FPAC 7+1
  1004                              <1> .1:
  1005 00001A25 83EB0C              <1> 	sub	bx,lenAccum	; start at fp(7)
  1006 00001A28 8A0F                <1> 	mov	cl,[bx+tag]	; get tag word
  1007 00001A2A 80E103              <1> 	and	cl,3		; mask to 2 bits (insurance)
  1008 00001A2D D1E0                <1> 	shl	ax,1
  1009 00001A2F D1E0                <1> 	shl	ax,1		; make room in AX
  1010 00001A31 08C8                <1> 	or	al,cl
  1011 00001A33 83FB44              <1> 	cmp	bx,fp0		; done with all of them
  1012 00001A36 75ED                <1> 	jne	.1
  1013 00001A38 AB                  <1> 	stosw			; store the composed tag word
  1014                              <1> 
  1015 00001A39 BE0400              <1> 	mov	si,save_ip	; DS:SI points at words to save
  1016 00001A3C A5                  <1> 	movsw		; store IP
  1017 00001A3D A5                  <1> 	movsw		; store CS
  1018 00001A3E A5                  <1> 	movsw		; store data offset
  1019 00001A3F A5                  <1> 	movsw		; store data SEG
  1020                              <1> 
  1021 00001A40 E973E7              <1>         jmp     restore_segs
  1022                              <1> 
  1023                              <1> 
  1024                              <1> 
  1025                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1026                              <1> ;
  1027                              <1> ;   FLDENV   mem         ; store Environment
  1028                              <1> ;
  1029                              <1> ;       ES:DI is the destination address
  1030                              <1> ;		of a 14 byte storage area
  1031                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1032                              <1> ;*** gFLDENV:         ; 001 100       14 bytes
  1033 00001A43 E970E7              <1>         jmp     restore_segs
  1034                              <1> 
  1035                              <1>      
  1036                              <1> 	
  1037                              <1> ; end em187h.asm
   525                                  
   526                                  
   527                                  	even
   528                                  %if BIG
   529                                  patanCon:
   530                                  ;	ACCUM   <tag_valid, 0, -2, 08930H, 0a2f4H, 0f66aH, 0b18aH>	; T1=tan(15deg.)
   531 00001A46 0000                    	db	tag_valid, 0
   532 00001A48 FEFF3089F4A26AF68A-     	dw	-2, 08930H, 0a2f4H, 0f66aH, 0b18aH	; T1=tan(15deg.)
   532 00001A51 B1                 
   533                                  ;	ACCUM   <tag_valid, 0, -1, 0860aH, 091c1H, 06b9bH, 02c23H>	; pi/6
   534 00001A52 0000                    	db	tag_valid, 0
   535 00001A54 FFFF0A86C1919B6B23-     	dw	-1, 0860aH, 091c1H, 06b9bH, 02c23H	; pi/6
   535 00001A5D 2C                 
   536                                  ;	ACCUM   <tag_valid, 0,  0, 0ddb3H, 0d742H, 0c265H, 0539eH>	; sqrt(3)
   537 00001A5E 0000                    	db	tag_valid, 0
   538 00001A60 0000B3DD42D765C29E-     	dw	 0, 0ddb3H, 0d742H, 0c265H, 0539eH	; sqrt(3)
   538 00001A69 53                 
   539                                  ;	ACCUM   <tag_valid, 1,  0, 08000H, 0H, 0H, 0H>			; -1
   540 00001A6A 0001                    	db	tag_valid, 1
   541 00001A6C 000000800000000000-     	dw	 0, 08000H, 0H, 0H, 0H			; -1
   541 00001A75 00                 
   542                                  ;	ACCUM	<tag_valid, 0, -5, 08d3dH, 0cb08H, 0d3dcH, 0b08dH>	; c14
   543 00001A76 0000                    	db	tag_valid, 0
   544 00001A78 FBFF3D8D08CBDCD38D-     	dw	-5, 08d3dH, 0cb08H, 0d3dcH, 0b08dH	; c14
   544 00001A81 B0                 
   545                                  ;	ACCUM	<tag_valid, 0, -5, 097b4H, 025edH, 0097bH, 0425fH>	; c13
   546 00001A82 0000                    	db	tag_valid, 0
   547 00001A84 FBFFB497ED257B095F-     	dw	-5, 097b4H, 025edH, 0097bH, 0425fH	; c13
   547 00001A8D 42                 
   548                                  ;	ACCUM	<tag_valid, 0, -5, 0a3d7H, 00a3dH, 070a3H, 0d70aH>	; c12
   549 00001A8E 0000                    	db	tag_valid, 0
   550 00001A90 FBFFD7A33D0AA3700A-     	dw	-5, 0a3d7H, 00a3dH, 070a3H, 0d70aH	; c12
   550 00001A99 D7                 
   551                                  ;	ACCUM	<tag_valid, 0, -5, 0b216H, 042c8H, 0590bH, 02164H>	; c11
   552 00001A9A 0000                    	db	tag_valid, 0
   553 00001A9C FBFF16B2C8420B5964-     	dw	-5, 0b216H, 042c8H, 0590bH, 02164H	; c11
   553 00001AA5 21                 
   554                                  ;	ACCUM	<tag_valid, 0, -5, 0c30cH, 030c3H, 00c30H, 0c30cH>	; c10
   555 00001AA6 0000                    	db	tag_valid, 0
   556 00001AA8 FBFF0CC3C330300C0C-     	dw	-5, 0c30cH, 030c3H, 00c30H, 0c30cH	; c10
   556 00001AB1 C3                 
   557                                  ;	ACCUM	<tag_valid, 0, -5, 0d794H, 035e5H, 00d79H, 0435eH>	; c09
   558 00001AB2 0000                    	db	tag_valid, 0
   559 00001AB4 FBFF94D7E535790D5E-     	dw	-5, 0d794H, 035e5H, 00d79H, 0435eH	; c09
   559 00001ABD 43                 
   560                                  ;	ACCUM	<tag_valid, 0, -5, 0f0f0H, 0f0f0H, 0f0f0H, 0f0f1H>	; c08
   561 00001ABE 0000                    	db	tag_valid, 0
   562 00001AC0 FBFFF0F0F0F0F0F0F1-     	dw	-5, 0f0f0H, 0f0f0H, 0f0f0H, 0f0f1H	; c08
   562 00001AC9 F0                 
   563                                  ;	ACCUM	<tag_valid, 0, -4, 08888H, 08888H, 08888H, 08889H>	; c07
   564 00001ACA 0000                    	db	tag_valid, 0
   565 00001ACC FCFF88888888888889-     	dw	-4, 08888H, 08888H, 08888H, 08889H	; c07
   565 00001AD5 88                 
   566                                  ;	ACCUM	<tag_valid, 0, -4, 09d89H, 0d89dH, 089d8H, 09d8aH>	; c06
   567 00001AD6 0000                    	db	tag_valid, 0
   568 00001AD8 FCFF899D9DD8D8898A-     	dw	-4, 09d89H, 0d89dH, 089d8H, 09d8aH	; c06
   568 00001AE1 9D                 
   569                                  ;	ACCUM	<tag_valid, 0, -4, 0ba2eH, 08ba2H, 0e8baH, 02e8cH>	; c05
   570 00001AE2 0000                    	db	tag_valid, 0
   571 00001AE4 FCFF2EBAA28BBAE88C-     	dw	-4, 0ba2eH, 08ba2H, 0e8baH, 02e8cH	; c05
   571 00001AED 2E                 
   572                                  ;	ACCUM	<tag_valid, 0, -4, 0e38eH, 038e3H, 08e38H, 0e38eH>	; c04
   573 00001AEE 0000                    	db	tag_valid, 0
   574 00001AF0 FCFF8EE3E338388E8E-     	dw	-4, 0e38eH, 038e3H, 08e38H, 0e38eH	; c04
   574 00001AF9 E3                 
   575                                  ;	ACCUM	<tag_valid, 0, -3, 09249H, 02492H, 04924H, 09249H>	; c03
   576 00001AFA 0000                    	db	tag_valid, 0
   577 00001AFC FDFF49929224244949-     	dw	-3, 09249H, 02492H, 04924H, 09249H	; c03
   577 00001B05 92                 
   578                                  ;	ACCUM	<tag_valid, 0, -3, 0ccccH, 0ccccH, 0ccccH, 0cccdH>	; c02
   579 00001B06 0000                    	db	tag_valid, 0
   580 00001B08 FDFFCCCCCCCCCCCCCD-     	dw	-3, 0ccccH, 0ccccH, 0ccccH, 0cccdH	; c02
   580 00001B11 CC                 
   581                                  ;	ACCUM	<tag_valid, 0, -2, 0aaaaH, 0aaaaH, 0aaaaH, 0aaabH>	; c01
   582 00001B12 0000                    	db	tag_valid, 0
   583 00001B14 FEFFAAAAAAAAAAAAAB-     	dw	-2, 0aaaaH, 0aaaaH, 0aaaaH, 0aaabH	; c01
   583 00001B1D AA                 
   584                                  ;	ACCUM	<tag_valid, 0,  0, 08000H, 0H, 0H, 0H>			; c00
   585 00001B1E 0000                    	db	tag_valid, 0
   586 00001B20 000000800000000000-     	dw	 0, 08000H, 0H, 0H, 0H			; c00
   586 00001B29 00                 
   587                                  %else
   588                                  patanCon:
   589                                  ;       ACCUM   <tag_valid, 0, -2, 08930H, 0a2f5H>	; T1=tan(15deg.)
   590                                  	db	tag_valid, 0
   591                                  	dw	-2, 08930H, 0a2f5H	; T1=tan(15deg.)
   592                                  ;	ACCUM   <tag_valid, 0, -1, 0860aH, 091c1H>	; pi/6
   593                                  	db	tag_valid, 0
   594                                  	dw	-1, 0860aH, 091c1H	; pi/6
   595                                  ;	ACCUM   <tag_valid, 0,  0, 0ddb3H, 0d743H>	; sqrt(3)
   596                                  	db	tag_valid, 0
   597                                  	dw	 0, 0ddb3H, 0d743H	; sqrt(3)
   598                                  ;	ACCUM   <tag_valid, 1,  0, 08000H, 00000H>			; -1
   599                                  	db	tag_valid, 1
   600                                  	dw	 0, 08000H, 00000H			; -1
   601                                  ;;;	ACCUM	<tag_valid, 0, -5, 0f0f0H, 0f0f1H>	; c08
   602                                  ;;;	ACCUM	<tag_valid, 0, -4, 08888H, 08889H>	; c07
   603                                  ;	ACCUM	<tag_valid, 0, -4, 09d89H, 0d89eH>	; c06
   604                                  	db	tag_valid, 0
   605                                  	dw	-4, 09d89H, 0d89eH	; c06
   606                                  ;	ACCUM	<tag_valid, 0, -4, 0ba2eH, 08ba3H>	; c05
   607                                  	db	tag_valid, 0
   608                                  	dw	-4, 0ba2eH, 08ba3H	; c05
   609                                  ;	ACCUM	<tag_valid, 0, -4, 0e38eH, 038e4H>	; c04
   610                                  	db	tag_valid, 0
   611                                  	dw	-4, 0e38eH, 038e4H	; c04
   612                                  ;	ACCUM	<tag_valid, 0, -3, 09249H, 02492H>	; c03
   613                                  	db	tag_valid, 0
   614                                  	dw	-3, 09249H, 02492H	; c03
   615                                  ;	ACCUM	<tag_valid, 0, -3, 0ccccH, 0cccdH>	; c02
   616                                  	db	tag_valid, 0
   617                                  	dw	-3, 0ccccH, 0cccdH	; c02
   618                                  ;	ACCUM	<tag_valid, 0, -2, 0aaaaH, 0aaabH>	; c01
   619                                  	db	tag_valid, 0
   620                                  	dw	-2, 0aaaaH, 0aaabH	; c01
   621                                  ;	ACCUM	<tag_valid, 0,  0, 08000H, 00000H>	; c00
   622                                  	db	tag_valid, 0
   623                                  	dw	 0, 08000H, 00000H	; c00
   624                                  %endif
   625                                  patanConLen 	equ	$-patanCon
   626                                  %if (patanConLen > lenCreg)
   627                                  	%error  not enough constant space in Creg
   628                                  %endif
   629                                  
   630                                  
   631                                  
   632                                  ; ST (X) has problems -- is zero or inf.
   633                                  ;
   634                                  PAT200:
   635                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   636                                  ;
   637                                  ;   FPATAN          8087 partial arctangent
   638                                  ;
   639                                  ;	Compute arctangent (Y / X), where Y is in ST(1) and X is in ST(0).
   640                                  ;
   641                                  ;	Assume  0 <= Y < X < inf.
   642                                  ;
   643                                  ;
   644                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   645                                  gFPATAN:
   646 00001B2A B97200                          mov     cx,patanConLen/2        ;number of words to move
   647                                  ;;;        mov     si,OFFSET patanCon      ;start of constant list
   648 00001B2D BE[461A]                        mov     si,patanCon      ;start of constant list
   649 00001B30 E8C7FE                          call    moveconsts              ;address constants from DS
   650                                  
   651 00001B33 30DB                    	xor	bl,bl			;get pointer to ST
   652 00001B35 E826EB                  	call	regptr			;BX points at X arg
   653 00001B38 89DE                    	mov	si,bx			;SI is divisor
   654 00001B3A B301                    	mov	bl,1			;Y is ST(1)
   655 00001B3C E81FEB                  	call	regptr
   656 00001B3F 89DF                    	mov	di,bx			;DI -> Y, SI -> X
   657 00001B41 E809F7                  	call	do_div			;ST(1) -> Y/X
   658 00001B44 89F3                    	mov	bx,si			;propagate pointer to X arg
   659 00001B46 803C01                  	cmp	byte [si+tag],tag_zero
   660                                  ;	jae	PAT90
   661 00001B49 7203                    	jb	PAT01
   662 00001B4B E98800                  	jmp	PAT90
   663                                  PAT01:
   664                                  ; SI and BX point at X input
   665                                  ;;;	mov	di,offset Creg		;DI is tan(15)
   666 00001B4E BFA400                  	mov	di,Creg			;DI is tan(15)
   667 00001B51 E8CFF7                  	call	do_compare		; compare [DI] : [SI]
   668 00001B54 31F6                    	xor	si,si			;flag Y=0
   669 00001B56 9E                      	sahf				;set flags
   670 00001B57 732C                    	jae	PAT010
   671 00001B59 53                      	push	bx			;save ST(1) pointer
   672 00001B5A 89DE                    	mov	si,bx			;SI -> X
   673                                  ;;;	mov	di,offset Creg + 2 * lenAccum
   674 00001B5C BFBC00                  	mov	di, Creg + 2 * lenAccum
   675                                  ;;;	mov	bx,offset Areg		;destination
   676 00001B5F BB2C00                  	mov	bx, Areg		;destination
   677 00001B62 56                      	push	si
   678 00001B63 57                      	push	di			;save argument pointers
   679 00001B64 E838E8                  	call	do_add			;SI -> X+S3
   680 00001B67 5F                      	pop	di
   681 00001B68 5E                      	pop	si
   682                                  ;;;	mov	bx,offset Breg
   683 00001B69 BB3800                  	mov	bx, Breg
   684 00001B6C E801F5                  	call	do_mul			;SI -> X*S3
   685                                  ;;;	mov	di,offset Creg + 3 * lenAccum	; -1
   686 00001B6F BFC800                  	mov	di, Creg + 3 * lenAccum	; -1
   687 00001B72 89F3                    	mov	bx,si			;Breg is dest
   688 00001B74 E828E8                  	call	do_add
   689 00001B77 89F7                    	mov	di,si			;numerator
   690                                  ;;;	mov	si,offset Areg		;denom.
   691 00001B79 BE2C00                  	mov	si, Areg		;denom.
   692 00001B7C 5B                      	pop	bx			;restore ST(1) pointer
   693 00001B7D E8CDF6                  	call	do_div
   694 00001B80 89F3                    	mov	bx,si
   695                                  ;;;	mov	si,offset Creg + lenAccum	;Y=PI/6
   696 00001B82 BEB000                  	mov	si, Creg + lenAccum	;Y=PI/6
   697                                  PAT010:				; BX is ST(1) pointer
   698 00001B85 89361800                	mov	[trptr2],si		;save pointer to Y param (0 or address)
   699 00001B89 53                      	push	bx			;save ST(1) pointer
   700 00001B8A 89DE                    	mov	si,bx			;set to form X*X
   701 00001B8C 89DF                    	mov	di,bx
   702                                  ;;;	mov	bx,offset Breg		;XX in Breg
   703 00001B8E BB3800                  	mov	bx, Breg		;XX in Breg
   704 00001B91 E8DCF4                  	call	do_mul			;
   705                                  
   706                                  ;;;	mov	si,offset Creg + 4 * lenAccum	;C14/C06 pointer
   707 00001B94 BED400                  	mov	si, Creg + 4 * lenAccum	;C14/C06 pointer
   708 00001B97 89361600                	mov	[trptr],si
   709                                  %if BIG
   710 00001B9B C6061B000E              	mov	byte [trctr],14
   711                                  %else
   712                                  	mov	byte [trctr],6
   713                                  %endif
   714                                  pat020:
   715                                  ;;;	mov	bx,offset Areg		;S in SI
   716 00001BA0 BB2C00                  	mov	bx, Areg		;S in SI
   717                                  ;;;	mov	di,offset Breg		;XX
   718 00001BA3 BF3800                  	mov	di, Breg		;XX
   719 00001BA6 E8C7F4                  	call	do_mul			;SI points at Areg
   720 00001BA9 89F3                    	mov	bx,si
   721 00001BAB 8B3E1600                	mov	di,[trptr]
   722 00001BAF 83C70C                  	add	di,lenAccum
   723 00001BB2 893E1600                	mov	[trptr],di
   724 00001BB6 80740101                	xor	byte [si+sign],1		;change sign of XX*S
   725 00001BBA E8E2E7                  	call	do_add			;SI points at S (Areg)
   726 00001BBD FE0E1B00                	dec	byte [trctr]
   727 00001BC1 75DD                    	jnz	pat020
   728                                  
   729 00001BC3 5B                      	pop	bx			;restore ST(1) pointer
   730 00001BC4 89DF                    	mov	di,bx
   731 00001BC6 E8A7F4                  	call	do_mul
   732 00001BC9 89F3                    	mov	bx,si
   733 00001BCB 8B3E1800                	mov	di,[trptr2]		;get possible Y
   734 00001BCF 09FF                    	or	di,di
   735 00001BD1 7403                    	jz	PAT90
   736 00001BD3 E8C9E7                  	call	do_add			;ST(1) = Y + X*S
   737                                  PAT90:				; BX contains pointer to result
   738 00001BD6 E9C7E5                  	jmp	pop_the_tos		;clear input X from stack top
   739                                  
   740                                  
   741                                  
   742                                  
   743                                  
   744                                  
   745                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   746                                  ; get FPEM_segment -- get data segment pointer to AX and DS
   747                                  ;
   748                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   749                                  ;;;	assume	ds:nothing
   750                                  	global  get_data_segment
   751                                  get_data_segment:	;	proc	near
   752 00001BD9 6A40                    	push	bios_data_seg	; get bios data area pointer
   753 00001BDB 1F                      	pop	ds
   754                                  .out0:
   755 00001BDC A1F000                  	mov	ax,word [FPEM_segment]	; get emulator segment
   756 00001BDF 09C0                    	or	ax,ax		; Allocated yet?
   757 00001BE1 7403                    	jz	.allocate
   758                                  .done:
   759 00001BE3 8ED8                    	mov	ds,ax
   760 00001BE5 C3                      	ret
   761                                  
   762                                  ; Allocate space for the Floating Point Emulator
   763                                  .allocate:
   764                                  %if FPEM_USE_EBDA
   765                                  	mov     ax,[EBDA_paragraph]
   766                                          sub     ax,word EM187_DATA_PARAS
   767                                  	mov     [EBDA_paragraph],ax
   768                                  	mov     [FPEM_segment],ax
   769                                  	shr     ax,6
   770                                  	mov     [memory_size],ax
   771                                  	jmp	.out0
   772                                  %else
   773 00001BE6 B84000                          mov     ax,bios_data_seg
   774 00001BE9 83E819                          sub     ax,word EM187_DATA_PARAS
   775 00001BEC A3F000                  	mov     [FPEM_segment],ax
   776 00001BEF EBF2                    	jmp	.done
   777                                  %endif
   778                                  ;get_data_segment	endp
   779                                  
   780                                  
   781                                  ;;;     assume  ds:EM187_DATA
   782                                  
   783                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   784                                  ;
   785                                  ;   exception -- called from anywhere to signal setting
   786                                  ;               of exception flags.  Test for unmasked exceptions
   787                                  ;               should occur here.
   788                                  ;
   789                                  ;   Calling sequence:
   790                                  ;
   791                                  ;       push    FLAGBITS
   792                                  ;       call    exception
   793                                  ;
   794                                  ;
   795                                  ;   Returns with stack already popped.
   796                                  ;
   797                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   798                                  exception:		;    proc    near
   799 00001BF1 55                              push    bp          ;create standard stack frame
   800 00001BF2 89E5                            mov     bp,sp
   801                                  
   802 00001BF4 50                              push    ax          ;save AX
   803 00001BF5 1E                              push    ds          ;save DS
   804                                  ;;;        mov     ax,seg EM187_DATA   ;get data segment
   805 00001BF6 E8E0FF                  	call	get_data_segment	; to AX and DS
   806                                  ;;;        mov     ds,ax       ;set up DS
   807                                  
   808 00001BF9 8B4604                          mov     ax,[bp+4]   ;get bits to AX
   809 00001BFC 08060200                        or      [flags],al    ;combine to flag word
   810                                  
   811                                  ;;;;;;;;;;;  JMP  EXC010
   812                                  
   813 00001C00 84061100                        test    al,[enables]  ;test for unmasked exceptions
   814 00001C04 7506                            jnz     EXC010      ;there are unmasked exceptions
   815                                  EXC005:
   816 00001C06 1F                              pop     ds          ;restore DS
   817 00001C07 58                              pop     ax          ;restore AX
   818 00001C08 C9                              leave               ;done
   819 00001C09 C20200                          ret     2           ;return, popping the stack
   820                                  
   821                                  
   822                                  ;   handle simple setting of unmasked error flags
   823                                  EXC010:
   824 00001C0C 08E4                            or      ah,ah       ;test for specific hi-bits
   825 00001C0E 7510                            jnz     EXC020      ;specific error flagged
   826                                  
   827 00001C10 D0C0                            rol     al,1
   828 00001C12 D0C0                            rol     al,1        ;discard hi-2 bits
   829 00001C14 B407                            mov     ah,7        ;max error code + 1 to AH
   830                                  EXC011:
   831 00001C16 FECC                            dec     ah          ;count down
   832 00001C18 D0E0                            shl     al,1        ;move bit to carry
   833 00001C1A 73FA                            jnc     EXC011      ;
   834                                  
   835 00001C1C 88E0                            mov     al,ah       ;error code to AL
   836 00001C1E EB08                            jmp     EXC030      ;go call signal routine
   837                                  
   838                                  EXC020:     ;specific high error flag
   839 00001C20 B006                            mov     al,6        ;min error code -1 to AL
   840                                  EXC021:
   841 00001C22 FEC0                            inc     al
   842 00001C24 D0EC                            shr     ah,1        ;flag bit to carry
   843 00001C26 73FA                            jnc     EXC021
   844                                  EXC030:
   845 00001C28 E80200                          call    _FPSIGNAL   ;signal error
   846 00001C2B EBD9                            jmp     EXC005      ;say nothing for now
   847                                  
   848                                  ;;;exception   endp
   849                                  
   850                                  %if ABSLOAD
   851                                  %include  "em187i.asm"
   852                              <1> ; em187i.asm -- signal module
   853                              <1> ;
   854                              <1> ;  Enter with error number in AL
   855                              <1> ;
   856                              <1> _FPSIGNAL:	;	proc	near
   857 00001C2D 53                  <1> 	push	bx
   858                              <1> ;;;	mov	bx,offset err0
   859 00001C2E BB[4A1C]            <1> 	mov	bx, err0
   860 00001C31 E8CD00              <1> 	call	strout
   861 00001C34 88C3                <1> 	mov	bl,al
   862 00001C36 30FF                <1> 	xor	bh,bh
   863 00001C38 D1E3                <1> 	shl	bx,1
   864 00001C3A 2E8B9F[E51C]        <1>   cs	mov	bx,word [FPUerrtab+bx]
   865 00001C3F E8BF00              <1> 	call	strout
   866                              <1> ;;;	mov	bx,offset errNL
   867 00001C42 BB[E21C]            <1> 	mov	bx, errNL
   868 00001C45 E8B900              <1> 	call	strout
   869 00001C48 5B                  <1> 	pop	bx
   870 00001C49 C3                  <1> 	ret
   871                              <1> ;_FPSIGNAL	endp
   872                              <1> 
   873                              <1> ;define the exception bits
   874                              <1> ; Iexcept     equ     1       ;invalid operation
   875                              <1> ; Dexcept     equ     2       ;denormalized operand
   876                              <1> ; Zexcept     equ     4       ;zero divide
   877                              <1> ; Oexcept     equ     8       ;overflow
   878                              <1> ; Uexcept     equ    10h      ;underflow
   879                              <1> ; Pexcept     equ    20h      ;precision
   880                              <1> ; 
   881                              <1> ; Sflag       equ    40h      ;stack flag     (new with 80187)
   882                              <1> ; Estatus     equ    80h      ;error summary status
   883                              <1> 
   884                              <1> ;define the high order error codes
   885                              <1> ; errUnemulated   equ     0100h   ;unemulated operation
   886                              <1> ; errSqrt         equ     0200h   ;error in SQRT
   887                              <1> ;unassigned
   888                              <1> ; errStkOverflow  equ     0800h   ;
   889                              <1> ; errStkUnderflow equ     1000h   ;
   890                              <1> 
   891 00001C4A 0D0A46505520657272- <1> err0	db	CR,LF,"FPU error:  ",0
   891 00001C53 6F723A202000        <1>
   892                              <1> 
   893 00001C59 496E76616C6964204F- <1> err1	db	"Invalid Operation",0
   893 00001C62 7065726174696F6E00  <1>
   894 00001C6B 44656E6F726D616C00  <1> err2	db	"Denormal",0
   895 00001C74 5A65726F2044697669- <1> err3	db	"Zero Divide",0
   895 00001C7D 646500              <1>
   896 00001C80 4F766572666C6F7700  <1> err4	db	"Overflow",0
   897 00001C89 556E646572666C6F77- <1> err5	db	"Underflow",0
   897 00001C92 00                  <1>
   898 00001C93 507265636973696F6E- <1> err6	db	"Precision",0
   898 00001C9C 00                  <1>
   899                              <1> 
   900 00001C9D 556E656D756C617465- <1> err7	db	"Unemulated Instruction",0
   900 00001CA6 6420496E7374727563- <1>
   900 00001CAF 74696F6E00          <1>
   901 00001CB4 53515254206572726F- <1> err8	db	"SQRT error",0
   901 00001CBD 7200                <1>
   902 00001CBF 00                  <1> err9	db	0
   903 00001CC0 537461636B204F7665- <1> errA	db	"Stack Overflow",0
   903 00001CC9 72666C6F7700        <1>
   904 00001CCF 537461636B20556E64- <1> errB	db	"Stack Underflow",0
   904 00001CD8 6572666C6F7700      <1>
   905 00001CDF 00                  <1> errC	db	0
   906 00001CE0 00                  <1> errD	db	0
   907 00001CE1 00                  <1> errE	db	0
   908                              <1> 
   909 00001CE2 0D0A00              <1> errNL	db	CR,LF,0
   910                              <1> 
   911                              <1> FPUerrtab:
   912 00001CE5 [591C][6B1C][741C]- <1> 	dw	err1,err2,err3,err4
   912 00001CEB [801C]              <1>
   913 00001CED [891C][931C][9D1C]- <1> 	dw	err5,err6,err7,err8
   913 00001CF3 [B41C]              <1>
   914 00001CF5 [BF1C][C01C][CF1C]- <1> 	dw	err9,errA,errB,errC
   914 00001CFB [DF1C]              <1>
   915 00001CFD [E01C][E11C]        <1> 	dw	errD,errE
   916                              <1> 
   917                              <1> ; output the string pointed to by BX
   918                              <1> ;
   919                              <1> strout:		;	proc	near
   920 00001D01 50                  <1> 	push	ax
   921                              <1> strout1:
   922 00001D02 2E8A07              <1>   cs	mov	al,byte [bx]
   923 00001D05 08C0                <1> 	or	al,al
   924 00001D07 7406                <1> 	jz	strout9
   925 00001D09 E80500              <1> 	call	charout
   926 00001D0C 43                  <1> 	inc	bx
   927 00001D0D EBF3                <1> 	jmp	strout1
   928                              <1> strout9:
   929 00001D0F 58                  <1> 	pop	ax
   930 00001D10 C3                  <1> 	ret
   931                              <1> ;strout	endp
   932                              <1> ; output the character in AL
   933                              <1> ;
   934                              <1> charout:	;	proc	near
   935 00001D11 50                  <1> 	push	ax
   936 00001D12 53                  <1> 	push	bx
   937                              <1> 
   938 00001D13 BB0700              <1> 	mov	bx,0007h
   939 00001D16 B40E                <1> 	mov	ah,0Eh
   940 00001D18 CD10                <1> 	int	10h
   941                              <1> 
   942 00001D1A 5B                  <1> 	pop	bx
   943 00001D1B 58                  <1> 	pop	ax
   944 00001D1C C3                  <1> 	ret
   945                              <1> ;charout	endp
   946                              <1> 
   947                              <1> ; end em187i.asm
   852                                  %endif
   853                                  
   854                                  %ifdef DEBUG
   855                                  trace       dd      200 dup (0)
   856                                  tracee      label   dword
   857                                  %endif
   858                                  
   859                                  ; number of paragraphs needed by the DATA area
   860 00001D1D 19                      	db	EM187_DATA_PARAS	; easy to see in the listing file
   861                                  
   862                                  ;;;_TEXT   ENDS
   863                                  ;;;        END
   863          ------------------       info: assembly required 1+3+2 passes

