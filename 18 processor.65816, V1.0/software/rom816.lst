ca65 V2.19 - Git 128b15a71
Main file   : rom816.asm
Current file: rom816.asm

000000r 1               .P816
000000r 1               ;__ROM816__________________________________________________________________________________________
000000r 1               ;
000000r 1               ;	ROM MONITOR FOR THE RBC 65c816N SBC
000000r 1               ;
000000r 1               ;	WRITTEN BY: DAN WERNER -- 9/8/2017
000000r 1               ;
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ;
000000r 1               ; DATA CONSTANTS
000000r 1               ;__________________________________________________________________________________________________
000000r 1               
000000r 1               ;        CHIP    65816           ; SET CHIP
000000r 1               ;        LONGA   OFF             ; ASSUME EMULATION MODE
000000r 1               ;        LONGI   OFF             ;
000000r 1               ;        PW      128
000000r 1               ;        PL      60
000000r 1               ;        INCLIST ON
000000r 1               
000000r 1                       .SEGMENT "ROM"
000000r 1               
000000r 1               IO_AREA         = $DF00
000000r 1               ;__________________________________________________________________________________________________
000000r 1               ; $8000-$8007 UART 16C550
000000r 1               ;__________________________________________________________________________________________________
000000r 1               UART0           = IO_AREA+$58   ;   DATA IN/OUT
000000r 1               UART1           = IO_AREA+$59   ;   CHECK RX
000000r 1               UART2           = IO_AREA+$5A   ;   INTERRUPTS
000000r 1               UART3           = IO_AREA+$5B   ;   LINE CONTROL
000000r 1               UART4           = IO_AREA+$5C   ;   MODEM CONTROL
000000r 1               UART5           = IO_AREA+$5D   ;   LINE STATUS
000000r 1               UART6           = IO_AREA+$5E   ;   MODEM STATUS
000000r 1               UART7           = IO_AREA+$5F   ;   SCRATCH REG.
000000r 1               
000000r 1               STACK           = $7FFF         ;   POINTER TO TOP OF STACK
000000r 1               ;
000000r 1               KEYBUFF         = $0200         ; 256 BYTE KEYBOARD BUFFER
000000r 1               ; NATIVE VECTORS
000000r 1               ICOPVECTOR      = $0300         ;COP handler indirect vector...
000000r 1               IBRKVECTOR      = $0302         ;BRK handler indirect vector...
000000r 1               IABTVECTOR      = $0304         ;ABT handler indirect vector...
000000r 1               INMIVECTOR      = $0306         ;NMI handler indirect vector...
000000r 1               IIRQVECTOR      = $0308         ;IRQ handler indirect vector...
000000r 1               ; 6502 Emulation Vectors
000000r 1               IECOPVECTOR     = $030A         ;ECOP handler indirect vector...
000000r 1               IEABTVECTOR     = $030C         ;EABT handler indirect vector...
000000r 1               IENMIVECTOR     = $030E         ;ENMI handler indirect vector...
000000r 1               IEINTVECTOR     = $0310         ;EINT handler indirect vector...
000000r 1               ConsoleDevice   = $0341         ; Current Console Device
000000r 1               ; $00 On-Board Serial
000000r 1               
000000r 1               TRUE            = 1
000000r 1               FALSE           = 0
000000r 1               
000000r 1                       .INCLUDE "MACROS.ASM"
000000r 2               ;___________________________________________________________________________________________________
000000r 2               ;
000000r 2               ;	USEFUL 65186 MACROS
000000r 2               ;__________________________________________________________________________________________________
000000r 2               
000000r 2               .macro       STORECONTEXT             ; Store Complete Context at the beginning of a Sub
000000r 2                       PHX
000000r 2                       phy
000000r 2                       pha
000000r 2                       php
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       RESTORECONTEXT                 ; Restore Complete Context at the end of a Sub
000000r 2                       plp
000000r 2                       pla
000000r 2                       ply
000000r 2                       plx
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       INDEX16                         ; Set 16bit Index Registers
000000r 2               		REP #$10 		; 16 bit Index registers
000000r 2               		.I16
000000r 2               .endmacro
000000r 2               .macro       INDEX8                          ; Set 8bit Index Registers
000000r 2               		SEP #$10 		; 8 bit Index registers
000000r 2               		.I8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR16                  ; Set 16bit Index Registers
000000r 2               		REP #$20 		; 16 bit Index registers
000000r 2               		.A16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATOR8                   ; Set 8bit Index Registers
000000r 2               		SEP #$20 		; 8 bit Index registers
000000r 2               		.A8
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX16             ; Set 16bit Index Registers
000000r 2               		REP #$30 		; 16 bit Index registers
000000r 2               		.A16
000000r 2                               .I16
000000r 2               .endmacro
000000r 2               
000000r 2               .macro       ACCUMULATORINDEX8              ; Set 8bit Index Registers
000000r 2               		SEP #$30 		; 8 bit Index registers
000000r 2               		.A8
000000r 2                               .I8
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 2               
000000r 2               .macro    cr                      ; Restore Complete Context at the end of a Sub
000000r 2                       SEP #$20 		; 8 bit accum
000000r 2               		.A8
000000r 2               .endmacro
000000r 2               
000000r 2               ;
000000r 2               
000000r 1               
000000r 1                       .ORG    $E000
00E000  1               ;__COLD_START___________________________________________________
00E000  1               ;
00E000  1               ; PERFORM SYSTEM COLD INIT
00E000  1               ;
00E000  1               ;_______________________________________________________________
00E000  1               COLD_START:
00E000  1  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00E001  1  18                   CLC                     ;
00E002  1  FB                   XCE                     ; SET NATIVE MODE
00E003  1  C2 30                ACCUMULATORINDEX16
00E005  1  A9 FF 7F             LDA     #STACK          ; get the stack address
00E008  1  1B                   TCS                     ; and set the stack to it
00E009  1  E2 30                ACCUMULATORINDEX8
00E00B  1  20 54 E0             JSR     CONSOLE_INIT    ; Init UART
00E00E  1               
00E00E  1               ; Announce that system is alive
00E00E  1               
00E00E  1  20 53 E0             JSR     BATEST          ; Perform Basic Assurance Test
00E011  1               
00E011  1  C2 20                ACCUMULATOR16
00E013  1  A9 51 E0             LDA     #INTRETURN      ;
00E016  1  8D 00 03             STA     ICOPVECTOR
00E019  1  8D 02 03             STA     IBRKVECTOR
00E01C  1  8D 04 03             STA     IABTVECTOR
00E01F  1  8D 06 03             STA     INMIVECTOR
00E022  1  8D 08 03             STA     IIRQVECTOR
00E025  1  8D 0A 03             STA     IECOPVECTOR
00E028  1  8D 0C 03             STA     IEABTVECTOR
00E02B  1  8D 0E 03             STA     IENMIVECTOR
00E02E  1  8D 10 03             STA     IEINTVECTOR
00E031  1               
00E031  1  E2 30                ACCUMULATORINDEX8
00E033  1  4C E7 E0             JMP     mon
00E036  1               
00E036  1               RCOPVECTOR:
00E036  1  6C 00 03             JMP     (ICOPVECTOR)
00E039  1               RBRKVECTOR:
00E039  1  6C 02 03             JMP     (IBRKVECTOR)
00E03C  1               RABTVECTOR:
00E03C  1  6C 04 03             JMP     (IABTVECTOR)
00E03F  1               RNMIVECTOR:
00E03F  1  6C 06 03             JMP     (INMIVECTOR)
00E042  1               RIRQVECTOR:
00E042  1  6C 08 03             JMP     (IIRQVECTOR)
00E045  1               RECOPVECTOR:
00E045  1  6C 0A 03             JMP     (IECOPVECTOR)
00E048  1               REABTVECTOR:
00E048  1  6C 0C 03             JMP     (IEABTVECTOR)
00E04B  1               RENMIVECTOR:
00E04B  1  6C 0E 03             JMP     (IENMIVECTOR)
00E04E  1               REINTVECTOR:
00E04E  1  6C 10 03             JMP     (IEINTVECTOR)
00E051  1               
00E051  1               
00E051  1               ;__INTRETURN____________________________________________________
00E051  1               ;
00E051  1               ; Handle Interrupts
00E051  1               ;
00E051  1               ;_______________________________________________________________
00E051  1               ;
00E051  1               INTRETURN:
00E051  1  78                   SEI
00E052  1  40                   RTI                     ;
00E053  1               
00E053  1               ;__BATEST_______________________________________________________
00E053  1               ;
00E053  1               ; Perform Basic Hardware Assurance Test
00E053  1               ;
00E053  1               ;_______________________________________________________________
00E053  1               ;
00E053  1               BATEST:
00E053  1  60                   RTS
00E054  1               
00E054  1               
00E054  1               
00E054  1               ;__CONSOLE_INIT_________________________________________________
00E054  1               ;
00E054  1               ; Initialize Attached Console Devices
00E054  1               ;
00E054  1               ;_______________________________________________________________
00E054  1               ;
00E054  1               CONSOLE_INIT:
00E054  1  08                   PHP
00E055  1  E2 30                ACCUMULATORINDEX8
00E057  1  20 8F E0             JSR     SERIAL_CONSOLE_INIT
00E05A  1  A9 00                LDA     #$00
00E05C  1  8D 41 03             STA     ConsoleDevice
00E05F  1  28                   PLP
00E060  1  60                   RTS
00E061  1               
00E061  1               ;__OUTCH_______________________________________________________
00E061  1               ;
00E061  1               ; OUTPUT CHAR IN LOW BYTE OF ACC TO CONSOLE
00E061  1               ;
00E061  1               ; Current Console Device stored in ConsoleDevice
00E061  1               ;
00E061  1               ; 0=Serial
00E061  1               ; 1=On Board 9918/KB
00E061  1               ;______________________________________________________________
00E061  1               OUTCH:
00E061  1  DA                   PHX
00E062  1  5A                   PHY
00E063  1  08                   PHP
00E064  1  E2 30                ACCUMULATORINDEX8
00E066  1  AA                   TAX
00E067  1               ; LDA     ConsoleDevice
00E067  1               ; CMP     #$01
00E067  1               ; BNE     OUTCH2
00E067  1               ; TXA
00E067  1               ; JSR     Outch9918
00E067  1               ; PLP
00E067  1               ; PLY
00E067  1               ; PLX
00E067  1               ; RTS
00E067  1               
00E067  1               ; Default (serial)
00E067  1               OUTCH2:
00E067  1  8A                   TXA
00E068  1  20 AB E0             JSR     SERIAL_OUTCH
00E06B  1  28                   PLP
00E06C  1  7A                   PLY
00E06D  1  FA                   PLX
00E06E  1  60                   RTS
00E06F  1               
00E06F  1               
00E06F  1               ;__INCHW_______________________________________________________
00E06F  1               ;
00E06F  1               ; INPUT CHAR FROM CONSOLE TO ACC  (WAIT FOR CHAR)
00E06F  1               ;
00E06F  1               ;______________________________________________________________
00E06F  1               INCHW:
00E06F  1  DA                   PHX
00E070  1  5A                   PHY
00E071  1  08                   PHP
00E072  1  E2 30                ACCUMULATORINDEX8
00E074  1               
00E074  1               ;        LDA     ConsoleDevice
00E074  1               ;       CMP     #$01
00E074  1               ; jmp     INCHW2
00E074  1               ; PLP
00E074  1               ; PLY
00E074  1               ; PLX
00E074  1               ; RTS
00E074  1               
00E074  1               ; Default (serial)
00E074  1               INCHW2:
00E074  1  20 BE E0             JSR     SERIAL_INCHW
00E077  1  28                   PLP
00E078  1  7A                   PLY
00E079  1  FA                   PLX
00E07A  1  60                   RTS
00E07B  1               
00E07B  1               
00E07B  1               ;__INCH________________________________________________________
00E07B  1               ;
00E07B  1               ; INPUT CHAR FROM CONSOLE TO ACC
00E07B  1               ;
00E07B  1               ;______________________________________________________________
00E07B  1               INCH:
00E07B  1  DA                   PHX
00E07C  1  5A                   PHY
00E07D  1  08                   PHP
00E07E  1  E2 30                ACCUMULATORINDEX8
00E080  1               
00E080  1               ; LDA     ConsoleDevice
00E080  1               ; CMP     #$01
00E080  1               ; BNE     INCH2
00E080  1               
00E080  1               ; JSR     ScanKeyboard
00E080  1               ; CMP     #$FF
00E080  1               ; BEQ     INCH2S
00E080  1               ; JSR     GetKey
00E080  1               ; BRA     INCH2C
00E080  1               
00E080  1               ; Default (serial)
00E080  1               INCH2:
00E080  1  20 CF E0             JSR     SERIAL_INCH
00E083  1  B0 05                BCS     INCH2S
00E085  1               
00E085  1               
00E085  1               INCH2C:
00E085  1  28                   PLP
00E086  1  7A                   PLY
00E087  1  FA                   PLX
00E088  1  18                   CLC
00E089  1  60                   RTS
00E08A  1               INCH2S:
00E08A  1  28                   PLP
00E08B  1  7A                   PLY
00E08C  1  FA                   PLX
00E08D  1  38                   SEC
00E08E  1  60                   RTS
00E08F  1               
00E08F  1               
00E08F  1                       .A16
00E08F  1                       .I16
00E08F  1               ;
00E08F  1               ;__SERIAL_CONSOLE_INIT___________________________________________
00E08F  1               ;
00E08F  1               ;	INITIALIZE UART
00E08F  1               ;	PARAMS:	SER_BAUD NEEDS TO BE SET TO BAUD RATE
00E08F  1               ;	1200:	96	 = 1,843,200 / ( 16 X 1200 )
00E08F  1               ;	2400:	48	 = 1,843,200 / ( 16 X 2400 )
00E08F  1               ;	4800:	24	 = 1,843,200 / ( 16 X 4800 )
00E08F  1               ;	9600:	12	 = 1,843,200 / ( 16 X 9600 )
00E08F  1               ;	19K2:	06	 = 1,843,200 / ( 16 X 19,200 )
00E08F  1               ;	38K4:	03
00E08F  1               ;	57K6:	02
00E08F  1               ;	115K2:	01
00E08F  1               ;
00E08F  1               ;_______________________________________________________________
00E08F  1               ;
00E08F  1               SERIAL_CONSOLE_INIT:
00E08F  1  08                   PHP
00E090  1  E2 30                SEP     #$30            ; 8 bit registers (A AND I)
00E092  1                       .A8
00E092  1                       .I8
00E092  1  A9 80                LDA     #$80            ;
00E094  1  8D 5B DF             STA     UART3           ; SET DLAB FLAG
00E097  1  A9 0C                LDA     #12             ; SET TO 12 = 9600 BAUD
00E099  1  8D 58 DF             STA     UART0           ; save baud rate
00E09C  1  A9 00                LDA     #00             ;
00E09E  1  8D 59 DF             STA     UART1           ;
00E0A1  1  A9 03                LDA     #03             ;
00E0A3  1  8D 5B DF             STA     UART3           ; SET 8 BIT DATA, 1 STOPBIT
00E0A6  1  8D 5C DF             STA     UART4           ;
00E0A9  1  28                   PLP
00E0AA  1  60                   RTS
00E0AB  1               
00E0AB  1               
00E0AB  1                       .A16
00E0AB  1                       .I16
00E0AB  1               ;__OUTCH_______________________________________________________
00E0AB  1               ;
00E0AB  1               ; OUTPUT CHAR IN LOW BYTE OF ACC TO UART
00E0AB  1               ;
00E0AB  1               ;______________________________________________________________
00E0AB  1               SERIAL_OUTCH:
00E0AB  1  08                   PHP
00E0AC  1  E2 20                SEP     #$20            ; NEED 8 bit accum for this
00E0AE  1                       .A8
00E0AE  1  48                   PHA                     ; STORE ACC
00E0AF  1               TX_BUSYLP:
00E0AF  1  AD 5D DF             LDA     UART5           ; READ LINE STATUS REGISTER
00E0B2  1  29 20                AND     #$20            ; TEST IF UART IS READY TO SEND (BIT 5)
00E0B4  1  C9 00                CMP     #$00
00E0B6  1  F0 F7                BEQ     TX_BUSYLP       ; IF NOT REPEAT
00E0B8  1  68                   PLA                     ; RESTORE ACC
00E0B9  1  8D 58 DF             STA     UART0           ; THEN WRITE THE CHAR TO UART
00E0BC  1               
00E0BC  1  28                   PLP                     ; RESTORE CPU CONTEXT
00E0BD  1  60                   RTS                     ; DONE
00E0BE  1               
00E0BE  1               
00E0BE  1                       .A16
00E0BE  1                       .I16
00E0BE  1               ;__INCHW_______________________________________________________
00E0BE  1               ;
00E0BE  1               ; INPUT CHAR FROM UART TO ACC  (WAIT FOR CHAR)
00E0BE  1               ;
00E0BE  1               ;______________________________________________________________
00E0BE  1               SERIAL_INCHW:
00E0BE  1  08                   PHP
00E0BF  1  E2 20                SEP     #$20            ; NEED 8 bit accum for this
00E0C1  1                       .A8
00E0C1  1               
00E0C1  1               SERIAL_INCHW1:
00E0C1  1  AD 5D DF             LDA     UART5           ; READ LINE STATUS REGISTER
00E0C4  1  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00E0C6  1  C9 00                CMP     #$00
00E0C8  1  F0 F7                BEQ     SERIAL_INCHW1   ; LOOP UNTIL DATA IS READY
00E0CA  1  AD 58 DF             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
00E0CD  1               
00E0CD  1  28                   PLP                     ; RESTORE CPU CONTEXT
00E0CE  1  60                   RTS
00E0CF  1               
00E0CF  1               
00E0CF  1                       .A16
00E0CF  1                       .I16
00E0CF  1               ;__INCH_______________________________________________________
00E0CF  1               ;
00E0CF  1               ; INPUT CHAR FROM UART TO ACC (DO NOT WAIT FOR CHAR)
00E0CF  1               ; CArry set if invalid character
00E0CF  1               ;______________________________________________________________
00E0CF  1               SERIAL_INCH:
00E0CF  1  08                   PHP
00E0D0  1  E2 20                SEP     #$20            ; NEED 8 bit accum for this
00E0D2  1                       .A8
00E0D2  1  AD 5D DF             LDA     UART5           ; READ LINE STATUS REGISTER
00E0D5  1  29 01                AND     #$01            ; TEST IF DATA IN RECEIVE BUFFER
00E0D7  1  F0 06                BEQ     SERIAL_INCH1    ; NO CHAR FOUND
00E0D9  1  AD 58 DF             LDA     UART0           ; THEN READ THE CHAR FROM THE UART
00E0DC  1  28                   PLP                     ; RESTORE CPU CONTEXT
00E0DD  1  18                   CLC
00E0DE  1  60                   RTS
00E0DF  1               SERIAL_INCH1:
00E0DF  1  28                   PLP                     ; RESTORE CPU CONTEXT
00E0E0  1  38                   SEC
00E0E1  1  60                   RTS
00E0E2  1               
00E0E2  1               
00E0E2  1               nothere:
00E0E2  1  60                   RTS
00E0E3  1               
00E0E3  1                       .INCLUDE "SUPERMON816.ASM"
00E0E3  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*      SUPERMON 816 MACHINE LANGUAGE MONITOR FOR THE W65C816S MICROPROCESSOR      *
00E0E3  2               ;* ------------------------------------------------------------------------------- *
00E0E3  2               ;*      Copyright Â©1991-2014 by BCS Technology Limited.  All rights reserved.      *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Permission is hereby granted to use, copy, modify and distribute this software, *
00E0E3  2               ;* provided this copyright notice remains in the source code and  proper  attribu- *
00E0E3  2               ;* tion is given.  Redistribution, regardless of form, must be at no charge to the *
00E0E3  2               ;* end  user.  This code or any part thereof, including any derivation, MAY NOT be *
00E0E3  2               ;* incorporated into any package intended for sale,  unless written permission has *
00E0E3  2               ;* been given by the copyright holder.                                             *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* THERE IS NO WARRANTY OF ANY KIND WITH THIS SOFTWARE.  The user assumes all risk *
00E0E3  2               ;* in connection with the incorporation of this software into any system.          *
00E0E3  2               ;* ------------------------------------------------------------------------------- *
00E0E3  2               ;* Supermon 816 is a salute to Jim Butterfield, who passed away on June 29, 2007.  *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Jim, who was the unofficial  spokesman for  Commodore  International during the *
00E0E3  2               ;* heyday of the company's 8 bit supremacy, scratch-developed the Supermon machine *
00E0E3  2               ;* language monitor for the PET & CBM computers.   When the best-selling Commodore *
00E0E3  2               ;* 64 was introduced, Jim adapted his software to the new machine & gave the adap- *
00E0E3  2               ;* tation the name Supermon 64.   Commodore  subsequently  integrated a customized *
00E0E3  2               ;* version of Supermon 64 into the C-128 to act as the resident M/L monitor.       *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Although Supermon 816 is not an adaptation of Supermon 64,  it was  decided  to *
00E0E3  2               ;* keep the Supermon name alive, since Supermon 816's general operation & user in- *
00E0E3  2               ;* terface is similar to that of Supermon 64.   Supermon 816 is 100 percent native *
00E0E3  2               ;* mode 65C816 code & was developed from a blank canvas.                           *
00E0E3  2               ;* ------------------------------------------------------------------------------- *
00E0E3  2               ;* Supermon 816 is a full featured monitor and supports the following operations:  *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     A - Assemble code                                                           *
00E0E3  2               ;*     C - Compare memory regions                                                  *
00E0E3  2               ;*     D - Disassemble code                                                        *
00E0E3  2               ;*     F - Fill memory region (cannot span banks)                                  *
00E0E3  2               ;*     G - Execute code (stops at BRK)                                             *
00E0E3  2               ;*     H - Search (hunt) memory region                                             *
00E0E3  2               ;*     J - Execute code as a subroutine (stops at BRK or RTS)                      *
00E0E3  2               ;*     M - Dump & display memory range                                             *
00E0E3  2               ;*     R - Dump & display 65C816 registers                                         *
00E0E3  2               ;*     T - Copy (transfer) memory region                                           *
00E0E3  2               ;*     X - Exit Supermon 816 & return to operating environment                     *
00E0E3  2               ;*     > - Modify up to 32 bytes of memory                                         *
00E0E3  2               ;*     ; - Modify 65C816 registers                                                 *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Supermon 816 accepts binary (%), octal (%), decimal (+) and hexadecimal ($) as  *
00E0E3  2               ;* input for numeric parameters.  Additionally, the H and > operations accept an   *
00E0E3  2               ;* ASCII string in place of numeric values by preceding the string with ', e.g.:   *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     h 042000 042FFF 'BCS Technology Limited                                     *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* If no radix symbol is entered hex is assumed.                                   *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Numeric conversion is also available.  For example, typing:                     *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     +1234567 <CR>                                                               *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* will display:                                                                   *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*         $12D687                                                                 *
00E0E3  2               ;*         +1234567                                                                *
00E0E3  2               ;*         %04553207                                                               *
00E0E3  2               ;*         %100101101011010000111                                                  *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* In the above example, <CR> means the console keyboard's return or enter key.    *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* All numeric values are internally processed as 32 bit unsigned integers.  Addr- *
00E0E3  2               ;* esses may be entered as 8, 16 or 24 bit values.  During instruction assembly,   *
00E0E3  2               ;* immediate mode operands may be forced to 16 bits by preceding the operand with  *
00E0E3  2               ;* an exclamation point if the instruction can accept a 16 bit operand, e.g.:      *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     a 1f2000 lda !#4                                                            *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* The above will assemble as:                                                     *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     A 1F2000  A9 04 00     LDA #$0004                                           *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Entering:                                                                       *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     a 1f2000 ldx !#+157                                                         *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* will assemble as:                                                               *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     A 1F2000  A2 9D 00     LDX #$009D                                           *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Absent the ! in the operand field, the above would have been assembled as:      *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     A 1F2000  A2 9D        LDX #$9D                                             *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* If an immediate mode operand is greater than $FF assembly of a 16 bit operand   *
00E0E3  2               ;* is implied.                                                                     *
00E0E3  2               ;* ------------------------------------------------------------------------------- *
00E0E3  2               ;* A Note on the PEA & PEI Instructions                                            *
00E0E3  2               ;* ------------------------------------                                            *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* The Eyes and Lichty programming manual uses the following syntax for the PEA    *
00E0E3  2               ;* and PEI instructions:                                                           *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     PEA <operand>                                                               *
00E0E3  2               ;*     PEI (<operand>)                                                             *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* The WDC data sheet that was published at the time of the 65C816's release in    *
00E0E3  2               ;* 1984 does not indicate a recommended or preferred syntax for any of the above   *
00E0E3  2               ;* instructions.  PEA pushes its operand to the stack and hence operates like any  *
00E0E3  2               ;* other immediate mode instruction, in that the operand is the data (however, PEA *
00E0E3  2               ;* doesn't affect the status register).  Similarly, PEI pushes the 16 bit value    *
00E0E3  2               ;* stored at <operand> and <operand>+1, and hence operates like any other direct   *
00E0E3  2               ;* (zero) page instruction, again without affecting the status register.           *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* BCS Technology Limited is of the opinion that the developer of the ORCA/M as-   *
00E0E3  2               ;* sembler, which is the assembler referred to in the Eyes and Lichty manual, mis- *
00E0E3  2               ;* understood how PEA and PEI behave during runtime, and hence chose an incorrect  *
00E0E3  2               ;* syntax for these two instructions.  This error was subsequently carried forward *
00E0E3  2               ;* by Eyes and Lichty.                                                             *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* Supermon 816's assembler uses the following syntax for PEA and PEI:             *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;*     PEA #<operand>                                                              *
00E0E3  2               ;*     PEI <operand>                                                               *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* The operand for PEA is treated as a 16 bit value, even if entered as an 8 bit   *
00E0E3  2               ;* value.  The operand for PEI must be 8 bits.                                     *
00E0E3  2               ;*                                                                                 *
00E0E3  2               ;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
00E0E3  2               ;
00E0E3  2               ;	* * * * * * * * * * * *
00E0E3  2               ;	* VERSION INFORMATION *
00E0E3  2               ;	* * * * * * * * * * * *
00E0E3  2               ;
00E0E3  2                       .MACRO  SOFTVERS        ;software version - change with each revision...
00E0E3  2                       .BYTE   "1"             ;major
00E0E3  2                       .BYTE   "."
00E0E3  2                       .BYTE   "0"             ;minor
00E0E3  2                       .BYTE   "."
00E0E3  2                       .BYTE   "2"             ;revision
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;REVISION TABLE
00E0E3  2               ;
00E0E3  2               ;Ver  Rev Date    Description
00E0E3  2               ;-------------------------------------------------------------------------------
00E0E3  2               ;1.0  2013/11/01  A) Original derived from the POC V1.1 single-board computer
00E0E3  2               ;                    firmware.
00E0E3  2               ;     2013/11/04  A) Fixed a problem where the B-accumulator wasn't always being
00E0E3  2               ;                    be copied to shadow storage after return from execution of
00E0E3  2               ;                    a J command.
00E0E3  2               ;     2017/10/07  A) Converted to use WDC's 65816 assembler (D.WERNER)
00E0E3  2               ;		  B) Adapt for the RBC 65c816 SBC
00E0E3  2               ;		  C) Disable X command
00E0E3  2               ;-------------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	        COMMENT ABBREVIATIONS
00E0E3  2               ;	----------------------------------------------------
00E0E3  2               ;	  BCD   binary-coded decimal
00E0E3  2               ;	   DP   direct page or page zero
00E0E3  2               ;	  EOF   end-of-field
00E0E3  2               ;	  EOI   end-of-input
00E0E3  2               ;	  LSB   least significant byte/bit
00E0E3  2               ;	  LSD   least significant digit
00E0E3  2               ;	  LSN   least significant nybble
00E0E3  2               ;	  LSW   least significant word
00E0E3  2               ;	  MPU   microprocessor
00E0E3  2               ;	  MSB   most significant byte/bit
00E0E3  2               ;	  MSD   most significant digit
00E0E3  2               ;	  MSN   most significant nybble
00E0E3  2               ;	  MSW   most-significant word
00E0E3  2               ;	  RAM   random access memory
00E0E3  2               ;	   WS   whitespace, i.e., blanks & horizontal tabs
00E0E3  2               ;	----------------------------------------------------
00E0E3  2               ;	A word is defined as 16 bits.
00E0E3  2               ;
00E0E3  2               ;	   MPU REGISTER SYMBOLS
00E0E3  2               ;	--------------------------
00E0E3  2               ;	   .A   accumulator LSB
00E0E3  2               ;	   .B   accumulator MSB
00E0E3  2               ;	   .C   16 bit accumulator
00E0E3  2               ;	   .X   X-index
00E0E3  2               ;	   .Y   Y-index
00E0E3  2               ;	   DB   data bank
00E0E3  2               ;	   DP   direct page
00E0E3  2               ;	   PB   program bank
00E0E3  2               ;	   PC   program counter
00E0E3  2               ;	   SP   stack pointer
00E0E3  2               ;	   SR   MPU status
00E0E3  2               ;	----------------------------
00E0E3  2               ;
00E0E3  2               ;	  MPU STATUS REGISTER SYMBOLS
00E0E3  2               ;	-------------------------------
00E0E3  2               ;	    C   carry
00E0E3  2               ;	    D   decimal mode
00E0E3  2               ;	    I   maskable interrupts
00E0E3  2               ;	    m   accumulator/memory size
00E0E3  2               ;	    N   result negative
00E0E3  2               ;	    V   sign overflow
00E0E3  2               ;	    x   index registers size
00E0E3  2               ;	    Z   result zero
00E0E3  2               ;	-------------------------------
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;SYSTEM INTERFACE DEFINITIONS
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------
00E0E3  2               ;	This section defines the interface between Supermon 816 & the host
00E0E3  2               ;	system.   Change these definitions to suit your system, but do not
00E0E3  2               ;	change any label names.  All definitions must have valid values in
00E0E3  2               ;	order to assemble Supermon 816.
00E0E3  2               ;	------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	--------------------------------------------------------
00E0E3  2               ;.org  $008000              ;assembly address...
00E0E3  2               ;
00E0E3  2               ;	Set _ORIGIN_ to Supermon 816's desired assembly address.
00E0E3  2               ;	--------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;vecexit  = $002000              ;exit to environment address...
00E0E3  2               ;
00E0E3  2               ;	Set VECEXIT to where Supermon 816 should go when it exits.  Supermon 816
00E0E3  2               ;	will do a JML (long jump) to this address, which means VECEXIT must be a
00E0E3  2               ;	24 bit address.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;getcha                  ;get keystroke from console...
00E0E3  2               ;
00E0E3  2               ;	GETCHA refers to an operating system API call that returns a keystroke
00E0E3  2               ;	in the 8 bit accumulator.  Supermon 816  assumes that GETCHA is a non-
00E0E3  2               ;	blocking subroutine & returns with carry clear to indicate that a key-
00E0E3  2               ;	stroke is in .A, or with carry set to indicate that no keystroke was
00E0E3  2               ;	available.  GETCHA will be called with a JSR instruction.
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from GETCHA.
00E0E3  2               ;	You may have to modify Supermon 816 at all calls to GETCHA if your "get
00E0E3  2               ;	keystroke" routine works differently than described.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               getcha          = $FF74
00E0E3  2               CURSOR          = nothere
00E0E3  2               UNCURSOR        = nothere
00E0E3  2               ;------------------------------------------------------------------------
00E0E3  2               ;putcha   print character on console...
00E0E3  2               ;
00E0E3  2               ;	PUTCHA refers to an operating system API call that prints a character to
00E0E3  2               ;	the console screen.  The character to be printed will be in .A, which
00E0E3  2               ;	will be set to 8-bit width.  Supermon 816 assumes that PUTCHA will block
00E0E3  2               ;	until the character can be processed.  PUTCHA will be called with a JSR
00E0E3  2               ;	instructions.
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 expects .X & .Y to be preserved upon return from PUTCHA.
00E0E3  2               ;	You may have to modify Supermon 816 at all calls to PUTCHA if your "put
00E0E3  2               ;	character" routine works differently than described.
00E0E3  2               ;
00E0E3  2               putcha          = $FF71
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               vecbrki         = $0302         ;BRK handler indirect vector...
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 will modify this vector so that execution of a BRK instruc-
00E0E3  2               ;	tion is intercepted & the registers  are  captured.   Your BRK front end
00E0E3  2               ;	should jump through this vector after pushing the registers as follows:
00E0E3  2               ;
00E0E3  2               ;	         phb                   ;save DB
00E0E3  2               ;	         phd                   ;save DP
00E0E3  2               ;	         rep #%00110000        ;16 bit registers
00E0E3  2               ;	         pha
00E0E3  2               ;	         phx
00E0E3  2               ;	         phy
00E0E3  2               ;	         jmp (vecbrki)         ;indirect vector
00E0E3  2               ;
00E0E3  2               ;	When a G or J command is issued, the above sequence will be reversed be-
00E0E3  2               ;	fore a jump is made to the code to be executed.  Upon exit from Supermon
00E0E3  2               ;	816, the original address at VECBRKI will be restored.
00E0E3  2               ;
00E0E3  2               ;	If your BRK front end doesn't conform to the above you will have to mod-
00E0E3  2               ;	ify Supermon 816 to accommodate the differences.  The most likely needed
00E0E3  2               ;	changes will be in the order in which registers are pushed to the stack.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               hwstack         = $7FFF         ;top of hardware stack...
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 initializes the stack pointer to this address when the cold
00E0E3  2               ;	start at MONCOLD is called to enter the monitor.  The stack pointer will
00E0E3  2               ;	be undisturbed when entry into Supermon 816 is through JMONBRK (see jump
00E0E3  2               ;	table definitions).
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               zeropage        = $10           ;Supermon 816's direct page...
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 uses direct page starting at this address.  Be sure that no
00E0E3  2               ;	conflict occurs with other software.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               stopkey         = $03           ;display abort key...
00E0E3  2               ;
00E0E3  2               ;	Supermon 816 will poll for a "stop key" during display operations, such
00E0E3  2               ;	as code disassembly & memory dumps, so as to abort further processing &
00E0E3  2               ;	return to the command prompt.  STOPKEY must be defined with the ASCII
00E0E3  2               ;	value that the "stop key" will emit when typed.  The polling is via a
00E0E3  2               ;	call to GETCHA (described above).  The default STOPKEY definition of $03
00E0E3  2               ;	is for ASCII <ETX> or [Ctrl-C].
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ibuffer         = $000200       ;input buffer &...
00E0E3  2               auxbuf          = ibuffer+s_ibuf+s_byte;auxiliary buffer...
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;	Supermon 816 will use the above definitions for input buffers.  These
00E0E3  2               ;	buffers may be located anywhere in RAM that is convenient.  The buffers
00E0E3  2               ;	are stateless, which means that unless Supermon 816 has control of your
00E0E3  2               ;	system, they may be overwritten without consequence.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;W65C816S INSTRUCTION SYNTHESIS MACROS -- !!!!! DO NOT EDIT !!!!!
00E0E3  2               ;
00E0E3  2               
00E0E3  2               
00E0E3  2                       .MACRO  _ASM24_ _ad
00E0E3  2                       .BYTE   <_ad,>_ad,_ad>>16
00E0E3  2                       .ENDMACRO
00E0E3  2               
00E0E3  2               ;brl      .macro _ad
00E0E3  2               ;_ba      =*+3
00E0E3  2               ;         .BYTE $82
00E0E3  2               ;         .WORD _ad-_ba
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;jml      .macro _ad
00E0E3  2               ;         .BYTE $5c
00E0E3  2               ;         _asm24_ _ad
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;mvn      .macro _s,_d
00E0E3  2               ;         .BYTE $54,_d,_s
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;mvp      .macro _s,_d
00E0E3  2               ;         .BYTE $44,_d,_s
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;pea      .macro _op
00E0E3  2               ;         .BYTE $f4
00E0E3  2               ;         .WORD _op
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;phb      .macro
00E0E3  2               ;         .BYTE $8b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;phk      .macro
00E0E3  2               ;         .BYTE $4b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;plb      .macro
00E0E3  2               ;         .BYTE $ab
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;rep      .macro _op
00E0E3  2               ;         .BYTE $c2,_op
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;sep      .macro _op
00E0E3  2               ;         .BYTE $e2,_op
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;tcd      .macro
00E0E3  2               ;         .BYTE $5b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;tcs      .macro
00E0E3  2               ;         .BYTE $1b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;tdc      .macro
00E0E3  2               ;         .BYTE $7b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;tsc      .macro
00E0E3  2               ;         .BYTE $3b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;txy      .macro
00E0E3  2               ;         .BYTE $9b
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;tyx      .macro
00E0E3  2               ;         .BYTE $bb
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;wai      .macro
00E0E3  2               ;         .BYTE $cb
00E0E3  2               ;        .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;xba      .macro
00E0E3  2               ;         .BYTE $eb
00E0E3  2               ;         .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ADCW _OP
00E0E3  2                       ADC     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ANDW _OP
00E0E3  2                       AND     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  BITW _OP
00E0E3  2                       BIT     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CMPW _OP
00E0E3  2                       CMP     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CPXW        _OP
00E0E3  2                       CPX     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CPYW        _OP
00E0E3  2                       CPY     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  EORW        _OP
00E0E3  2                       EOR     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDAW        _OP
00E0E3  2                       LDA     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDXW        _OP
00E0E3  2                       LDX     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDYW        _OP
00E0E3  2                       LDY     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ORAW        _OP
00E0E3  2                       ORA     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SBCW        _OP
00E0E3  2                       SBC     #<_OP
00E0E3  2                       .BYTE   >_OP
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDALX _AD
00E0E3  2                       .BYTE   $BF
00E0E3  2                       _ASM24_ _AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ADCIL        _AD
00E0E3  2                       .BYTE   $67,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ADCILY        _AD
00E0E3  2                       .BYTE   $77,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ANDIL        _AD
00E0E3  2                       .BYTE   $27,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ANDILY        _AD
00E0E3  2                       .BYTE   $37,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CMPIL        _AD
00E0E3  2                       .BYTE   $C7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CMPILY        _AD
00E0E3  2                       .BYTE   $D7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  EORIL        _AD
00E0E3  2                       .BYTE   $47,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  EORILY        _AD
00E0E3  2                       .BYTE   $57,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDAIL        _AD
00E0E3  2                       .BYTE   $A7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDAILY        _AD
00E0E3  2                       .BYTE   $B7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ORAIL        _AD
00E0E3  2                       .BYTE   $07,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ORAILY        _AD
00E0E3  2                       .BYTE   $17,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SBCIL        _AD
00E0E3  2                       .BYTE   $E7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SBCILY        _AD
00E0E3  2                       .BYTE   $F7,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  STAIL        _AD
00E0E3  2                       .BYTE   $87,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  STAILY        _AD
00E0E3  2                       .BYTE   $97,_AD
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ADCS        _OF
00E0E3  2                       .BYTE   $63,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ADCSI        _OF
00E0E3  2                       .BYTE   $73,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ANDS        _OF
00E0E3  2                       .BYTE   $23,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ANDSI        _OF
00E0E3  2                       .BYTE   $33,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CMPS        _OF
00E0E3  2                       .BYTE   $C3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  CMPSI        _OF
00E0E3  2                       .BYTE   $D3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  EORS        _OF
00E0E3  2                       .BYTE   $43,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  EORSI        _OF
00E0E3  2                       .BYTE   $53,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDAS        _OF
00E0E3  2                       .BYTE   $A3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LDASI        _OF
00E0E3  2                       .BYTE   $B3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ORAS        _OF
00E0E3  2                       .BYTE   $03,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  ORASI        _OF
00E0E3  2                       .BYTE   $13,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SBCS        _OF
00E0E3  2                       .BYTE   $E3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SBCSI        _OF
00E0E3  2                       .BYTE   $F3,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  STAS        _OF
00E0E3  2                       .BYTE   $83,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  STASI        _OF
00E0E3  2                       .BYTE   $93,_OF
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SLONGA
00E0E3  2                       .BYTE   $C2,$20
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LONGR
00E0E3  2                       .BYTE   $C2,$30
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  LONGX
00E0E3  2                       .BYTE   $C2,$10
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SHORTA
00E0E3  2                       .BYTE   $E2,$20
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SHORTI
00E0E3  2                       .BYTE   $E2,$10
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SHORTR
00E0E3  2                       .BYTE   $E2,$30
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2                       .MACRO  SHORTX
00E0E3  2                       .BYTE   $E2,$10
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;CONSOLE DISPLAY CONTROL MACROS
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;	The following macros execute terminal  control procedures  that  perform
00E0E3  2               ;	such tasks as clearing the screen,  switching  between  normal & reverse
00E0E3  2               ;	video, etc.  These macros are for WYSE 60 & compatible displays, such as
00E0E3  2               ;	the WYSE 150, WYSE 160, WYSE 325 & WYSE GPT.   Only the functions needed
00E0E3  2               ;	by Supermon 816 are included.
00E0E3  2               ;
00E0E3  2               ;	If your console is not WYSE 60 compatible, you will need to  edit  these
00E0E3  2               ;	macros as required to control your particular console or terminal.  Note
00E0E3  2               ;	that in some cases one macro may call another.  Exercise caution in your
00E0E3  2               ;	edits to avoid introducing display bugs.
00E0E3  2               ;
00E0E3  2               ;	If your console display cannot execute one of these procedures,  such as
00E0E3  2               ;	'CL' (clear to end of line), you will have to develop an alternative.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	cursor control...
00E0E3  2               ;
00E0E3  2                       .MACRO  CRR             ;carriage return
00E0E3  2                       .BYTE   a_cr
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2               
00E0E3  2                       .MACRO  LF              ;carriage return/line feed
00E0E3  2                       CRR
00E0E3  2                       .BYTE   a_lf
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;	miscellaneous control...
00E0E3  2               ;
00E0E3  2                       .MACRO  RB              ;ring "bell"
00E0E3  2                       .BYTE   a_bel
00E0E3  2                       .ENDMACRO
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;ASCII CONTROL DEFINITIONS (menmonic order)
00E0E3  2               ;
00E0E3  2               a_bel           = $07           ;<BEL> alert/ring bell
00E0E3  2               a_bs            = $08           ;<BS>  backspace
00E0E3  2               a_cr            = $0d           ;<CR>  carriage return
00E0E3  2               a_del           = $7f           ;<DEL> delete
00E0E3  2               a_esc           = $1b           ;<ESC> escape
00E0E3  2               a_ht            = $09           ;<HT>  horizontal tabulation
00E0E3  2               a_lf            = $0a           ;<LF>  linefeed
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	miscellaneous (description order)...
00E0E3  2               ;
00E0E3  2               a_blank         = ' '           ;blank (whitespace)
00E0E3  2               a_asclch        = 'z'           ;end of lowercase ASCII
00E0E3  2               a_lctouc        = $5f           ;LC to UC conversion mask
00E0E3  2               a_asclcl        = 'a'           ;start of lowercase ASCII
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;GLOBAL ATOMIC CONSTANTS
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	data type sizes...
00E0E3  2               ;
00E0E3  2               s_byte          = 1             ;byte
00E0E3  2               s_word          = 2             ;word (16 bits)
00E0E3  2               s_xword         = 3             ;extended word (24 bits)
00E0E3  2               s_dword         = 4             ;double word (32 bits)
00E0E3  2               s_rampag        = $0100         ;65xx RAM page
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	data type sizes in bits...
00E0E3  2               ;
00E0E3  2               s_bibyte        = 8             ;byte
00E0E3  2               s_bnybbl        = 4             ;nybble
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	miscellaneous...
00E0E3  2               ;
00E0E3  2               bitabs          = $2c           ;absolute BIT opcode
00E0E3  2               bitzp           = $24           ;zero page BIT opcode
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;W65C816S NATIVE MODE STATUS REGISTER DEFINITIONS
00E0E3  2               ;
00E0E3  2               s_mpudbx        = s_byte        ;data bank size
00E0E3  2               s_mpudpx        = s_word        ;direct page size
00E0E3  2               s_mpupbx        = s_byte        ;program bank size
00E0E3  2               s_mpupcx        = s_word        ;program counter size
00E0E3  2               s_mpuspx        = s_word        ;stack pointer size
00E0E3  2               s_mpusrx        = s_byte        ;status size
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	status register flags...
00E0E3  2               ;
00E0E3  2               sr_car          = %00000001     ;C
00E0E3  2               sr_zer          = sr_car<<1     ;Z
00E0E3  2               sr_irq          = sr_zer<<1     ;I
00E0E3  2               sr_bdm          = sr_irq<<1     ;D
00E0E3  2               sr_ixw          = sr_bdm<<1     ;x
00E0E3  2               sr_amw          = sr_ixw<<1     ;m
00E0E3  2               sr_ovl          = sr_amw<<1     ;V
00E0E3  2               sr_neg          = sr_ovl<<1     ;N
00E0E3  2               ;
00E0E3  2               ;	NVmxDIZC
00E0E3  2               ;	xxxxxxxx
00E0E3  2               ;	||||||||
00E0E3  2               ;	|||||||+---> 1 = carry set/generated
00E0E3  2               ;	||||||+----> 1 = result = zero
00E0E3  2               ;	|||||+-----> 1 = IRQs ignored
00E0E3  2               ;	||||+------> 0 = binary arithmetic mode
00E0E3  2               ;	||||         1 = decimal arithmetic mode
00E0E3  2               ;	|||+-------> 0 = 16 bit index
00E0E3  2               ;	|||          1 = 8 bit index
00E0E3  2               ;	||+--------> 0 = 16 bit .A & memory
00E0E3  2               ;	||           1 = 8 bit .A & memory
00E0E3  2               ;	|+---------> 1 = sign overflow
00E0E3  2               ;	+----------> 1 = result = negative
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;"SIZE-OF" CONSTANTS
00E0E3  2               ;
00E0E3  2               s_addr          = s_xword       ;24 bit address
00E0E3  2               s_auxbuf        = 32            ;auxiliary buffer
00E0E3  2               s_ibuf          = 69            ;input buffer
00E0E3  2               s_mnemon        = 3             ;MPU ASCII mnemonic
00E0E3  2               s_mnepck        = 2             ;MPU encoded mnemonic
00E0E3  2               s_mvinst        = 3             ;MVN/MVP instruction
00E0E3  2               s_opcode        = s_byte        ;MPU opcode
00E0E3  2               s_oper          = s_xword       ;operand
00E0E3  2               s_pfac          = s_dword       ;primary math accumulator
00E0E3  2               s_sfac          = s_dword+s_word;secondary math accumulators
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;"NUMBER-OF" CONSTANTS
00E0E3  2               ;
00E0E3  2               n_dbytes        = 21            ;default disassembly bytes
00E0E3  2               n_dump          = 8             ;bytes per memory dump line
00E0E3  2               n_mbytes        = s_rampag-1    ;default memory dump bytes
00E0E3  2               n_hccols        = 10            ;compare/hunt display columns
00E0E3  2               n_opcols        = 3*s_oper      ;disassembly operand columns
00E0E3  2               n_opslsr        = 4             ;LSRs to extract instruction size
00E0E3  2               n_shfenc        = 5             ;shifts to encode/decode mnemonic
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;NUMERIC CONVERSION CONSTANTS
00E0E3  2               ;
00E0E3  2               a_hexdec        = 'A'-'9'-2     ;hex to decimal difference
00E0E3  2               c_bin           = '%'           ;binary prefix
00E0E3  2               c_dec           = '+'           ;decimal prefix
00E0E3  2               c_hex           = '$'           ;hexadecimal prefix
00E0E3  2               c_oct           = '@'           ;octal prefix
00E0E3  2               k_hex           = 'f'           ;hex ASCII conversion
00E0E3  2               m_bits          = s_pfac*s_bibyte;operand bit size
00E0E3  2               m_cbits         = s_sfac*s_bibyte;workspace bit size
00E0E3  2               bcdumask        = %00001111     ;isolate BCD units mask
00E0E3  2               btoamask        = %00110000     ;binary to ASCII mask
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;ASSEMBLER/DISASSEMBLER CONSTANTS
00E0E3  2               ;
00E0E3  2               a_mnecvt        = '?'           ;encoded mnemonic conversion base
00E0E3  2               aimmaska        = %00011111     ;.A immediate opcode test #1
00E0E3  2               aimmaskb        = %00001001     ;.A immediate opcode test #2
00E0E3  2               asmprfx         = 'A'           ;assemble code prefix
00E0E3  2               ascprmct        = 9             ;assembler prompt "size-of"
00E0E3  2               disprfx         = '.'           ;disassemble code prefix
00E0E3  2               flimmask        = %11000000     ;force long immediate flag
00E0E3  2               opc_cpxi        = $e0           ;CPX # opcode
00E0E3  2               opc_cpyi        = $c0           ;CPY # opcode
00E0E3  2               opc_ldxi        = $a2           ;LDX # opcode
00E0E3  2               opc_ldyi        = $a0           ;LDY # opcode
00E0E3  2               opc_mvn         = $54           ;MVN opcode
00E0E3  2               opc_mvp         = $44           ;MVP opcode
00E0E3  2               opc_rep         = $c2           ;REP opcode
00E0E3  2               opc_sep         = $e2           ;SEP opcode
00E0E3  2               pfmxmask        = sr_amw|sr_ixw ;MPU m & x flag bits mask
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	assembler prompt buffer offsets...
00E0E3  2               ;
00E0E3  2               apadrbkh        = s_word        ;instruction address bank MSN
00E0E3  2               apadrbkl        = apadrbkh+s_byte;instruction address bank LSN
00E0E3  2               apadrmbh        = apadrbkl+s_byte;instruction address MSB MSN
00E0E3  2               apadrmbl        = apadrmbh+s_byte;instruction address MSB LSN
00E0E3  2               apadrlbh        = apadrmbl+s_byte;instruction address LSB MSN
00E0E3  2               apadrlbl        = apadrlbh+s_byte;instruction address LSB LSN
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	addressing mode preamble symbols...
00E0E3  2               ;
00E0E3  2               amp_flim        = '!'           ;force long immediate
00E0E3  2               amp_imm         = '#'           ;immediate
00E0E3  2               amp_ind         = '('           ;indirect
00E0E3  2               amp_indl        = '['           ;indirect long
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	addressing mode symbolic translation indices...
00E0E3  2               ;
00E0E3  2               am_nam          = %0000         ;no symbol
00E0E3  2               am_imm          = %0001         ;#
00E0E3  2               am_adrx         = %0010         ;<addr>,X
00E0E3  2               am_adry         = %0011         ;<addr>,Y
00E0E3  2               am_ind          = %0100         ;(<addr>)
00E0E3  2               am_indl         = %0101         ;[<dp>]
00E0E3  2               am_indly        = %0110         ;[<dp>],Y
00E0E3  2               am_indx         = %0111         ;(<addr>,X)
00E0E3  2               am_indy         = %1000         ;(<dp>),Y
00E0E3  2               am_stk          = %1001         ;<offset>,S
00E0E3  2               am_stky         = %1010         ;(<offset>,S),Y
00E0E3  2               am_move         = %1011         ;<sbnk>,<dbnk>
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	operand size translation indices...
00E0E3  2               ;
00E0E3  2               ops0            = %0000<<4      ;no operand
00E0E3  2               ops1            = %0001<<4      ;8 bit operand
00E0E3  2               ops2            = %0010<<4      ;16 bit operand
00E0E3  2               ops3            = %0011<<4      ;24 bit operand
00E0E3  2               bop1            = %0101<<4      ;8 bit relative branch
00E0E3  2               bop2            = %0110<<4      ;16 bit relative branch
00E0E3  2               vops            = %1001<<4      ;8 or 16 bit operand
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	operand size & addressing mode extraction masks...
00E0E3  2               ;
00E0E3  2               amodmask        = %00001111     ;addressing mode index
00E0E3  2               opsmask         = %00110000     ;operand size
00E0E3  2               vopsmask        = %11000000     ;BOPx & VOPS flag bits
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	instruction mnemonic encoding...
00E0E3  2               ;
00E0E3  2               mne_adc         = $2144         ;ADC
00E0E3  2               mne_and         = $2bc4         ;AND
00E0E3  2               mne_asl         = $6d04         ;ASL
00E0E3  2               mne_bcc         = $2106         ;BCC
00E0E3  2               mne_bcs         = $a106         ;BCS
00E0E3  2               mne_beq         = $9186         ;BEQ
00E0E3  2               mne_bit         = $aa86         ;BIT
00E0E3  2               mne_bmi         = $5386         ;BMI
00E0E3  2               mne_bne         = $33c6         ;BNE
00E0E3  2               mne_bpl         = $6c46         ;BPL
00E0E3  2               mne_bra         = $14c6         ;BRA
00E0E3  2               mne_brk         = $64c6         ;BRK
00E0E3  2               mne_brl         = $6cc6         ;BRL
00E0E3  2               mne_bvc         = $25c6         ;BVC
00E0E3  2               mne_bvs         = $a5c6         ;BVS
00E0E3  2               mne_clc         = $2348         ;CLC
00E0E3  2               mne_cld         = $2b48         ;CLD
00E0E3  2               mne_cli         = $5348         ;CLI
00E0E3  2               mne_clv         = $bb48         ;CLV
00E0E3  2               mne_cmp         = $8b88         ;CMP
00E0E3  2               mne_cop         = $8c08         ;COP
00E0E3  2               mne_cpx         = $cc48         ;CPX
00E0E3  2               mne_cpy         = $d448         ;CPY
00E0E3  2               mne_dec         = $218a         ;DEC
00E0E3  2               mne_dex         = $c98a         ;DEX
00E0E3  2               mne_dey         = $d18a         ;DEY
00E0E3  2               mne_eor         = $9c0c         ;EOR
00E0E3  2               mne_inc         = $23d4         ;INC
00E0E3  2               mne_inx         = $cbd4         ;INX
00E0E3  2               mne_iny         = $d3d4         ;INY
00E0E3  2               mne_jml         = $6b96         ;JML
00E0E3  2               mne_jmp         = $8b96         ;JMP
00E0E3  2               mne_jsl         = $6d16         ;JSL
00E0E3  2               mne_jsr         = $9d16         ;JSR
00E0E3  2               mne_lda         = $115a         ;LDA
00E0E3  2               mne_ldx         = $c95a         ;LDX
00E0E3  2               mne_ldy         = $d15a         ;LDY
00E0E3  2               mne_lsr         = $9d1a         ;LSR
00E0E3  2               mne_mvn         = $7ddc         ;MVN
00E0E3  2               mne_mvp         = $8ddc         ;MVP
00E0E3  2               mne_nop         = $8c1e         ;NOP
00E0E3  2               mne_ora         = $14e0         ;ORA
00E0E3  2               mne_pea         = $11a2         ;PEA
00E0E3  2               mne_pei         = $51a2         ;PEI
00E0E3  2               mne_per         = $99a2         ;PER
00E0E3  2               mne_pha         = $1262         ;PHA
00E0E3  2               mne_phb         = $1a62         ;PHB
00E0E3  2               mne_phd         = $2a62         ;PHD
00E0E3  2               mne_phk         = $6262         ;PHK
00E0E3  2               mne_php         = $8a62         ;PHP
00E0E3  2               mne_phx         = $ca62         ;PHX
00E0E3  2               mne_phy         = $d262         ;PHY
00E0E3  2               mne_pla         = $1362         ;PLA
00E0E3  2               mne_plb         = $1b62         ;PLB
00E0E3  2               mne_pld         = $2b62         ;PLD
00E0E3  2               mne_plp         = $8b62         ;PLP
00E0E3  2               mne_plx         = $cb62         ;PLX
00E0E3  2               mne_ply         = $d362         ;PLY
00E0E3  2               mne_rep         = $89a6         ;REP
00E0E3  2               mne_rol         = $6c26         ;ROL
00E0E3  2               mne_ror         = $9c26         ;ROR
00E0E3  2               mne_rti         = $5566         ;RTI
00E0E3  2               mne_rtl         = $6d66         ;RTL
00E0E3  2               mne_rts         = $a566         ;RTS
00E0E3  2               mne_sbc         = $20e8         ;SBC
00E0E3  2               mne_sec         = $21a8         ;SEC
00E0E3  2               mne_sed         = $29a8         ;SED
00E0E3  2               mne_sei         = $51a8         ;SEI
00E0E3  2               mne_sep         = $89a8         ;SEP
00E0E3  2               mne_sta         = $1568         ;STA
00E0E3  2               mne_stp         = $8d68         ;STP
00E0E3  2               mne_stx         = $cd68         ;STX
00E0E3  2               mne_sty         = $d568         ;STY
00E0E3  2               mne_stz         = $dd68         ;STZ
00E0E3  2               mne_tax         = $c8aa         ;TAX
00E0E3  2               mne_tay         = $d0aa         ;TAY
00E0E3  2               mne_tcd         = $292a         ;TCD
00E0E3  2               mne_tcs         = $a12a         ;TCS
00E0E3  2               mne_tdc         = $216a         ;TDC
00E0E3  2               mne_trb         = $1cea         ;TRB
00E0E3  2               mne_tsb         = $1d2a         ;TSB
00E0E3  2               mne_tsc         = $252a         ;TSC
00E0E3  2               mne_tsx         = $cd2a         ;TSX
00E0E3  2               mne_txa         = $166a         ;TXA
00E0E3  2               mne_txs         = $a66a         ;TXS
00E0E3  2               mne_txy         = $d66a         ;TXY
00E0E3  2               mne_tya         = $16aa         ;TYA
00E0E3  2               mne_tyx         = $ceaa         ;TYX
00E0E3  2               mne_wai         = $50b0         ;WAI
00E0E3  2               mne_wdm         = $7170         ;WDM
00E0E3  2               mne_xba         = $10f2         ;XBA
00E0E3  2               mne_xce         = $3132         ;XCE
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	encoded instruction mnemonic indices...
00E0E3  2               ;
00E0E3  2               mne_adcx        = 16            ;ADC
00E0E3  2               mne_andx        = 29            ;AND
00E0E3  2               mne_aslx        = 44            ;ASL
00E0E3  2               mne_bccx        = 15            ;BCC
00E0E3  2               mne_bcsx        = 65            ;BCS
00E0E3  2               mne_beqx        = 59            ;BEQ
00E0E3  2               mne_bitx        = 70            ;BIT
00E0E3  2               mne_bmix        = 36            ;BMI
00E0E3  2               mne_bnex        = 31            ;BNE
00E0E3  2               mne_bplx        = 42            ;BPL
00E0E3  2               mne_brax        = 5             ;BRA
00E0E3  2               mne_brkx        = 39            ;BRK
00E0E3  2               mne_brlx        = 43            ;BRL
00E0E3  2               mne_bvcx        = 23            ;BVC
00E0E3  2               mne_bvsx        = 68            ;BVS
00E0E3  2               mne_clcx        = 20            ;CLC
00E0E3  2               mne_cldx        = 27            ;CLD
00E0E3  2               mne_clix        = 35            ;CLI
00E0E3  2               mne_clvx        = 71            ;CLV
00E0E3  2               mne_cmpx        = 53            ;CMP
00E0E3  2               mne_copx        = 55            ;COP
00E0E3  2               mne_cpxx        = 78            ;CPX
00E0E3  2               mne_cpyx        = 88            ;CPY
00E0E3  2               mne_decx        = 18            ;DEC
00E0E3  2               mne_dexx        = 74            ;DEX
00E0E3  2               mne_deyx        = 84            ;DEY
00E0E3  2               mne_eorx        = 61            ;EOR
00E0E3  2               mne_incx        = 21            ;INC
00E0E3  2               mne_inxx        = 77            ;INX
00E0E3  2               mne_inyx        = 87            ;INY
00E0E3  2               mne_jmlx        = 40            ;JML
00E0E3  2               mne_jmpx        = 54            ;JMP
00E0E3  2               mne_jslx        = 45            ;JSL
00E0E3  2               mne_jsrx        = 63            ;JSR
00E0E3  2               mne_ldax        = 1             ;LDA
00E0E3  2               mne_ldxx        = 73            ;LDX
00E0E3  2               mne_ldyx        = 83            ;LDY
00E0E3  2               mne_lsrx        = 64            ;LSR
00E0E3  2               mne_mvnx        = 48            ;MVN
00E0E3  2               mne_mvpx        = 58            ;MVP
00E0E3  2               mne_nopx        = 56            ;NOP
00E0E3  2               mne_orax        = 6             ;ORA
00E0E3  2               mne_peax        = 2             ;PEA
00E0E3  2               mne_peix        = 33            ;PEI
00E0E3  2               mne_perx        = 60            ;PER
00E0E3  2               mne_phax        = 3             ;PHA
00E0E3  2               mne_phbx        = 10            ;PHB
00E0E3  2               mne_phdx        = 26            ;PHD
00E0E3  2               mne_phkx        = 38            ;PHK
00E0E3  2               mne_phpx        = 51            ;PHP
00E0E3  2               mne_phxx        = 75            ;PHX
00E0E3  2               mne_phyx        = 85            ;PHY
00E0E3  2               mne_plax        = 4             ;PLA
00E0E3  2               mne_plbx        = 11            ;PLB
00E0E3  2               mne_pldx        = 28            ;PLD
00E0E3  2               mne_plpx        = 52            ;PLP
00E0E3  2               mne_plxx        = 76            ;PLX
00E0E3  2               mne_plyx        = 86            ;PLY
00E0E3  2               mne_repx        = 49            ;REP
00E0E3  2               mne_rolx        = 41            ;ROL
00E0E3  2               mne_rorx        = 62            ;ROR
00E0E3  2               mne_rtix        = 37            ;RTI
00E0E3  2               mne_rtlx        = 46            ;RTL
00E0E3  2               mne_rtsx        = 67            ;RTS
00E0E3  2               mne_sbcx        = 14            ;SBC
00E0E3  2               mne_secx        = 19            ;SEC
00E0E3  2               mne_sedx        = 25            ;SED
00E0E3  2               mne_seix        = 34            ;SEI
00E0E3  2               mne_sepx        = 50            ;SEP
00E0E3  2               mne_stax        = 7             ;STA
00E0E3  2               mne_stpx        = 57            ;STP
00E0E3  2               mne_stxx        = 80            ;STX
00E0E3  2               mne_styx        = 89            ;STY
00E0E3  2               mne_stzx        = 91            ;STZ
00E0E3  2               mne_taxx        = 72            ;TAX
00E0E3  2               mne_tayx        = 82            ;TAY
00E0E3  2               mne_tcdx        = 24            ;TCD
00E0E3  2               mne_tcsx        = 66            ;TCS
00E0E3  2               mne_tdcx        = 17            ;TDC
00E0E3  2               mne_trbx        = 12            ;TRB
00E0E3  2               mne_tsbx        = 13            ;TSB
00E0E3  2               mne_tscx        = 22            ;TSC
00E0E3  2               mne_tsxx        = 79            ;TSX
00E0E3  2               mne_txax        = 8             ;TXA
00E0E3  2               mne_txsx        = 69            ;TXS
00E0E3  2               mne_txyx        = 90            ;TXY
00E0E3  2               mne_tyax        = 9             ;TYA
00E0E3  2               mne_tyxx        = 81            ;TYX
00E0E3  2               mne_waix        = 32            ;WAI
00E0E3  2               mne_wdmx        = 47            ;WDM
00E0E3  2               mne_xbax        = 0             ;XBA
00E0E3  2               mne_xcex        = 30            ;XCE
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;MISCELLANEOUS CONSTANTS
00E0E3  2               ;
00E0E3  2               halftab         = 4             ;1/2 tabulation spacing
00E0E3  2               memprfx         = '>'           ;memory dump prefix
00E0E3  2               memsepch        = ':'           ;memory dump separator
00E0E3  2               memsubch        = '.'           ;memory dump non-print char
00E0E3  2               srinit          = %00110000     ;SR initialization value
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;DIRECT PAGE STORAGE
00E0E3  2               ;
00E0E3  2               reg_pbx         = zeropage      ;PB
00E0E3  2               reg_pcx         = reg_pbx+s_mpupbx;PC
00E0E3  2               reg_srx         = reg_pcx+s_mpupcx;SR
00E0E3  2               reg_ax          = reg_srx+s_mpusrx;.C
00E0E3  2               reg_xx          = reg_ax+s_word ;.X
00E0E3  2               reg_yx          = reg_xx+s_word ;.Y
00E0E3  2               reg_spx         = reg_yx+s_word ;SP
00E0E3  2               reg_dpx         = reg_spx+s_mpuspx;DP
00E0E3  2               reg_dbx         = reg_dpx+s_mpudpx;DB
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	general workspace...
00E0E3  2               ;
00E0E3  2               addra           = reg_dbx+s_mpudbx;address #1
00E0E3  2               addrb           = addra+s_addr  ;address #2
00E0E3  2               faca            = addrb+s_addr  ;primary accumulator
00E0E3  2               facax           = faca+s_pfac   ;extended primary accumulator
00E0E3  2               facb            = facax+s_pfac  ;secondary accumulator
00E0E3  2               facc            = facb+s_sfac   ;tertiary accumulator
00E0E3  2               operand         = facc+s_sfac   ;instruction operand
00E0E3  2               auxbufix        = operand+s_oper;auxiliary buffer index
00E0E3  2               ibufidx         = auxbufix+s_byte;input buffer index
00E0E3  2               bitsdig         = ibufidx+s_byte;bits per numeral
00E0E3  2               numeral         = bitsdig+s_byte;numeral buffer
00E0E3  2               radix           = numeral+s_byte;radix index
00E0E3  2               admodidx        = radix+s_byte  ;addressing mode index
00E0E3  2               charcnt         = admodidx+s_byte;character counter
00E0E3  2               instsize        = charcnt+s_word;instruction size
00E0E3  2               mnepck          = instsize+s_word;encoded mnemonic
00E0E3  2               opcode          = mnepck+s_mnepck;current opcode
00E0E3  2               status          = opcode+s_byte ;I/O status flag
00E0E3  2               xrtemp          = status+s_byte ;temp .X storage
00E0E3  2               eopsize         = xrtemp+s_byte ;entered operand size
00E0E3  2               flimflag        = eopsize+s_byte;forced long immediate...
00E0E3  2               vecbrkia        = flimflag+s_byte;system indirect BRK vector
00E0E3  2               ;
00E0E3  2               ;	xx000000
00E0E3  2               ;	||
00E0E3  2               ;	|+---------> 0: .X/.Y =  8 bits
00E0E3  2               ;	|            1: .X/.Y =  18 bits
00E0E3  2               ;	+----------> 0: .A =  8 bits
00E0E3  2               ;	             1: .A =  16 bits
00E0E3  2               ;
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;	During assembly, FLIMFLAG indicates the operand size used with an immed-
00E0E3  2               ;	iate mode instruction, thus causing the following disassembly to display
00E0E3  2               ;	the assembled  operand size.   During disassembly,  FLIMFLAG will mirror
00E0E3  2               ;	the effect of the most recent REP or SEP instruction.
00E0E3  2               ;	------------------------------------------------------------------------
00E0E3  2               ;
00E0E3  2               iopsize         = flimflag+s_byte;operand size
00E0E3  2               range           = iopsize+s_byte;allowable radix range
00E0E3  2               vopsflag        = range+s_byte  ;VOPS & ROPS mode bits
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               ;	copy/fill workspace (overlaps some of the above)...
00E0E3  2               ;
00E0E3  2               mcftwork        = faca          ;start of copy/fill code
00E0E3  2               mcftopc         = mcftwork+s_byte;instruction opcode
00E0E3  2               mcftbnk         = mcftopc+s_byte;banks
00E0E3  2               ;
00E0E3  2               ;================================================================================
00E0E3  2               ;
00E0E3  2               ;SUPERMON 816 JUMP TABLE
00E0E3  2               ;
00E0E3  2               ;
00E0E3  2               JMON:
00E0E3  2  80 02                BRA     mon             ;cold start entry
00E0E5  2               JMONBRK:
00E0E5  2  80 54                BRA     monbrk          ;software interrupt intercept
00E0E7  2               ;
00E0E7  2               ;
00E0E7  2               ;================================================================================
00E0E7  2               ;
00E0E7  2               ;mon: SUPERMON 816 COLD START
00E0E7  2               ;
00E0E7  2               mon:
00E0E7  2  C2 10                INDEX16
00E0E9  2  E2 20                ACCUMULATOR8
00E0EB  2  A0 00 00             LDY     #$0000          ; LOAD $00 INTO Y
00E0EE  2               OUTSTRLP:
00E0EE  2  B9 88 F1             LDA     ALIVEM,Y        ; LOAD NEXT CHAR FROM STRING INTO ACC
00E0F1  2  C9 00                CMP     #$00            ; IS NULL?
00E0F3  2  F0 07                BEQ     ENDOUTSTR       ; YES, END PRINT OUT
00E0F5  2  20 71 FF             JSR     putcha          ; PRINT CHAR IN ACC
00E0F8  2  C8                   INY                     ; Y=Y+1 (BUMP INDEX)
00E0F9  2  4C EE E0             JMP     OUTSTRLP        ; DO NEXT CHAR
00E0FC  2               ENDOUTSTR:
00E0FC  2  E2 10                INDEX8
00E0FE  2               
00E0FE  2               
00E0FE  2  C2 20                SLONGA
00E100  2  AD 02 03             LDA     vecbrki         ;BRK vector
00E103  2  C9 3B E1             CMPW    monbrk          ;pointing at monitor?
00E106  2  D0 03                BNE     moncontinue
00E108  2  4C 7E E1             JMP     monreg          ;yes, ignore cold start
00E10B  2               ;
00E10B  2               moncontinue:
00E10B  2  85 4D                STA     vecbrkia        ;save vector for exit
00E10D  2  A9 3B E1             LDAW    monbrk          ;Supermon 816 intercepts...
00E110  2  8D 02 03             STA     vecbrki         ;BRK handler
00E113  2  E2 30                SHORTR                  ;8 bit registers
00E115  2  A2 3F                LDX     #vopsflag-reg_pbx
00E117  2               ;
00E117  2               _0000010:
00E117  2  74 10                STZ     reg_pbx,x       ;clear DP storage
00E119  2  CA                   DEX
00E11A  2  10 FB                BPL     _0000010
00E11C  2               ;
00E11C  2               ;
00E11C  2               ;	initialize register shadows...
00E11C  2               ;
00E11C  2  A9 30                LDA     #srinit
00E11E  2  85 13                STA     reg_srx         ;status register
00E120  2  C2 20                SLONGA                  ;16 bit .A
00E122  2  A9 FF 7F             LDAW    hwstack         ;top of hardware stack
00E125  2  1B                   TCS                     ;set SP
00E126  2  7B                   TDC                     ;get & save...
00E127  2  85 1C                STA     reg_dpx         ;DP register
00E129  2  A9 00 00             LDAW    0
00E12C  2  E2 20                SHORTA
00E12E  2  4B                   PHK
00E12F  2  68                   PLA                     ;capture PB &...
00E130  2  85 10                STA     reg_pbx         ;set
00E132  2  8B                   PHB
00E133  2  68                   PLA                     ;capture DB &...
00E134  2  85 1E                STA     reg_dbx         ;set
00E136  2               ;
00E136  2               ;
00E136  2               ;	print startup banner...
00E136  2               ;
00E136  2  F4 FE F0             PEA     mm_entry        ;"...ready..."
00E139  2  80 36                BRA     moncom
00E13B  2               ;
00E13B  2               ;================================================================================
00E13B  2               ;
00E13B  2               ;monbrk: SOFTWARE INTERRUPT INTERCEPT
00E13B  2               ;
00E13B  2               ;	------------------------------------------------------------------------
00E13B  2               ;	This is the entry point taken when a BRK instruction is executed.  It is
00E13B  2               ;	assumed that the BRK  handler has pushed the registers to the stack that
00E13B  2               ;	are not automatically pushed by the MPU in response to BRK.
00E13B  2               ;	------------------------------------------------------------------------
00E13B  2               ;
00E13B  2               monbrk:
00E13B  2  D8                   CLD                     ; VERIFY DECIMAL MODE IS OFF
00E13C  2  18                   CLC                     ;
00E13D  2  FB                   XCE                     ; SET NATIVE MODE
00E13E  2  8B                   PHB                     ;save DB
00E13F  2  0B                   PHD                     ;save DP
00E140  2  C2 20                SLONGA                  ;16 bit .A
00E142  2  48                   PHA
00E143  2  A9 00 00             LDAW    $0000           ;set DPR
00E146  2  5B                   TCD                     ;
00E147  2  68                   PLA
00E148  2  C2 30                LONGR                   ;store 16 bit registers
00E14A  2  85 14                STA     <reg_ax         ;.A
00E14C  2  86 16                STX     <reg_xx         ;.X
00E14E  2  84 18                STY     <reg_yx         ;.Y
00E150  2  68                   PLA                     ;get DP &...
00E151  2  85 1C                STA     <reg_dpx        ;store
00E153  2  E2 10                SHORTX
00E155  2  FA                   PLX                     ;get DB &...
00E156  2  86 1E                STX     <reg_dbx        ;store
00E158  2  FA                   PLX                     ;get SR &...
00E159  2  86 13                STX     <reg_srx        ;store
00E15B  2  68                   PLA                     ;get PC &...
00E15C  2  85 11                STA     <reg_pcx        ;store
00E15E  2  FA                   PLX                     ;get PB &...
00E15F  2  86 10                STX     <reg_pbx        ;store
00E161  2  C2 20                SLONGA
00E163  2  A9 FF 7F             LDAW    hwstack         ;top of hardware stack
00E166  2  1B                   TCS                     ;set SPR
00E167  2               ;        CLI                     ;reenable IRQs
00E167  2  78                   SEI                     ;Disable Interrupts
00E168  2  E2 20                SHORTA
00E16A  2  A9 00                LDA     #$00            ;set DBR
00E16C  2  48                   PHA
00E16D  2  AB                   PLB
00E16E  2  F4 F4 F0             PEA     mm_brk          ;"*BRK"
00E171  2               ;
00E171  2               ;================================================================================
00E171  2               ;
00E171  2               ;moncom: COMMON ENTRY POINT
00E171  2               ;
00E171  2               ;	--------------------------------------
00E171  2               ;	DO NOT directly call this entry point!
00E171  2               ;	--------------------------------------
00E171  2               ;
00E171  2               moncom:
00E171  2  20 7D E8             JSR     sprint          ;print heading
00E174  2  C2 20                SLONGA
00E176  2  3B                   TSC                     ;get SP &...
00E177  2  85 1A                STA     <reg_spx        ;store
00E179  2  C2 FF                REP     #%11111111      ;clear SR &...
00E17B  2  E2 30                SEP     #srinit         ;set default state
00E17D  2  38                   SEC                     ;see next
00E17E  2               ;
00E17E  2               ;================================================================================
00E17E  2               ;
00E17E  2               ;monreg: DISPLAY MPU REGISTERS
00E17E  2               ;
00E17E  2               ;	---------
00E17E  2               ;	syntax: R
00E17E  2               ;	---------
00E17E  2               ;
00E17E  2               monreg:
00E17E  2  B0 03                BCS     _0010010        ;okay to proceed
00E180  2               ;
00E180  2  4C 1B E2             JMP     monerr          ;error if called with a parm
00E183  2               ;
00E183  2               _0010010:
00E183  2  F4 21 F1             PEA     mm_regs
00E186  2  20 7D E8             JSR     sprint          ;display heading
00E189  2               ;
00E189  2               ;
00E189  2               ;	display program bank & counter...
00E189  2               ;
00E189  2  E2 20                SHORTA
00E18B  2  A5 10                LDA     <reg_pbx        ;PB
00E18D  2  20 53 E8             JSR     dpyhex          ;display as hex ASCII
00E190  2  20 78 E8             JSR     printspc        ;inter-field space
00E193  2               
00E193  2  C2 20                SLONGA
00E195  2  A5 11                LDA     <reg_pcx
00E197  2  E2 20                SHORTA
00E199  2  20 43 E8             JSR     dpyhexw         ;display PC
00E19C  2  A2 02                LDX     #2
00E19E  2  20 5D E8             JSR     multspc         ;inter-field spacing
00E1A1  2               ;
00E1A1  2               ;
00E1A1  2               ;	display SR in bitwise fashion...
00E1A1  2               ;
00E1A1  2  A6 13                LDX     <reg_srx        ;SR
00E1A3  2  A0 08                LDY     #s_bibyte       ;bits in a byte
00E1A5  2               ;
00E1A5  2               _0010020:
00E1A5  2  8A                   TXA                     ;remaining SR bits
00E1A6  2  0A                   ASL                     ;grab one of them
00E1A7  2  AA                   TAX                     ;save remainder
00E1A8  2  A9 30                LDA     #'0'            ;a clear bit but...
00E1AA  2  69 00                ADC     #0              ;adjust if set &...
00E1AC  2  20 71 FF             JSR     putcha          ;print
00E1AF  2  88                   DEY                     ;bit processed
00E1B0  2  D0 F3                BNE     _0010020        ;do another
00E1B2  2               ;
00E1B2  2               ;
00E1B2  2               ;	display .C, .X, .Y, SP & DP...
00E1B2  2               ;
00E1B2  2               _0010030:
00E1B2  2  20 78 E8             JSR     printspc        ;spacing
00E1B5  2  C2 20                SLONGA
00E1B7  2  B9 14 00             LDA     reg_ax,y        ;get register value
00E1BA  2  E2 20                SHORTA
00E1BC  2  20 43 E8             JSR     dpyhexw         ;convert & display
00E1BF  2               
00E1BF  2               ;         .rept s_word
00E1BF  2  C8                   INY
00E1C0  2  C8                   INY
00E1C1  2               ;         .endr
00E1C1  2               
00E1C1  2  C0 08                CPY     #reg_dbx-reg_ax-2
00E1C3  2  90 ED                BCC     _0010030        ;next
00E1C5  2               
00E1C5  2  F4 4A F1             PEA     mm_regs1
00E1C8  2  20 7D E8             JSR     sprint          ;display heading
00E1CB  2  C2 20                SLONGA
00E1CD  2  A5 1C                LDA     <reg_dpx        ;get register value
00E1CF  2  E2 20                SHORTA
00E1D1  2  20 43 E8             JSR     dpyhexw         ;convert & display
00E1D4  2               ;
00E1D4  2               ;
00E1D4  2               ;	display DB...
00E1D4  2               ;
00E1D4  2  20 78 E8             JSR     printspc        ;more spacing
00E1D7  2  A5 1E                LDA     <reg_dbx        ;get DB &...
00E1D9  2  20 53 E8             JSR     dpyhex          ;display it
00E1DC  2               ;
00E1DC  2               ;================================================================================
00E1DC  2               ;
00E1DC  2               ;monce: COMMAND EXECUTIVE
00E1DC  2               ;
00E1DC  2               monce:
00E1DC  2  E2 20                SHORTA
00E1DE  2  A9 00                LDA     #0              ;default buffer index
00E1E0  2               ;
00E1E0  2               moncea:
00E1E0  2  E2 30                SHORTR                  ;alternate entry point
00E1E2  2  85 3D                STA     ibufidx         ;(re)set buffer index
00E1E4  2  F4 1D F1             PEA     mm_prmpt
00E1E7  2  20 7D E8             JSR     sprint          ;display input prompt
00E1EA  2  20 8A EC             JSR     input           ;await some input
00E1ED  2               ;
00E1ED  2               _0020010:
00E1ED  2  20 E0 EC             JSR     getcharc        ;read from buffer
00E1F0  2  F0 EA                BEQ     monce           ;terminator, just loop
00E1F2  2               ;
00E1F2  2  C9 20                CMP     #a_blank
00E1F4  2  F0 F7                BEQ     _0020010        ;strip leading blanks
00E1F6  2               ;
00E1F6  2  A2 0C                LDX     #n_mpctab-1     ;number of primary commands
00E1F8  2               ;
00E1F8  2               _0020020:
00E1F8  2  DD 98 ED             CMP     mpctab,x        ;search primary command list
00E1FB  2  D0 0E                BNE     _0020030
00E1FD  2               ;
00E1FD  2  8A                   TXA                     ;get index
00E1FE  2  0A                   ASL                     ;double for offset
00E1FF  2  AA                   TAX
00E200  2  C2 20                SLONGA
00E202  2  BD A5 ED             LDA     mpcextab,x      ;command address -1
00E205  2  48                   PHA                     ;prime the stack
00E206  2  E2 20                SHORTA
00E208  2  4C 2C EB             JMP     getparm         ;evaluate parm & execute command
00E20B  2               ;
00E20B  2               _0020030:
00E20B  2  CA                   DEX
00E20C  2  10 EA                BPL     _0020020        ;continue searching primary commands
00E20E  2               ;
00E20E  2  A2 03                LDX     #n_radix-1      ;number of radices
00E210  2               ;
00E210  2               _0020040:
00E210  2  DD D3 ED             CMP     radxtab,x       ;search conversion command list
00E213  2  D0 03                BNE     _0020050
00E215  2               ;
00E215  2  4C 63 E6             JMP     monenv          ;convert & display parameter
00E218  2               ;
00E218  2               _0020050:
00E218  2  CA                   DEX
00E219  2  10 F5                BPL     _0020040
00E21B  2               ;
00E21B  2               ;================================================================================
00E21B  2               ;
00E21B  2               ;monerr: COMMON ERROR HANDLER
00E21B  2               ;
00E21B  2               monerr:
00E21B  2  E2 30                SHORTR                  ;8 bit registers
00E21D  2               ;
00E21D  2               monerraa:
00E21D  2  20 2A E8             JSR     dpyerr          ;indicate an error &...
00E220  2  80 BA                BRA     monce           ;return to input loop
00E222  2               
00E222  2               ;
00E222  2               ;================================================================================
00E222  2               ;
00E222  2               ;monasc: ASSEMBLE CODE
00E222  2               ;
00E222  2               ;	-----------------------------------------------------------------------
00E222  2               ;	syntax: A <addr> <mnemonic> [<argument>]
00E222  2               ;
00E222  2               ;	After a line of code has been successfully assembled it will be disass-
00E222  2               ;	embled & displayed,  & the monitor will prompt with the next address to
00E222  2               ;	which code may be assembled.
00E222  2               ;	-----------------------------------------------------------------------
00E222  2               ;
00E222  2               monasc:
00E222  2  90 03                BCC     _0030020        ;assembly address entered
00E224  2               ;
00E224  2               _0030010:
00E224  2  4C 1B E2             JMP     monerr          ;terminate w/error
00E227  2               ;
00E227  2               ;
00E227  2               ;	evaluate assembly address...
00E227  2               ;
00E227  2               _0030020:
00E227  2  20 1C EB             JSR     facasize        ;check address...
00E22A  2  C9 04                CMP     #s_dword        ;range
00E22C  2  B0 F6                BCS     _0030010        ;out of range - error
00E22E  2               ;
00E22E  2  20 FE EA             JSR     facaddra        ;store assembly address
00E231  2               ;
00E231  2               ;
00E231  2               ;	initialize workspace...
00E231  2               ;
00E231  2  A2 1F                LDX     #s_auxbuf-s_byte
00E233  2               ;
00E233  2               _0030030:
00E233  2  9E 46 02             STZ     auxbuf,x        ;clear addressing mode buffer
00E236  2  CA                   DEX
00E237  2  D0 FA                BNE     _0030030
00E239  2               ;
00E239  2  A9 20                LDA     #a_blank
00E23B  2  8D 46 02             STA     auxbuf          ;preamble placeholder
00E23E  2  20 82 EA             JSR     clroper         ;clear operand
00E241  2  64 3C                STZ     auxbufix        ;reset addressing mode index
00E243  2  64 4C                STZ     flimflag        ;clear forced long immediate
00E245  2  64 46                STZ     mnepck          ;clear encoded...
00E247  2  64 47                STZ     mnepck+s_byte   ;mnemonic workspace
00E249  2  64 4F                STZ     vopsflag        ;clear 8/16 or relative flag
00E24B  2               ;
00E24B  2               ;
00E24B  2               ;	encode mnemonic...
00E24B  2               ;
00E24B  2  A0 03                LDY     #s_mnemon       ;expected mnemonic size
00E24D  2               ;
00E24D  2               _0030040:
00E24D  2  20 7B EC             JSR     getcharw        ;get from buffer wo/whitespace
00E250  2  D0 0A                BNE     _0030060        ;gotten
00E252  2               ;
00E252  2  C0 03                CPY     #s_mnemon       ;any input at all?
00E254  2  90 03                BCC     _0030050        ;yes
00E256  2               ;
00E256  2  4C DC E1             JMP     monce           ;no, abort further assembly
00E259  2               ;
00E259  2               _0030050:
00E259  2  4C F9 E3             JMP     monasc10        ;incomplete mnemonic - error
00E25C  2               ;
00E25C  2               _0030060:
00E25C  2  38                   SEC
00E25D  2  E9 3F                SBC     #a_mnecvt       ;ASCII to binary factor
00E25F  2  A2 05                LDX     #n_shfenc       ;shifts required to encode
00E261  2               ;
00E261  2               _0030070:
00E261  2  4A                   LSR                     ;shift out a bit...
00E262  2  66 47                ROR     mnepck+s_byte   ;into...
00E264  2  66 46                ROR     mnepck          ;encoded mnemonic
00E266  2  CA                   DEX
00E267  2  D0 F8                BNE     _0030070        ;next bit
00E269  2               ;
00E269  2  88                   DEY
00E26A  2  D0 E1                BNE     _0030040        ;get next char
00E26C  2               ;
00E26C  2               ;
00E26C  2               ;	test for copy instruction...
00E26C  2               ;	------------------------------------------------------------------------
00E26C  2               ;	The MVN & MVP instructions accept two operands & hence have an irregular
00E26C  2               ;	syntax.  Therefore, special handling is necessary to assemble either of
00E26C  2               ;	these instructions.
00E26C  2               ;
00E26C  2               ;	The official WDC syntax has the programmer entering a pair of 24 bit ad-
00E26C  2               ;	dresses as operands, with the assembler isolating bits 16-23 to	use as
00E26C  2               ;	operands.  This formality has been dispensed with in this monitor & the
00E26C  2               ;	operands are expected to be 8 bit bank values.
00E26C  2               ;	------------------------------------------------------------------------
00E26C  2               ;
00E26C  2  C2 20                SLONGA                  ;16 bit load
00E26E  2  A5 46                LDA     mnepck          ;packed menmonic
00E270  2  A2 54                LDX     #opc_mvn        ;MVN opcode
00E272  2  C9 DC 7D             CMPW    mne_mvn         ;is it MVN?
00E275  2  F0 07                BEQ     monasc01        ;yes
00E277  2               ;
00E277  2  A2 44                LDX     #opc_mvp        ;MVP opcode
00E279  2  C9 DC 8D             CMPW    mne_mvp         ;is it MVP?
00E27C  2  D0 30                BNE     monasc02        ;no
00E27E  2               ;
00E27E  2               ;
00E27E  2               ;	assemble copy instruction...
00E27E  2               ;
00E27E  2               monasc01:
00E27E  2  86 48                STX     opcode          ;store relevant opcode
00E280  2  E2 20                SHORTA
00E282  2  20 8A EB             JSR     instdata        ;get instruction data
00E285  2  86 4B                STX     eopsize         ;effective operand size
00E287  2  E8                   INX
00E288  2  86 44                STX     instsize        ;instruction size
00E28A  2  A2 01                LDX     #s_oper-s_word  ;operand index
00E28C  2  86 4A                STX     xrtemp          ;set it
00E28E  2               ;
00E28E  2               _0040010:
00E28E  2  20 96 E8             JSR     ascbin          ;evaluate bank number
00E291  2  B0 50                BCS     monasc04        ;conversion error
00E293  2               ;
00E293  2  F0 4E                BEQ     monasc04        ;nothing returned - error
00E295  2               ;
00E295  2  20 1C EB             JSR     facasize        ;bank must be...
00E298  2  C9 02                CMP     #s_word         ;8 bits
00E29A  2  B0 47                BCS     monasc04        ;it isn't - error
00E29C  2               ;
00E29C  2  A5 25                LDA     faca            ;bank
00E29E  2  A6 4A                LDX     xrtemp          ;operand index
00E2A0  2  95 39                STA     operand,x       ;store
00E2A2  2  C6 4A                DEC     xrtemp          ;index=index-1
00E2A4  2  10 E8                BPL     _0040010        ;get destination bank
00E2A6  2               ;
00E2A6  2  20 1B EC             JSR     getcharr        ;should be no more input
00E2A9  2  D0 38                BNE     monasc04        ;there is - error
00E2AB  2               ;
00E2AB  2  4C A9 E3             JMP     monasc08        ;finish MVN/MVP assembly
00E2AE  2               ;
00E2AE  2               ;
00E2AE  2               ;	continue with normal assembly...
00E2AE  2               ;
00E2AE  2               monasc02:
00E2AE  2  E2 20                SHORTA                  ;back to 8 bits
00E2B0  2               ;
00E2B0  2               monasc03:
00E2B0  2  20 7B EC             JSR     getcharw        ;get next char
00E2B3  2  F0 3D                BEQ     monasc06        ;EOI, no argument
00E2B5  2               ;
00E2B5  2  C9 21                CMP     #amp_flim
00E2B7  2  D0 0A                BNE     _0050010        ;no forced long immediate
00E2B9  2               ;
00E2B9  2  A5 4C                LDA     flimflag        ;FLIM already set?
00E2BB  2  D0 26                BNE     monasc04        ;yes - error
00E2BD  2               ;
00E2BD  2  A9 C0                LDA     #flimmask
00E2BF  2  85 4C                STA     flimflag        ;set flag &...
00E2C1  2  80 ED                BRA     monasc03        ;get next char
00E2C3  2               ;
00E2C3  2               _0050010:
00E2C3  2  C9 23                CMP     #amp_imm        ;immediate mode?
00E2C5  2  F0 08                BEQ     _0050020        ;yes
00E2C7  2               ;
00E2C7  2  C9 28                CMP     #amp_ind        ;indirect mode?
00E2C9  2  F0 04                BEQ     _0050020        ;yes
00E2CB  2               ;
00E2CB  2  C9 5B                CMP     #amp_indl       ;indirect long mode?
00E2CD  2  D0 07                BNE     _0050030        ;no
00E2CF  2               ;
00E2CF  2               _0050020:
00E2CF  2  8D 46 02             STA     auxbuf          ;set addressing mode preamble
00E2D2  2  E6 3C                INC     auxbufix        ;bump aux buffer index &...
00E2D4  2  80 02                BRA     _0050040        ;evaluate operand
00E2D6  2               ;
00E2D6  2               _0050030:
00E2D6  2  C6 3D                DEC     ibufidx         ;position back to char
00E2D8  2               ;
00E2D8  2               _0050040:
00E2D8  2  20 96 E8             JSR     ascbin          ;evaluate operand
00E2DB  2  D0 09                BNE     monasc05        ;evaluated
00E2DD  2               ;
00E2DD  2  B0 04                BCS     monasc04        ;conversion error
00E2DF  2               ;
00E2DF  2  A5 3C                LDA     auxbufix        ;no operand...any preamble?
00E2E1  2  F0 0F                BEQ     monasc06        ;no, syntax is okay so far
00E2E3  2               ;
00E2E3  2               monasc04:
00E2E3  2  4C F9 E3             JMP     monasc10        ;abort w/error
00E2E6  2               ;
00E2E6  2               monasc05:
00E2E6  2  20 1C EB             JSR     facasize        ;size operand
00E2E9  2  C9 04                CMP     #s_dword        ;max is 24 bits
00E2EB  2  B0 F6                BCS     monasc04        ;too big
00E2ED  2               ;
00E2ED  2  85 4B                STA     eopsize         ;save operand size
00E2EF  2  20 12 EB             JSR     facaoper        ;store operand
00E2F2  2               ;
00E2F2  2               monasc06:
00E2F2  2  C6 3D                DEC     ibufidx         ;back to last char
00E2F4  2  A6 3C                LDX     auxbufix        ;mode buffer index
00E2F6  2  D0 01                BNE     _0060010        ;preamble in buffer
00E2F8  2               ;
00E2F8  2  E8                   INX                     ;step past preamble position
00E2F9  2               ;
00E2F9  2               _0060010:
00E2F9  2  20 E0 EC             JSR     getcharc        ;get a char w/forced UC
00E2FC  2  F0 0A                BEQ     _0060030        ;EOI
00E2FE  2               ;
00E2FE  2  E0 20                CPX     #s_auxbuf       ;mode buffer full?
00E300  2  B0 E1                BCS     monasc04        ;yes, too much input
00E302  2               ;
00E302  2               _0060020:
00E302  2  9D 46 02             STA     auxbuf,x        ;store for comparison
00E305  2  E8                   INX
00E306  2  D0 F1                BNE     _0060010
00E308  2               ;
00E308  2               ;
00E308  2               ;	evaluate mnemonic...
00E308  2               ;
00E308  2               _0060030:
00E308  2  A2 5B                LDX     #n_mnemon-1     ;starting mnemonic index
00E30A  2               ;
00E30A  2               monasc07:
00E30A  2  8A                   TXA                     ;convert index...
00E30B  2  0A                   ASL                     ;to offset
00E30C  2  A8                   TAY                     ;now mnemonic table index
00E30D  2  C2 20                SLONGA                  ;16 bit compare
00E30F  2  B9 E0 ED             LDA     mnetab,y        ;get mnemonic from table
00E312  2  C5 46                CMP     mnepck          ;compare to entered mnemonic
00E314  2  E2 20                SHORTA                  ;back to 8 bits
00E316  2  F0 05                BEQ     _0070020        ;match
00E318  2               ;
00E318  2               _0070010:
00E318  2  CA                   DEX                     ;try next mnemonic
00E319  2  30 C8                BMI     monasc04        ;unknown mnemonic - error
00E31B  2               ;
00E31B  2  80 ED                BRA     monasc07        ;keep going
00E31D  2               ;
00E31D  2               _0070020:
00E31D  2  86 46                STX     mnepck          ;save mnemonic index
00E31F  2  8A                   TXA
00E320  2  A2 00                LDX     #0              ;trial opcode
00E322  2               ;
00E322  2               _0070030:
00E322  2  DD 98 EE             CMP     mnetabix,x      ;search index table...
00E325  2  F0 05                BEQ     _0070050        ;for a match
00E327  2               ;
00E327  2               _0070040:
00E327  2  E8                   INX                     ;keep going until we...
00E328  2  D0 F8                BNE     _0070030        ;search entire table
00E32A  2               ;
00E32A  2  80 B7                BRA     monasc04        ;this shouldn't happen!
00E32C  2               ;
00E32C  2               ;	---------------------------------------------------------------------
00E32C  2               ;	If the mnemonic index table search fails then there is a coding error
00E32C  2               ;	somewhere, as every entry in the mnemonic table is supposed to have a
00E32C  2               ;	matching cardinal index.
00E32C  2               ;	---------------------------------------------------------------------
00E32C  2               ;
00E32C  2               ;
00E32C  2               ;	evaluate addressing mode...
00E32C  2               ;
00E32C  2               _0070050:
00E32C  2  86 48                STX     opcode          ;save trial opcode
00E32E  2  20 8A EB             JSR     instdata        ;get related instruction data
00E331  2  85 4F                STA     vopsflag        ;save 8/16 or relative flag
00E333  2  86 4D                STX     iopsize         ;operand size
00E335  2  E8                   INX
00E336  2  86 44                STX     instsize        ;instruction size
00E338  2  A6 48                LDX     opcode          ;recover trial opcode
00E33A  2  98                   TYA                     ;addressing mode
00E33B  2  0A                   ASL                     ;create table index
00E33C  2  A8                   TAY
00E33D  2  C2 20                SLONGA
00E33F  2  B9 9C F0             LDA     ms_lutab,y      ;mode lookup table
00E342  2  85 22                STA     addrb           ;set pointer
00E344  2  E2 20                SHORTA
00E346  2  A0 00                LDY     #0
00E348  2               ;
00E348  2               _0070060:
00E348  2  B1 22                LDA     (addrb),y       ;table addressing mode
00E34A  2  D9 46 02             CMP     auxbuf,y        ;entered addressing mode
00E34D  2  F0 04                BEQ     _0070080        ;okay so far
00E34F  2               ;
00E34F  2               _0070070:
00E34F  2  A5 46                LDA     mnepck          ;reload mnemonic index
00E351  2  80 D4                BRA     _0070040        ;wrong opcode for addresing mode
00E353  2               ;
00E353  2               _0070080:
00E353  2  09 00                ORA     #0              ;last char the terminator?
00E355  2  F0 03                BEQ     _0070090        ;yes, evaluate operand
00E357  2               ;
00E357  2  C8                   INY
00E358  2  80 EE                BRA     _0070060        ;keep testing
00E35A  2               ;
00E35A  2               ;
00E35A  2               ;	evaluate operand...
00E35A  2               ;
00E35A  2               _0070090:
00E35A  2  A5 4B                LDA     eopsize         ;entered operand size
00E35C  2  D0 06                BNE     _0070100        ;non-zero
00E35E  2               ;
00E35E  2  05 4D                ORA     iopsize         ;instruction operand size
00E360  2  D0 ED                BNE     _0070070        ;wrong opcode - keep trying
00E362  2               ;
00E362  2  80 45                BRA     monasc08        ;assemble instruction
00E364  2               ;
00E364  2               _0070100:
00E364  2  24 4F                BIT     vopsflag        ;is this a branch?
00E366  2  70 3A                BVS     _0070160        ;yes, evaluate
00E368  2               ;
00E368  2  A5 4D                LDA     iopsize         ;instruction operand size
00E36A  2  24 4F                BIT     vopsflag        ;variable size operand allowed?
00E36C  2  30 15                BMI     _0070130        ;yes
00E36E  2               ;
00E36E  2  24 4C                BIT     flimflag        ;was forced immediate set?
00E370  2  10 03                BPL     _0070110        ;no
00E372  2               ;
00E372  2  4C F9 E3             JMP     monasc10        ;yes - error
00E375  2               ;
00E375  2               _0070110:
00E375  2  C5 4B                CMP     eopsize         ;entered operand size
00E377  2  90 D6                BCC     _0070070        ;operand too big
00E379  2               ;
00E379  2  85 4B                STA     eopsize         ;new operand size
00E37B  2  80 2C                BRA     monasc08        ;assemble, otherwise...
00E37D  2               ;
00E37D  2               _0070120:
00E37D  2  C5 4B                CMP     eopsize         ;exact size match required
00E37F  2  D0 CE                BNE     _0070070        ;mismatch - wrong opcode
00E381  2               ;
00E381  2  80 26                BRA     monasc08        ;assemble
00E383  2               ;
00E383  2               ;
00E383  2               ;	process variable size immediate mode operand...
00E383  2               ;
00E383  2               _0070130:
00E383  2  A6 4B                LDX     eopsize         ;entered operand size
00E385  2  E0 03                CPX     #s_xword        ;check size
00E387  2  B0 70                BCS     monasc10        ;too big - error
00E389  2               ;
00E389  2  24 4C                BIT     flimflag        ;forced long immediate?
00E38B  2  10 06                BPL     _0070140        ;no
00E38D  2               ;
00E38D  2  A2 02                LDX     #s_word         ;promote operand size to...
00E38F  2  86 4B                STX     eopsize         ;16 bits
00E391  2  80 08                BRA     _0070150
00E393  2               ;
00E393  2               _0070140:
00E393  2  E0 02                CPX     #s_word         ;16 bits?
00E395  2  D0 04                BNE     _0070150        ;no
00E397  2               ;
00E397  2  A0 C0                LDY     #flimmask       ;yes so force long...
00E399  2  84 4C                STY     flimflag        ;immediate disassembly
00E39B  2               ;
00E39B  2               _0070150:
00E39B  2  1A                   INA                     ;new instruction operand size
00E39C  2  C5 4B                CMP     eopsize         ;compare against operand size
00E39E  2  90 AF                BCC     _0070070        ;mismatch - can't assemble
00E3A0  2               ;
00E3A0  2  80 07                BRA     monasc08        ;okay, assemble
00E3A2  2               ;
00E3A2  2               ;
00E3A2  2               ;	process relative branch...
00E3A2  2               ;
00E3A2  2               _0070160:
00E3A2  2  20 D6 EB             JSR     targoff         ;compute branch offset
00E3A5  2  B0 52                BCS     monasc10        ;branch out of range
00E3A7  2               ;
00E3A7  2  85 4B                STA     eopsize         ;effective operand size
00E3A9  2               ;
00E3A9  2               ;
00E3A9  2               ;	assemble instruction...
00E3A9  2               ;
00E3A9  2               monasc08:
00E3A9  2  A5 48                LDA     opcode          ;opcode
00E3AB  2  87 1F                STAIL   addra           ;store at assembly address
00E3AD  2  A6 4B                LDX     eopsize         ;any operand to process?
00E3AF  2  F0 09                BEQ     _0080020        ;no
00E3B1  2               ;
00E3B1  2  9B                   TXY                     ;also storage offset
00E3B2  2               ;
00E3B2  2               _0080010:
00E3B2  2  CA                   DEX
00E3B3  2  B5 39                LDA     operand,x       ;get operand byte &...
00E3B5  2  97 1F                STAILY  addra           ;poke into memory
00E3B7  2  88                   DEY
00E3B8  2  D0 F8                BNE     _0080010        ;next
00E3BA  2               ;
00E3BA  2               _0080020:
00E3BA  2  A9 0D                LDA     #a_cr
00E3BC  2  20 71 FF             JSR     putcha          ;return to left margin
00E3BF  2  A9 41                LDA     #asmprfx        ;assembly prefix
00E3C1  2  20 E6 E6             JSR     dpycodaa        ;disassemble & display
00E3C4  2               ;
00E3C4  2               ;
00E3C4  2               ;	prompt for next instruction...
00E3C4  2               ;
00E3C4  2               monasc09:
00E3C4  2  A9 20                LDA     #a_blank
00E3C6  2  A2 08                LDX     #ascprmct-1
00E3C8  2               ;
00E3C8  2               _0090010:
00E3C8  2  9D 00 02             STA     ibuffer,x       ;prepare buffer for...
00E3CB  2  CA                   DEX                     ;next instruction
00E3CC  2  10 FA                BPL     _0090010
00E3CE  2               ;
00E3CE  2  A9 41                LDA     #asmprfx        ;assemble code...
00E3D0  2  8D 00 02             STA     ibuffer         ;prompt prefix
00E3D3  2  A5 21                LDA     addra+s_word    ;next instruction address bank
00E3D5  2  20 EE E9             JSR     binhex          ;convert to ASCII
00E3D8  2  8D 02 02             STA     ibuffer+apadrbkh;store MSN in buffer
00E3DB  2  8E 03 02             STX     ibuffer+apadrbkl;store LSN in buffer
00E3DE  2  A5 20                LDA     addra+s_byte    ;next instruction address MSB
00E3E0  2  20 EE E9             JSR     binhex
00E3E3  2  8D 04 02             STA     ibuffer+apadrmbh
00E3E6  2  8E 05 02             STX     ibuffer+apadrmbl
00E3E9  2  A5 1F                LDA     addra           ;next instruction address LSB
00E3EB  2  20 EE E9             JSR     binhex
00E3EE  2  8D 06 02             STA     ibuffer+apadrlbh
00E3F1  2  8E 07 02             STX     ibuffer+apadrlbl
00E3F4  2  A9 09                LDA     #ascprmct       ;effective input count
00E3F6  2  4C E0 E1             JMP     moncea          ;reenter input loop
00E3F9  2               ;
00E3F9  2               ;
00E3F9  2               ;	process assembly error...
00E3F9  2               ;
00E3F9  2               monasc10:
00E3F9  2  20 2A E8             JSR     dpyerr          ;indicate error &...
00E3FC  2  80 C6                BRA     monasc09        ;prompt w/same assembly address
00E3FE  2               ;
00E3FE  2               ;================================================================================
00E3FE  2               ;
00E3FE  2               ;mondsc: DISASSEMBLE CODE
00E3FE  2               ;
00E3FE  2               ;	-----------------------------
00E3FE  2               ;	syntax: D [<addr1> [<addr2>]]
00E3FE  2               ;	-----------------------------
00E3FE  2               ;
00E3FE  2               mondsc:
00E3FE  2  B0 11                BCS     _0100010        ;no parameters
00E400  2               ;
00E400  2  64 4C                STZ     flimflag        ;reset to 8 bit mode
00E402  2  20 1C EB             JSR     facasize        ;check starting...
00E405  2  C9 04                CMP     #s_dword        ;address
00E407  2  B0 46                BCS     _0100050        ;out of range - error
00E409  2               ;
00E409  2  20 FE EA             JSR     facaddra        ;copy starting address
00E40C  2  20 2C EB             JSR     getparm         ;get ending address
00E40F  2  90 17                BCC     _0100020        ;gotten
00E411  2               ;
00E411  2               _0100010:
00E411  2  20 01 EA             JSR     clrfaca         ;clear accumulator
00E414  2  C2 20                SLONGA
00E416  2  18                   CLC
00E417  2  A5 1F                LDA     addra           ;starting address
00E419  2  69 15 00             ADCW    n_dbytes        ;default bytes
00E41C  2  85 25                STA     faca            ;effective ending address
00E41E  2  E2 20                SHORTA
00E420  2  A5 21                LDA     addra+s_word    ;starting bank
00E422  2  69 00                ADC     #0
00E424  2  85 27                STA     faca+s_word     ;effective ending bank
00E426  2  B0 27                BCS     _0100050        ;end address > $FFFFFF
00E428  2               ;
00E428  2               _0100020:
00E428  2  20 1C EB             JSR     facasize        ;check ending...
00E42B  2  C9 04                CMP     #s_dword        ;address
00E42D  2  B0 20                BCS     _0100050        ;out of range - error
00E42F  2               ;
00E42F  2  20 08 EB             JSR     facaddrb        ;set ending address
00E432  2  20 2C EB             JSR     getparm         ;check for excess input
00E435  2  90 18                BCC     _0100050        ;present - error
00E437  2               ;
00E437  2  20 6D EA             JSR     calccnt         ;calculate bytes
00E43A  2  90 13                BCC     _0100050        ;end < start
00E43C  2               ;
00E43C  2               _0100030:
00E43C  2  20 F0 EC             JSR     teststop        ;test for display stop
00E43F  2  B0 0B                BCS     _0100040        ;stopped
00E441  2               ;
00E441  2  20 68 E8             JSR     newline         ;next line
00E444  2  20 E4 E6             JSR     dpycod          ;disassemble & display
00E447  2  20 B4 EA             JSR     decdcnt         ;decrement byte count
00E44A  2  90 F0                BCC     _0100030        ;not done
00E44C  2               ;
00E44C  2               _0100040:
00E44C  2  4C DC E1             JMP     monce           ;back to main loop
00E44F  2               ;
00E44F  2               _0100050:
00E44F  2  4C 1B E2             JMP     monerr          ;address range error
00E452  2               ;
00E452  2               ;================================================================================
00E452  2               ;
00E452  2               ;monjmp: EXECUTE CODE
00E452  2               ;
00E452  2               ;	-------------------------------------------------------------
00E452  2               ;	syntax: G [<dp>]
00E452  2               ;
00E452  2               ;	If no address is specified, the current values in the PB & PC
00E452  2               ;	shadow registers are used.
00E452  2               ;	-------------------------------------------------------------
00E452  2               ;
00E452  2               monjmp:
00E452  2  20 BF EB             JSR     setxaddr        ;set execution address
00E455  2  B0 29                BCS     monjmpab        ;out of range - error
00E457  2               ;
00E457  2  20 2C EB             JSR     getparm         ;check for excess input
00E45A  2  90 24                BCC     monjmpab        ;too much input - error
00E45C  2               ;
00E45C  2  C2 20                SLONGA                  ;16 bit .A
00E45E  2  A5 1A                LDA     reg_spx
00E460  2  1B                   TCS                     ;restore SP
00E461  2               ;
00E461  2               monjmpaa:
00E461  2  E2 20                SHORTA
00E463  2  A5 10                LDA     reg_pbx
00E465  2  48                   PHA                     ;restore PB
00E466  2  C2 20                SLONGA
00E468  2  A5 11                LDA     reg_pcx
00E46A  2  48                   PHA                     ;restore PC
00E46B  2  E2 20                SHORTA
00E46D  2  A5 13                LDA     reg_srx
00E46F  2  48                   PHA                     ;restore SR
00E470  2  A5 1E                LDA     reg_dbx
00E472  2  48                   PHA
00E473  2  AB                   PLB                     ;restore DB
00E474  2  C2 30                LONGR
00E476  2  A5 1C                LDA     reg_dpx
00E478  2  5B                   TCD                     ;restore DP
00E479  2  A5 14                LDA     reg_ax          ;restore .C
00E47B  2  A6 16                LDX     reg_xx          ;restore .X
00E47D  2  A4 18                LDY     reg_yx          ;restore .Y
00E47F  2  40                   RTI                     ;execute code
00E480  2               ;
00E480  2               monjmpab:
00E480  2  4C 1B E2             JMP     monerr          ;error
00E483  2               ;
00E483  2               ;================================================================================
00E483  2               ;
00E483  2               ;monjsr: EXECUTE CODE AS SUBROUTINE
00E483  2               ;
00E483  2               ;	------------------------------------------------------------
00E483  2               ;	syntax: J [<dp>]
00E483  2               ;
00E483  2               ;	If no address is specified the current values in the PB & PC
00E483  2               ;	shadow registers are used.   An RTS at the end of the called
00E483  2               ;	subroutine will return control to the monitor  provided  the
00E483  2               ;	stack remains in balance.
00E483  2               ;	------------------------------------------------------------
00E483  2               ;
00E483  2               monjsr:
00E483  2  20 BF EB             JSR     setxaddr        ;set execution address
00E486  2  B0 F8                BCS     monjmpab        ;out of range - error
00E488  2               ;
00E488  2  20 2C EB             JSR     getparm         ;check for excess input
00E48B  2  90 F3                BCC     monjmpab        ;too much input - error
00E48D  2               ;
00E48D  2  C2 20                SLONGA
00E48F  2  A5 1A                LDA     reg_spx
00E491  2  1B                   TCS                     ;restore SP &...
00E492  2  20 61 E4             JSR     monjmpaa        ;call subroutine
00E495  2  08                   PHP                     ;push SR
00E496  2  C2 30                LONGR
00E498  2  85 14                STA     reg_ax          ;save...
00E49A  2  86 16                STX     reg_xx          ;register...
00E49C  2  84 18                STY     reg_yx          ;returns
00E49E  2  E2 10                SHORTX                  ;8 bit .X & .Y
00E4A0  2  FA                   PLX                     ;get & save...
00E4A1  2  86 13                STX     reg_srx         ;return SR
00E4A3  2  3B                   TSC                     ;get & save...
00E4A4  2  85 1A                STA     reg_spx         ;return SP
00E4A6  2  7B                   TDC                     ;get & save...
00E4A7  2  85 1C                STA     reg_dpx         ;DP pointer
00E4A9  2  E2 20                SHORTA                  ;8 bit .A
00E4AB  2  4B                   PHK                     ;get &...
00E4AC  2  68                   PLA                     ;save...
00E4AD  2  85 10                STA     reg_pbx         ;return PB
00E4AF  2  8B                   PHB                     ;get &...
00E4B0  2  68                   PLA                     ;save...
00E4B1  2  85 1E                STA     reg_dbx         ;return DB
00E4B3  2  F4 56 F1             PEA     mm_rts          ;"*RET"
00E4B6  2  4C 71 E1             JMP     moncom          ;return to monitor
00E4B9  2               ;
00E4B9  2               ;================================================================================
00E4B9  2               ;
00E4B9  2               ;monchm: CHANGE and/or DUMP MEMORY
00E4B9  2               ;
00E4B9  2               ;	--------------------------------------------
00E4B9  2               ;	syntax: > [<addr> <operand> [<operand>]...]
00E4B9  2               ;
00E4B9  2               ;	> <addr> without operands will dump 16 bytes
00E4B9  2               ;	of memory, starting at <addr>.
00E4B9  2               ;	--------------------------------------------
00E4B9  2               ;
00E4B9  2               monchm:
00E4B9  2  B0 23                BCS     _0110030        ;no address given - quit
00E4BB  2               ;
00E4BB  2  20 1C EB             JSR     facasize        ;size address
00E4BE  2  C9 04                CMP     #s_dword
00E4C0  2  B0 1F                BCS     _0110040        ;address out of range - error
00E4C2  2               ;
00E4C2  2  20 FE EA             JSR     facaddra        ;set starting address
00E4C5  2  20 2F EC             JSR     getpat          ;evaluate change pattern
00E4C8  2  90 04                BCC     _0110010        ;entered
00E4CA  2               ;
00E4CA  2  10 0C                BPL     _0110020        ;not entered
00E4CC  2               ;
00E4CC  2  80 13                BRA     _0110040        ;evaluation error
00E4CE  2               ;
00E4CE  2               _0110010:
00E4CE  2  88                   DEY                     ;next byte
00E4CF  2  30 07                BMI     _0110020        ;done
00E4D1  2               ;
00E4D1  2  B9 46 02             LDA     auxbuf,y        ;write pattern...
00E4D4  2  97 1F                STAILY  addra           ;to memory
00E4D6  2  80 F6                BRA     _0110010        ;next
00E4D8  2               ;
00E4D8  2               _0110020:
00E4D8  2  20 68 E8             JSR     newline         ;next line
00E4DB  2  20 F6 E7             JSR     dpymem          ;regurgitate changes
00E4DE  2               ;
00E4DE  2               _0110030:
00E4DE  2  4C DC E1             JMP     monce           ;back to command loop
00E4E1  2               ;
00E4E1  2               _0110040:
00E4E1  2  4C 1B E2             JMP     monerr          ;goto error handler
00E4E4  2               ;
00E4E4  2               ;================================================================================
00E4E4  2               ;
00E4E4  2               ;moncmp: COMPARE MEMORY
00E4E4  2               ;
00E4E4  2               ;	-----------------------------
00E4E4  2               ;	syntax: C <start> <end> <ref>
00E4E4  2               ;	-----------------------------
00E4E4  2               ;
00E4E4  2               moncmp:
00E4E4  2  B0 26                BCS     _0120030        ;start not given - quit
00E4E6  2               ;
00E4E6  2  20 D8 EA             JSR     enddest         ;get end & reference addresses
00E4E9  2  B0 24                BCS     _0120040        ;range or other error
00E4EB  2               ;
00E4EB  2  64 4A                STZ     xrtemp          ;column counter
00E4ED  2               ;
00E4ED  2               _0120010:
00E4ED  2  20 F0 EC             JSR     teststop        ;check for stop
00E4F0  2  B0 1A                BCS     _0120030        ;abort
00E4F2  2               ;
00E4F2  2  A7 1F                LDAIL   addra           ;get from reference location
00E4F4  2  C7 39                CMPIL   operand         ;test against compare location
00E4F6  2  F0 03                BEQ     _0120020        ;match, don't display address
00E4F8  2               ;
00E4F8  2  20 CC E6             JSR     dpycaddr        ;display current location
00E4FB  2               ;
00E4FB  2               _0120020:
00E4FB  2  20 54 EB             JSR     nxtaddra        ;next reference location
00E4FE  2  B0 0C                BCS     _0120030        ;done
00E500  2               ;
00E500  2  C2 20                SLONGA
00E502  2  E6 39                INC     operand         ;bump bits 0-15
00E504  2  E2 20                SHORTA
00E506  2  D0 E5                BNE     _0120010
00E508  2               ;
00E508  2  E6 3B                INC     operand+s_word  ;bump bits 16-23
00E50A  2  80 E1                BRA     _0120010
00E50C  2               ;
00E50C  2               _0120030:
00E50C  2  4C DC E1             JMP     monce           ;return to command exec
00E50F  2               ;
00E50F  2               _0120040:
00E50F  2  4C 1B E2             JMP     monerr          ;goto error handler
00E512  2               ;
00E512  2               ;================================================================================
00E512  2               ;
00E512  2               ;moncpy: COPY (transfer) MEMORY
00E512  2               ;
00E512  2               ;	--------------------------------
00E512  2               ;	syntax: T <start> <end> <target>
00E512  2               ;	--------------------------------
00E512  2               ;
00E512  2               moncpy:
00E512  2  B0 49                BCS     _0130040        ;start not given - quit
00E514  2               ;
00E514  2  20 D8 EA             JSR     enddest         ;get end & target addresses
00E517  2  B0 47                BCS     _0130050        ;range or other error
00E519  2               ;
00E519  2  C2 20                SLONGA
00E51B  2  38                   SEC
00E51C  2  A5 22                LDA     addrb           ;ending address
00E51E  2  E5 1F                SBC     addra           ;starting address
00E520  2  90 3E                BCC     _0130050        ;start > end - error
00E522  2               ;
00E522  2  85 2D                STA     facb            ;bytes to copy
00E524  2  E2 20                SHORTA
00E526  2  C2 10                LONGX
00E528  2  A5 3B                LDA     operand+s_word  ;target bank
00E52A  2  A4 39                LDY     operand         ;target address
00E52C  2  C5 21                CMP     addra+s_word    ;source bank
00E52E  2  C2 20                SLONGA
00E530  2  D0 1C                BNE     _0130020        ;can use forward copy
00E532  2               ;
00E532  2  C4 1F                CPY     addra           ;source address
00E534  2  90 18                BCC     _0130020        ;can use forward copy
00E536  2               ;
00E536  2  D0 02                BNE     _0130010        ;must use reverse copy
00E538  2               ;
00E538  2  80 26                BRA     _0130050        ;copy in place - error
00E53A  2               ;
00E53A  2               _0130010:
00E53A  2  A5 2D                LDA     facb            ;get bytes to copy
00E53C  2  48                   PHA                     ;protect
00E53D  2  20 D8 EC             JSR     lodbnk          ;load banks
00E540  2  20 95 EA             JSR     cprvsup         ;do reverse copy setup
00E543  2  68                   PLA                     ;get bytes to copy
00E544  2  AA                   TAX                     ;save a copy
00E545  2  18                   CLC
00E546  2  65 39                ADC     operand         ;change target to...
00E548  2  A8                   TAY                     ;target end
00E549  2  8A                   TXA                     ;recover bytes to copy
00E54A  2  A6 22                LDX     addrb           ;source end
00E54C  2  80 0C                BRA     _0130030
00E54E  2               ;
00E54E  2               _0130020:
00E54E  2  A5 2D                LDA     facb            ;get bytes to copy
00E550  2  48                   PHA                     ;protect
00E551  2  20 D8 EC             JSR     lodbnk          ;load banks
00E554  2  20 8E EA             JSR     cpfwsup         ;do forward copy setup
00E557  2  68                   PLA                     ;get bytes to copy
00E558  2  A6 1F                LDX     addra           ;source start
00E55A  2               ;
00E55A  2               _0130030:
00E55A  2  4C 25 00             JMP     mcftwork        ;copy memory
00E55D  2               ;
00E55D  2               _0130040:
00E55D  2  4C DC E1             JMP     monce           ;back to executive
00E560  2               ;
00E560  2               _0130050:
00E560  2  4C 1B E2             JMP     monerr          ;error
00E563  2               ;
00E563  2               ;================================================================================
00E563  2               ;
00E563  2               ;mondmp: DISPLAY MEMORY RANGE
00E563  2               ;
00E563  2               ;	-----------------------------
00E563  2               ;	syntax: M [<addr1> [<addr2>]]
00E563  2               ;	-----------------------------
00E563  2               ;
00E563  2               mondmp:
00E563  2  B0 0F                BCS     _0140010        ;no parameters
00E565  2               ;
00E565  2  20 1C EB             JSR     facasize        ;check address...
00E568  2  C9 04                CMP     #s_dword        ;range
00E56A  2  B0 46                BCS     _0140050        ;address out of range
00E56C  2               ;
00E56C  2  20 FE EA             JSR     facaddra        ;copy starting address
00E56F  2  20 2C EB             JSR     getparm         ;get ending address
00E572  2  90 17                BCC     _0140020        ;gotten
00E574  2               ;
00E574  2               _0140010:
00E574  2  20 01 EA             JSR     clrfaca         ;clear accumulator
00E577  2  C2 20                SLONGA
00E579  2  18                   CLC
00E57A  2  A5 1F                LDA     addra           ;starting address
00E57C  2  69 FF 00             ADCW    n_mbytes        ;default bytes
00E57F  2  85 25                STA     faca            ;effective ending address
00E581  2  E2 20                SHORTA
00E583  2  A5 21                LDA     addra+s_word    ;starting bank
00E585  2  69 00                ADC     #0
00E587  2  85 27                STA     faca+s_word     ;effective ending bank
00E589  2  B0 27                BCS     _0140050        ;end address > $FFFFFF
00E58B  2               ;
00E58B  2               _0140020:
00E58B  2  20 1C EB             JSR     facasize        ;check ending address...
00E58E  2  C9 04                CMP     #s_dword        ;range
00E590  2  B0 20                BCS     _0140050        ;out of range - error
00E592  2               ;
00E592  2  20 08 EB             JSR     facaddrb        ;copy ending address
00E595  2  20 2C EB             JSR     getparm         ;check for excess input
00E598  2  90 18                BCC     _0140050        ;error
00E59A  2               ;
00E59A  2  20 6D EA             JSR     calccnt         ;calculate bytes to dump
00E59D  2  90 13                BCC     _0140050        ;end < start
00E59F  2               ;
00E59F  2               _0140030:
00E59F  2  20 F0 EC             JSR     teststop        ;test for display stop
00E5A2  2  B0 0B                BCS     _0140040        ;stopped
00E5A4  2               ;
00E5A4  2  20 68 E8             JSR     newline         ;next line
00E5A7  2  20 F6 E7             JSR     dpymem          ;display
00E5AA  2  20 B4 EA             JSR     decdcnt         ;decrement byte count
00E5AD  2  90 F0                BCC     _0140030        ;not done
00E5AF  2               ;
00E5AF  2               _0140040:
00E5AF  2  4C DC E1             JMP     monce           ;back to main loop
00E5B2  2               ;
00E5B2  2               _0140050:
00E5B2  2  4C 1B E2             JMP     monerr          ;address range error
00E5B5  2               ;
00E5B5  2               ;================================================================================
00E5B5  2               ;
00E5B5  2               ;monfil: FILL MEMORY
00E5B5  2               ;
00E5B5  2               ;	-----------------------------------------
00E5B5  2               ;	syntax: F <start> <end> <fill>
00E5B5  2               ;
00E5B5  2               ;	<start> & <end> must be in the same bank.
00E5B5  2               ;	-----------------------------------------
00E5B5  2               ;
00E5B5  2               monfil:
00E5B5  2  B0 5E                BCS     _0150010        ;start not given - quit
00E5B7  2               ;
00E5B7  2  20 1C EB             JSR     facasize        ;check size
00E5BA  2  C9 04                CMP     #s_dword
00E5BC  2  B0 5A                BCS     _0150020        ;out of range - error...
00E5BE  2               ;
00E5BE  2  20 FE EA             JSR     facaddra        ;store start
00E5C1  2  20 2C EB             JSR     getparm         ;evaluate end
00E5C4  2  B0 52                BCS     _0150020        ;not entered - error
00E5C6  2               ;
00E5C6  2  20 1C EB             JSR     facasize        ;check size
00E5C9  2  C9 04                CMP     #s_dword
00E5CB  2  B0 4B                BCS     _0150020        ;out of range - error
00E5CD  2               ;
00E5CD  2  A5 27                LDA     faca+s_word     ;end bank
00E5CF  2  C5 21                CMP     addra+s_word    ;start bank
00E5D1  2  D0 45                BNE     _0150020        ;not same - error
00E5D3  2               ;
00E5D3  2  20 08 EB             JSR     facaddrb        ;store <end>
00E5D6  2  C2 20                SLONGA
00E5D8  2  38                   SEC
00E5D9  2  A5 22                LDA     addrb           ;ending address
00E5DB  2  E5 1F                SBC     addra           ;starting address
00E5DD  2  90 39                BCC     _0150020        ;start > end - error
00E5DF  2               ;
00E5DF  2  85 2D                STA     facb            ;bytes to copy
00E5E1  2  E2 20                SHORTA
00E5E3  2  20 2C EB             JSR     getparm         ;evaluate <fill>
00E5E6  2  B0 30                BCS     _0150020        ;not entered - error
00E5E8  2               ;
00E5E8  2  20 1C EB             JSR     facasize        ;<fill> should be...
00E5EB  2  C9 02                CMP     #s_word         ;8 bits
00E5ED  2  B0 29                BCS     _0150020        ;it isn't - error
00E5EF  2               ;
00E5EF  2  20 12 EB             JSR     facaoper        ;store <fill>
00E5F2  2  20 2C EB             JSR     getparm         ;should be no more parameters
00E5F5  2  90 21                BCC     _0150020        ;there are - error
00E5F7  2               ;
00E5F7  2  A5 39                LDA     operand         ;<fill>
00E5F9  2  87 1F                STAIL   addra           ;fill 1st location
00E5FB  2  C2 30                LONGR                   ;16 bit operations
00E5FD  2  A5 2D                LDA     facb            ;get byte count
00E5FF  2  F0 14                BEQ     _0150010        ;only 1 location - finished
00E601  2               ;
00E601  2  3A                   DEA                     ;zero align &...
00E602  2  48                   PHA                     ;protect
00E603  2  E2 20                SHORTA
00E605  2  A5 21                LDA     addra+s_word    ;start bank
00E607  2  EB                   XBA
00E608  2  A5 24                LDA     addrb+s_word    ;end bank
00E60A  2  20 8E EA             JSR     cpfwsup         ;do forward copy setup
00E60D  2  68                   PLA                     ;recover fill count
00E60E  2  A6 1F                LDX     addra           ;fill-from starting location
00E610  2  9B                   TXY
00E611  2  C8                   INY                     ;fill-to starting location
00E612  2  4C 25 00             JMP     mcftwork        ;fill memory
00E615  2               ;
00E615  2               _0150010:
00E615  2  4C DC E1             JMP     monce           ;goto command executive
00E618  2               ;
00E618  2               _0150020:
00E618  2  4C 1B E2             JMP     monerr          ;goto error handler
00E61B  2               ;
00E61B  2               ;================================================================================
00E61B  2               ;
00E61B  2               ;monhnt: SEARCH (hunt) MEMORY
00E61B  2               ;
00E61B  2               ;	-----------------------------------
00E61B  2               ;	syntax: H <addr1> <addr2> <pattern>
00E61B  2               ;	-----------------------------------
00E61B  2               ;
00E61B  2               monhnt:
00E61B  2  B0 40                BCS     _0160050        ;no start address
00E61D  2               ;
00E61D  2  20 1C EB             JSR     facasize        ;size starting address
00E620  2  C9 04                CMP     #s_dword
00E622  2  B0 3C                BCS     _0160060        ;address out of range - error
00E624  2               ;
00E624  2  20 FE EA             JSR     facaddra        ;store starting address
00E627  2  20 2C EB             JSR     getparm         ;evaluate ending address
00E62A  2  B0 34                BCS     _0160060        ;no address - error
00E62C  2               ;
00E62C  2  20 1C EB             JSR     facasize        ;size ending address
00E62F  2  C9 04                CMP     #s_dword
00E631  2  B0 2D                BCS     _0160060        ;address out of range - error
00E633  2               ;
00E633  2  20 08 EB             JSR     facaddrb        ;store ending address
00E636  2  20 6D EA             JSR     calccnt         ;calculate byte range
00E639  2  90 25                BCC     _0160060        ;end < start
00E63B  2               ;
00E63B  2  20 2F EC             JSR     getpat          ;evaluate search pattern
00E63E  2  B0 20                BCS     _0160060        ;error
00E640  2               ;
00E640  2  64 4A                STZ     xrtemp          ;clear column counter
00E642  2               ;
00E642  2               _0160010:
00E642  2  20 F0 EC             JSR     teststop        ;check for stop
00E645  2  B0 16                BCS     _0160050        ;abort
00E647  2               ;
00E647  2  A4 3C                LDY     auxbufix        ;pattern index
00E649  2               ;
00E649  2               _0160020:
00E649  2  88                   DEY
00E64A  2  30 09                BMI     _0160030        ;pattern match
00E64C  2               ;
00E64C  2  B7 1F                LDAILY  addra           ;get from memory
00E64E  2  D9 46 02             CMP     auxbuf,y        ;test against pattern
00E651  2  D0 05                BNE     _0160040        ;mismatch, next location
00E653  2               ;
00E653  2  F0 F4                BEQ     _0160020        ;match, keep testing
00E655  2               ;
00E655  2               _0160030:
00E655  2  20 CC E6             JSR     dpycaddr        ;display current location
00E658  2               ;
00E658  2               _0160040:
00E658  2  20 54 EB             JSR     nxtaddra        ;next location
00E65B  2  90 E5                BCC     _0160010        ;not done
00E65D  2               ;
00E65D  2               _0160050:
00E65D  2  4C DC E1             JMP     monce           ;back to executive
00E660  2               ;
00E660  2               _0160060:
00E660  2  4C 1B E2             JMP     monerr          ;goto error handler
00E663  2               ;
00E663  2               ;================================================================================
00E663  2               ;
00E663  2               ;monenv: CONVERT NUMERIC VALUE
00E663  2               ;
00E663  2               ;	----------------------
00E663  2               ;	syntax: <radix><value>
00E663  2               ;	----------------------
00E663  2               ;
00E663  2               monenv:
00E663  2  20 2A EB             JSR     getparmr        ;reread & evaluate parameter
00E666  2  B0 26                BCS     _0170020        ;none entered
00E668  2               ;
00E668  2  A2 00                LDX     #0              ;radix index
00E66A  2  A0 04                LDY     #n_radix        ;number of radices
00E66C  2               ;
00E66C  2               _0170010:
00E66C  2  5A                   PHY                     ;save counter
00E66D  2  DA                   PHX                     ;save radix index
00E66E  2  20 68 E8             JSR     newline         ;next line &...
00E671  2  20 F0 E7             JSR     clearlin        ;clear it
00E674  2  A9 20                LDA     #a_blank
00E676  2  A2 04                LDX     #halftab
00E678  2  20 5D E8             JSR     multspc         ;indent 1/2 tab
00E67B  2  FA                   PLX                     ;get radix index but...
00E67C  2  DA                   PHX                     ;put it back
00E67D  2  BD D3 ED             LDA     radxtab,x       ;get radix
00E680  2  20 5A E9             JSR     binasc          ;convert to ASCII
00E683  2  5A                   PHY                     ;string address MSB
00E684  2  DA                   PHX                     ;string address LSB
00E685  2  20 7D E8             JSR     sprint          ;print
00E688  2  FA                   PLX                     ;get index again
00E689  2  7A                   PLY                     ;get counter
00E68A  2  E8                   INX
00E68B  2  88                   DEY                     ;all radices handled?
00E68C  2  D0 DE                BNE     _0170010        ;no
00E68E  2               
00E68E  2               _0170020:
00E68E  2  4C DC E1             JMP     monce           ;back to command exec
00E691  2               ;
00E691  2               ;================================================================================
00E691  2               ;
00E691  2               ;monchr: CHANGE REGISTERS
00E691  2               ;
00E691  2               ;	------------------------------------------------------
00E691  2               ;	syntax: ; [PB [PC [.S [.C [.X [.Y [SP [DP [DB]]]]]]]]]
00E691  2               ;
00E691  2               ;	; with no parameters is the same as the R command.
00E691  2               ;	------------------------------------------------------
00E691  2               ;
00E691  2               monchr:
00E691  2  B0 33                BCS     _0570040        ;dump registers & quit
00E693  2               ;
00E693  2  A0 00                LDY     #0              ;register counter
00E695  2  84 33                STY     facc            ;initialize register index
00E697  2               ;
00E697  2               _0570010:
00E697  2  20 1C EB             JSR     facasize        ;get parameter size
00E69A  2  D9 D7 ED             CMP     rcvltab,y       ;check against size table
00E69D  2  B0 2A                BCS     _0570050        ;out of range
00E69F  2               ;
00E69F  2  B9 D7 ED             LDA     rcvltab,y       ;determine number of bytes...
00E6A2  2  C9 03                CMP     #s_word+1       ;to store
00E6A4  2  66 34                ROR     facc+s_byte     ;condition flag
00E6A6  2  10 02                BPL     _0570020        ;8 bit register size
00E6A8  2               ;
00E6A8  2  C2 20                SLONGA                  ;16 bit register size
00E6AA  2               ;
00E6AA  2               _0570020:
00E6AA  2  A6 33                LDX     facc            ;get register index
00E6AC  2  A5 25                LDA     faca            ;get parm
00E6AE  2  95 10                STA     reg_pbx,x       ;put in shadow storage
00E6B0  2  E2 20                SHORTA
00E6B2  2  06 34                ASL     facc+s_byte     ;mode flag to carry
00E6B4  2  8A                   TXA                     ;register index
00E6B5  2  69 01                ADC     #s_byte         ;at least 1 byte stored
00E6B7  2  85 33                STA     facc            ;save new index
00E6B9  2  20 2C EB             JSR     getparm         ;get a parameter
00E6BC  2  B0 08                BCS     _0570040        ;EOI
00E6BE  2               ;
00E6BE  2  C8                   INY                     ;bump register count
00E6BF  2  C0 09                CPY     #n_regchv       ;all registers processed?
00E6C1  2  D0 D4                BNE     _0570010        ;no, keep going
00E6C3  2               ;
00E6C3  2               _0570030:
00E6C3  2  20 74 E8             JSR     alert           ;excessive input
00E6C6  2               ;
00E6C6  2               _0570040:
00E6C6  2  4C 7E E1             JMP     monreg          ;display changes
00E6C9  2               ;
00E6C9  2               _0570050:
00E6C9  2  4C 1B E2             JMP     monerr          ;goto error handler
00E6CC  2               ;
00E6CC  2               ;================================================================================
00E6CC  2               ;
00E6CC  2               ;monxit: EXIT TO OPERATING ENVIRONMENT
00E6CC  2               ;
00E6CC  2               ;	---------
00E6CC  2               ;	syntax: X
00E6CC  2               ;	---------
00E6CC  2               ;
00E6CC  2               ;monxit   bcc _0180020          ;no parameters allowed
00E6CC  2               ;
00E6CC  2               ;         slonga
00E6CC  2               ;        lda vecbrki           ;BRK indirect vector
00E6CC  2               ;         cmpw monbrk           ;we intercept it?
00E6CC  2               ;         bne _0180010          ;no, don't change it
00E6CC  2               ;
00E6CC  2               ;         lda vecbrkia          ;old vector
00E6CC  2               ;         sta vecbrki           ;restore it
00E6CC  2               ;         stz vecbrkia          ;invalidate old vector
00E6CC  2               ;
00E6CC  2               ;_0180010 shortr
00E6CC  2               ;         jml vecexit           ;long jump to exit
00E6CC  2               ;
00E6CC  2               ;_0180020 jmp monerr            ;goto error handler
00E6CC  2               ;
00E6CC  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00E6CC  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00E6CC  2               ; * *                                         * *
00E6CC  2               ; * * S T A R T   o f   S U B R O U T I N E S * *
00E6CC  2               ; * *                                         * *
00E6CC  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00E6CC  2               ; * * * * * * * * * * * * * * * * * * * * * * * *
00E6CC  2               ;
00E6CC  2               ;dpycaddr: DISPLAY CURRENT ADDRESS IN COLUMNS
00E6CC  2               ;
00E6CC  2               dpycaddr:
00E6CC  2  A6 4A                LDX     xrtemp          ;column count
00E6CE  2  D0 05                BNE     _0190010        ;not at right side
00E6D0  2               ;
00E6D0  2  20 68 E8             JSR     newline         ;next row
00E6D3  2  A2 0A                LDX     #n_hccols       ;max columns
00E6D5  2               ;
00E6D5  2               _0190010:
00E6D5  2  E0 0A                CPX     #n_hccols       ;max columns
00E6D7  2  F0 05                BEQ     _0190020        ;at left margin
00E6D9  2               ;
00E6D9  2  A9 09                LDA     #a_ht
00E6DB  2  20 71 FF             JSR     putcha          ;tab a column
00E6DE  2               ;
00E6DE  2               _0190020:
00E6DE  2  CA                   DEX                     ;one less column
00E6DF  2  86 4A                STX     xrtemp          ;save column counter
00E6E1  2  4C 36 E8             JMP     prntladr        ;print reference address
00E6E4  2               ;
00E6E4  2               ;================================================================================
00E6E4  2               ;
00E6E4  2               ;dpycod: DISASSEMBLE & DISPLAY CODE
00E6E4  2               ;
00E6E4  2               ;	------------------------------------------------------------------------
00E6E4  2               ;	This function disassembles & displays the machine code at  the  location
00E6E4  2               ;	pointed to by ADDRA.  Upon return, ADDRA will point to the opcode of the
00E6E4  2               ;	next instruction.   The entry point at DPYCODAA  should be called with a
00E6E4  2               ;	disassembly prefix character loaded in .A.   If entered  at  DPYCOD, the
00E6E4  2               ;	default character will be display at the beginning of each  disassembled
00E6E4  2               ;	instruction.
00E6E4  2               ;
00E6E4  2               ;	The disassembly of immediate mode instructions that can take an 8 or  16
00E6E4  2               ;	bit operand is affected by the bit pattern that is  stored  in  FLIMFLAG
00E6E4  2               ;	upon entry to this function:
00E6E4  2               ;
00E6E4  2               ;	    FLIMFLAG: xx000000
00E6E4  2               ;	              ||
00E6E4  2               ;	              |+---------> 0:  8 bit .X or .Y operand
00E6E4  2               ;	              |            1: 16 bit .X or .Y operand
00E6E4  2               ;	              +----------> 0:  8 bit .A or BIT # operand
00E6E4  2               ;	                           1: 16 bit .A or BIT # operand
00E6E4  2               ;
00E6E4  2               ;	FLIMFLAG is conditioned according to the operand of  the  most  recently
00E6E4  2               ;	disassembled REP or SEP instruction.   Hence repetitive  calls  to  this
00E6E4  2               ;	subroutine will usually result in the correct disassembly of 16 bit imm-
00E6E4  2               ;	ediate mode instructions.
00E6E4  2               ;	------------------------------------------------------------------------
00E6E4  2               ;
00E6E4  2               dpycod:
00E6E4  2  A9 2E                LDA     #disprfx        ;default prefix
00E6E6  2               ;
00E6E6  2               ;
00E6E6  2               ;	alternate prefix display entry point...
00E6E6  2               ;
00E6E6  2               dpycodaa:
00E6E6  2  20 71 FF             JSR     putcha          ;print prefix
00E6E9  2  20 78 E8             JSR     printspc        ;space
00E6EC  2  20 36 E8             JSR     prntladr        ;print long address
00E6EF  2  20 78 E8             JSR     printspc        ;space to opcode field
00E6F2  2  20 69 EB             JSR     getbyte         ;get opcode
00E6F5  2  85 48                STA     opcode          ;save &...
00E6F7  2  20 6D E8             JSR     printbyt        ;display as hex
00E6FA  2               ;
00E6FA  2               ;
00E6FA  2               ;	decode menmonic & addressing info...
00E6FA  2               ;
00E6FA  2  A6 48                LDX     opcode          ;current mnemonic
00E6FC  2  BD 98 EE             LDA     mnetabix,x      ;get mnemonic index
00E6FF  2  0A                   ASL                     ;double for...
00E700  2  A8                   TAY                     ;mnemonic table offset
00E701  2  C2 20                SLONGA                  ;16 bit load
00E703  2  B9 E0 ED             LDA     mnetab,y        ;copy encoded mnemonic to...
00E706  2  85 46                STA     mnepck          ;working storage
00E708  2  E2 20                SHORTA                  ;back to 8 bits
00E70A  2  20 8A EB             JSR     instdata        ;extract mode & size data
00E70D  2  85 4F                STA     vopsflag        ;save mode flags
00E70F  2  84 41                STY     admodidx        ;save mode index
00E711  2  0A                   ASL                     ;variable immediate instruction?
00E712  2  90 1F                BCC     dpycod01        ;no, effective operand size in .X
00E714  2               ;
00E714  2               ;
00E714  2               ;	determine immediate mode operand size...
00E714  2               ;
00E714  2  A5 48                LDA     opcode          ;current opcode
00E716  2  24 4C                BIT     flimflag        ;operand display mode
00E718  2  10 08                BPL     _0200010        ;8 bit .A & BIT immediate mode
00E71A  2               ;
00E71A  2  29 1F                AND     #aimmaska       ;determine if...
00E71C  2  C9 09                CMP     #aimmaskb       ;.A or BIT immediate
00E71E  2  F0 10                BEQ     _0200030        ;display 16 bit operand
00E720  2               ;
00E720  2  A5 48                LDA     opcode          ;not .A or BIT immediate
00E722  2               ;
00E722  2               _0200010:
00E722  2  50 0F                BVC     dpycod01        ;8 bit .X/.Y immediate mode
00E724  2               ;
00E724  2  A0 03                LDY     #n_vopidx-1     ;opcodes to test
00E726  2               ;
00E726  2               _0200020:
00E726  2  D9 98 F0             CMP     vopidx,y        ;looking for LDX #, CPY #, etc.
00E729  2  F0 07                BEQ     _0200040        ;disassemble a 16 bit operand
00E72B  2               ;
00E72B  2  88                   DEY
00E72C  2  10 F8                BPL     _0200020        ;keep trying
00E72E  2               ;
00E72E  2  80 03                BRA     dpycod01        ;not .X or .Y immediate
00E730  2               ;
00E730  2               _0200030:
00E730  2  A5 48                LDA     opcode          ;reload
00E732  2               ;
00E732  2               _0200040:
00E732  2  E8                   INX                     ;16 bit operand
00E733  2               ;
00E733  2               ;
00E733  2               ;	get & display operand bytes...
00E733  2               ;
00E733  2               dpycod01:
00E733  2  86 4D                STX     iopsize         ;operand size...
00E735  2  E8                   INX                     ;plus opcode becomes...
00E736  2  86 44                STX     instsize        ;instruction size
00E738  2  86 42                STX     charcnt         ;total bytes to process
00E73A  2  A9 0B                LDA     #n_opcols+2     ;total operand columns plus WS
00E73C  2  85 4A                STA     xrtemp          ;initialize counter
00E73E  2  20 82 EA             JSR     clroper         ;clear operand
00E741  2  A4 4D                LDY     iopsize         ;operand size
00E743  2  F0 16                BEQ     _0210020        ;no operand
00E745  2               ;
00E745  2  A2 00                LDX     #0              ;operand index
00E747  2               ;
00E747  2               _0210010:
00E747  2  20 69 EB             JSR     getbyte         ;get operand byte
00E74A  2  95 39                STA     operand,x       ;save
00E74C  2  DA                   PHX                     ;protect operand index
00E74D  2  20 6D E8             JSR     printbyt        ;print operand byte
00E750  2  C6 4A                DEC     xrtemp          ;3 columns used, 2 for...
00E752  2  C6 4A                DEC     xrtemp          ;operand nybbles &...
00E754  2  C6 4A                DEC     xrtemp          ;1 for whitespace
00E756  2  FA                   PLX                     ;get operand index
00E757  2  E8                   INX                     ;bump it
00E758  2  88                   DEY
00E759  2  D0 EC                BNE     _0210010        ;next
00E75B  2               ;
00E75B  2               _0210020:
00E75B  2  A6 4A                LDX     xrtemp          ;operand columns remaining
00E75D  2  20 5D E8             JSR     multspc         ;space to mnemonic field
00E760  2               ;
00E760  2               ;
00E760  2               ;	display mnemonic...
00E760  2               ;
00E760  2  A0 03                LDY     #s_mnemon       ;size of ASCII mnemonic
00E762  2               ;
00E762  2               _0210030:
00E762  2  A9 00                LDA     #0              ;initialize char
00E764  2  A2 05                LDX     #n_shfenc       ;shifts to execute
00E766  2               ;
00E766  2               _0210040:
00E766  2  06 46                ASL     mnepck          ;shift encoded mnemonic
00E768  2  26 47                ROL     mnepck+s_byte
00E76A  2  2A                   ROL
00E76B  2  CA                   DEX
00E76C  2  D0 F8                BNE     _0210040
00E76E  2               ;
00E76E  2  69 3F                ADC     #a_mnecvt       ;convert to ASCII &...
00E770  2  48                   PHA                     ;stash
00E771  2  88                   DEY
00E772  2  D0 EE                BNE     _0210030        ;continue with mnemonic
00E774  2               ;
00E774  2  A0 03                LDY     #s_mnemon
00E776  2               ;
00E776  2               _0210050:
00E776  2  68                   PLA                     ;get mnenmonic byte
00E777  2  20 71 FF             JSR     putcha          ;print it
00E77A  2  88                   DEY
00E77B  2  D0 F9                BNE     _0210050
00E77D  2               ;
00E77D  2               ;
00E77D  2               ;	display operand...
00E77D  2               ;
00E77D  2  A5 4D                LDA     iopsize         ;operand size
00E77F  2  F0 6F                BEQ     clearlin        ;zero, disassembly finished
00E781  2               ;
00E781  2  20 78 E8             JSR     printspc        ;space to operand field
00E784  2  24 4F                BIT     vopsflag        ;check mode flags
00E786  2  50 08                BVC     dpycod02        ;not a branch
00E788  2               ;
00E788  2  20 A0 EB             JSR     offtarg         ;compute branch target
00E78B  2  A6 44                LDX     instsize        ;effective instruction size
00E78D  2  CA                   DEX
00E78E  2  86 4D                STX     iopsize         ;effective operand size
00E790  2               ;
00E790  2               dpycod02:
00E790  2  64 4F                STZ     vopsflag        ;clear
00E792  2  A5 41                LDA     admodidx        ;instruction addressing mode
00E794  2  C9 0B                CMP     #am_move        ;block move instruction?
00E796  2  D0 02                BNE     _0220010        ;no
00E798  2               ;
00E798  2  66 4F                ROR     vopsflag        ;yes
00E79A  2               ;
00E79A  2               _0220010:
00E79A  2  0A                   ASL                     ;convert addressing mode to...
00E79B  2  AA                   TAX                     ;symbology table index
00E79C  2  C2 20                SLONGA                  ;do a 16 bit load
00E79E  2  BD 9C F0             LDA     ms_lutab,x      ;addressing symbol pointer
00E7A1  2  48                   PHA
00E7A2  2  E2 20                SHORTA                  ;back to 8 bit loads
00E7A4  2  A0 00                LDY     #0
00E7A6  2  B3 01                LDASI   1               ;get 1st char
00E7A8  2  C9 20                CMP     #a_blank
00E7AA  2  F0 03                BEQ     _0220020        ;no addresing mode preamble
00E7AC  2               ;
00E7AC  2  20 71 FF             JSR     putcha          ;print preamble
00E7AF  2               ;
00E7AF  2               _0220020:
00E7AF  2  A9 24                LDA     #c_hex
00E7B1  2  20 71 FF             JSR     putcha          ;operand displayed as hex
00E7B4  2  A4 4D                LDY     iopsize         ;operand size = index
00E7B6  2               ;
00E7B6  2               _0220030:
00E7B6  2  88                   DEY
00E7B7  2  30 16                BMI     _0220040        ;done with operand
00E7B9  2               ;
00E7B9  2  B9 39 00             LDA     operand,y       ;get operand byte
00E7BC  2  20 53 E8             JSR     dpyhex          ;print operand byte
00E7BF  2  24 4F                BIT     vopsflag        ;block move?
00E7C1  2  10 F3                BPL     _0220030        ;no
00E7C3  2               ;
00E7C3  2  64 4F                STZ     vopsflag        ;reset
00E7C5  2  5A                   PHY                     ;protect operand index
00E7C6  2  F4 D5 F0             PEA     ms_move
00E7C9  2  20 7D E8             JSR     sprint          ;display MVN/MVP operand separator
00E7CC  2  7A                   PLY                     ;recover operand index again
00E7CD  2  80 E7                BRA     _0220030        ;continue
00E7CF  2               ;
00E7CF  2               _0220040:
00E7CF  2  FA                   PLX                     ;symbology LSB
00E7D0  2  7A                   PLY                     ;symbology MSB
00E7D1  2  E8                   INX                     ;move past preamble
00E7D2  2  D0 01                BNE     _0220050
00E7D4  2               ;
00E7D4  2  C8                   INY
00E7D5  2               ;
00E7D5  2               _0220050:
00E7D5  2  5A                   PHY
00E7D6  2  DA                   PHX
00E7D7  2  20 7D E8             JSR     sprint          ;print postamble, if any
00E7DA  2               ;
00E7DA  2               ;
00E7DA  2               ;	condition immediate mode display format...
00E7DA  2               ;
00E7DA  2               dpycod03:
00E7DA  2  A5 39                LDA     operand         ;operand LSB
00E7DC  2  29 30                AND     #pfmxmask       ;isolate M & X bits
00E7DE  2  0A                   ASL                     ;shift to match...
00E7DF  2  0A                   ASL                     ;FLIMFLAG alignment
00E7E0  2  A6 48                LDX     opcode          ;current instruction
00E7E2  2  E0 C2                CPX     #opc_rep        ;was it REP?
00E7E4  2  D0 04                BNE     _0230010        ;no
00E7E6  2               ;
00E7E6  2  04 4C                TSB     flimflag        ;set flag bits as required
00E7E8  2  80 06                BRA     clearlin
00E7EA  2               ;
00E7EA  2               _0230010:
00E7EA  2  E0 E2                CPX     #opc_sep        ;was it SEP?
00E7EC  2  D0 02                BNE     clearlin        ;no, just exit
00E7EE  2               ;
00E7EE  2  14 4C                TRB     flimflag        ;clear flag bits as required
00E7F0  2               ;
00E7F0  2               ;================================================================================
00E7F0  2               ;
00E7F0  2               ;clearlin: CLEAR DISPLAY LINE
00E7F0  2               ;
00E7F0  2               clearlin:
00E7F0  2  60                   RTS
00E7F1  2               ;
00E7F1  2               ;================================================================================
00E7F1  2               ;
00E7F1  2               ;dpyibuf: DISPLAY MONITOR INPUT BUFFER CONTENTS
00E7F1  2               ;
00E7F1  2               dpyibuf:
00E7F1  2  F4 00 02             PEA     ibuffer
00E7F4  2  80 37                BRA     dpyerraa
00E7F6  2               ;
00E7F6  2               ;================================================================================
00E7F6  2               ;
00E7F6  2               ;dpymem: DISPLAY MEMORY
00E7F6  2               ;
00E7F6  2               ;	------------------------------------------------------------
00E7F6  2               ;	This function displays 16 bytes of memory as hex values & as
00E7F6  2               ;	ASCII equivalents.  The starting address for the display is
00E7F6  2               ;	in ADDRA & is expected to be a 24 bit address.  Upon return,
00E7F6  2               ;	ADDRA will point to the start of the next 16 bytes.
00E7F6  2               ;	------------------------------------------------------------
00E7F6  2               ;
00E7F6  2               dpymem:
00E7F6  2  E2 30                SHORTR
00E7F8  2  64 42                STZ     charcnt         ;reset
00E7FA  2               ;         lda #memprfx
00E7FA  2               ;         jsr putcha            ;display prefix
00E7FA  2  20 36 E8             JSR     prntladr        ;print 24 bit address
00E7FD  2  A2 00                LDX     #0              ;string buffer index
00E7FF  2  A0 08                LDY     #n_dump         ;bytes per line
00E801  2               ;
00E801  2               _0240010:
00E801  2  20 69 EB             JSR     getbyte         ;get from RAM, also...
00E804  2  48                   PHA                     ;save for decoding
00E805  2  DA                   PHX                     ;save string index
00E806  2  20 6D E8             JSR     printbyt        ;display as hex ASCII
00E809  2  E6 42                INC     charcnt         ;bytes displayed +1
00E80B  2  FA                   PLX                     ;recover string index &...
00E80C  2  68                   PLA                     ;byte
00E80D  2  C9 20                CMP     #a_blank        ;printable?
00E80F  2  90 04                BCC     _0240020        ;no
00E811  2               ;
00E811  2  C9 7F                CMP     #a_del
00E813  2  90 02                BCC     _0240030        ;is printable
00E815  2               ;
00E815  2               _0240020:
00E815  2  A9 2E                LDA     #memsubch       ;substitute character
00E817  2               ;
00E817  2               _0240030:
00E817  2  9D 00 02             STA     ibuffer,x       ;save char
00E81A  2  E8                   INX                     ;bump index
00E81B  2  88                   DEY                     ;byte count -= 1
00E81C  2  D0 E3                BNE     _0240010        ;not done
00E81E  2               ;
00E81E  2  9E 00 02             STZ     ibuffer,x       ;terminate ASCII string
00E821  2  A9 3A                LDA     #memsepch
00E823  2  20 71 FF             JSR     putcha          ;separate ASCII from bytes
00E826  2  20 F1 E7             JSR     dpyibuf         ;display ASCII equivalents
00E829  2  60                   RTS
00E82A  2               ;
00E82A  2               ;================================================================================
00E82A  2               ;
00E82A  2               ;dpyerr: DISPLAY ERROR SIGNAL
00E82A  2               ;
00E82A  2               dpyerr:
00E82A  2  F4 16 F1             PEA     mm_err          ;"*ERR"
00E82D  2               ;
00E82D  2               dpyerraa:
00E82D  2  20 7D E8             JSR     sprint
00E830  2  60                   RTS
00E831  2               ;
00E831  2               ;================================================================================
00E831  2               ;
00E831  2               ;gendbs: GENERATE DESTRUCTIVE BACKSPACE
00E831  2               ;
00E831  2               gendbs:
00E831  2  F4 E6 F0             PEA     dc_bs           ;destructive backspace
00E834  2  80 F7                BRA     dpyerraa
00E836  2               ;
00E836  2               ;================================================================================
00E836  2               ;
00E836  2               ;prntladr: PRINT 24 BIT CURRENT ADDRESS
00E836  2               ;
00E836  2               prntladr:
00E836  2  08                   PHP                     ;protect register sizes
00E837  2  E2 20                SHORTA
00E839  2  A5 21                LDA     addra+s_word    ;get bank byte &...
00E83B  2  20 53 E8             JSR     dpyhex          ;display it
00E83E  2  C2 20                SLONGA
00E840  2  A5 1F                LDA     addra           ;get 16 bit address
00E842  2  28                   PLP                     ;restore register sizes
00E843  2               ;
00E843  2               ;================================================================================
00E843  2               ;
00E843  2               ;dpyhexw: DISPLAY BINARY WORD AS HEX ASCII
00E843  2               ;
00E843  2               ;	------------------------------------
00E843  2               ;	Preparatory Ops: .C: word to display
00E843  2               ;
00E843  2               ;	Returned Values: .C: used
00E843  2               ;	                 .X: used
00E843  2               ;	                 .Y: entry value
00E843  2               ;	------------------------------------
00E843  2               ;
00E843  2               dpyhexw:
00E843  2  08                   PHP                     ;save register sizes
00E844  2  C2 20                SLONGA
00E846  2  48                   PHA                     ;protect value
00E847  2  E2 20                SHORTA
00E849  2  EB                   XBA                     ;get MSB &...
00E84A  2  20 53 E8             JSR     dpyhex          ;display
00E84D  2  C2 20                SLONGA
00E84F  2  68                   PLA                     ;recover value
00E850  2  E2 20                SHORTA                  ;only LSB visible
00E852  2  28                   PLP                     ;reset register sizes
00E853  2               ;
00E853  2               ;================================================================================
00E853  2               ;
00E853  2               ;dpyhex: DISPLAY BINARY BYTE AS HEX ASCII
00E853  2               ;
00E853  2               ;	------------------------------------
00E853  2               ;	Preparatory Ops: .A: byte to display
00E853  2               ;
00E853  2               ;	Returned Values: .A: used
00E853  2               ;	                 .X: used
00E853  2               ;	                 .Y: entry value
00E853  2               ;	------------------------------------
00E853  2               ;
00E853  2               dpyhex:
00E853  2  20 EE E9             JSR     binhex          ;convert to hex ASCII
00E856  2  20 71 FF             JSR     putcha          ;print MSN
00E859  2  8A                   TXA
00E85A  2  4C 71 FF             JMP     putcha          ;print LSN
00E85D  2               ;
00E85D  2               ;================================================================================
00E85D  2               ;
00E85D  2               ;multspc: PRINT MULTIPLE BLANKS
00E85D  2               ;
00E85D  2               ;	------------------------------------------------
00E85D  2               ;	Preparatory Ops : .X: number of blanks to print
00E85D  2               ;
00E85D  2               ;	Register Returns: none
00E85D  2               ;
00E85D  2               ;	Calling Example : ldx #3
00E85D  2               ;	                  jsr multspc    ;print 3 spaces
00E85D  2               ;
00E85D  2               ;	Notes: This sub will print 1 blank if .X=0.
00E85D  2               ;	------------------------------------------------
00E85D  2               ;
00E85D  2               
00E85D  2               multspc:
00E85D  2  8A                   TXA
00E85E  2  D0 01                BNE     _0250010        ;blank count specified
00E860  2               ;
00E860  2  E8                   INX                     ;default to 1 blank
00E861  2               ;
00E861  2               _0250010:
00E861  2  20 78 E8             JSR     printspc
00E864  2  CA                   DEX
00E865  2  D0 FA                BNE     _0250010
00E867  2               ;
00E867  2  60                   RTS
00E868  2               
00E868  2               ;
00E868  2               ;================================================================================
00E868  2               ;
00E868  2               ;newline: PRINT NEWLINE (CRLF)
00E868  2               ;
00E868  2               newline:
00E868  2  F4 E3 F0             PEA     dc_lf
00E86B  2  80 C0                BRA     dpyerraa
00E86D  2               ;
00E86D  2               ;================================================================================
00E86D  2               ;
00E86D  2               ;printbyt: PRINT A BYTE WITH LEADING SPACE
00E86D  2               ;
00E86D  2               printbyt:
00E86D  2  48                   PHA                     ;protect byte
00E86E  2  20 78 E8             JSR     printspc        ;print leading space
00E871  2  68                   PLA                     ;restore &...
00E872  2  80 DF                BRA     dpyhex          ;print byte
00E874  2               ;
00E874  2               ;================================================================================
00E874  2               ;
00E874  2               ;alert: ALERT USER w/TERMINAL BELL
00E874  2               ;
00E874  2               alert:
00E874  2  A9 07                LDA     #a_bel
00E876  2  80 02                BRA     printcmn
00E878  2               ;
00E878  2               ;================================================================================
00E878  2               ;
00E878  2               ;printspc: PRINT A SPACE
00E878  2               ;
00E878  2               printspc:
00E878  2  A9 20                LDA     #a_blank
00E87A  2               ;
00E87A  2               printcmn:
00E87A  2  4C 71 FF             JMP     putcha
00E87D  2               ;
00E87D  2               ;================================================================================
00E87D  2               ;
00E87D  2               ;sprint: PRINT NULL-TERMINATED CHARACTER STRING
00E87D  2               ;
00E87D  2               ;	---------------------------------------------------------
00E87D  2               ;	Preparatory Ops : SP+1: string address LSB
00E87D  2               ;	                  SP+2: string address MSB
00E87D  2               ;
00E87D  2               ;	Register Returns: .A: used
00E87D  2               ;	                  .B: entry value
00E87D  2               ;	                  .X: used
00E87D  2               ;	                  .Y: used
00E87D  2               ;
00E87D  2               ;	MPU Flags: NVmxDIZC
00E87D  2               ;	           ||||||||
00E87D  2               ;	           |||||||+---> 0: okay
00E87D  2               ;	           |||||||      1: string too long (1)
00E87D  2               ;	           ||||+++----> not defined
00E87D  2               ;	           |||+-------> 1
00E87D  2               ;	           ||+--------> 1
00E87D  2               ;	           ++---------> not defined
00E87D  2               ;
00E87D  2               ;	Example: PER STRING
00E87D  2               ;	         JSR SPRINT
00E87D  2               ;	         BCS TOOLONG
00E87D  2               ;
00E87D  2               ;	Notes: 1) Maximum permissible string length including the
00E87D  2               ;	          terminator is 32,767 bytes.
00E87D  2               ;	       2) All registers are forced to 8 bits.
00E87D  2               ;	       3) DO NOT JUMP OR BRANCH INTO THIS FUNCTION!
00E87D  2               ;	---------------------------------------------------------
00E87D  2               ;
00E87D  2               sprint:
00E87D  2  E2 20                SHORTA                  ;8 bit accumulator
00E87F  2  C2 10                LONGX                   ;16 bit index
00E881  2               ;
00E881  2               ;---------------------------------------------------------
00E881  2               _retaddr        = 1             ;return address
00E881  2               _src            = _retaddr+s_word;string address stack offset
00E881  2               ;---------------------------------------------------------
00E881  2               ;
00E881  2  A0 00 00             LDYW    0
00E884  2  18                   CLC                     ;no initial error
00E885  2               ;
00E885  2               _0260010:
00E885  2  B3 03                LDASI   _src            ;get a byte
00E887  2  F0 07                BEQ     _0260020        ;done
00E889  2               ;
00E889  2  20 71 FF             JSR     putcha          ;write to console port
00E88C  2  C8                   INY
00E88D  2  10 F6                BPL     _0260010        ;next
00E88F  2               ;
00E88F  2  38                   SEC                     ;string too long
00E890  2               ;
00E890  2               _0260020:
00E890  2  FA                   PLX                     ;pull RTS address
00E891  2  7A                   PLY                     ;clear string pointer
00E892  2  DA                   PHX                     ;replace RTS
00E893  2  E2 10                SHORTX
00E895  2  60                   RTS
00E896  2               ;
00E896  2               ;================================================================================
00E896  2               ;
00E896  2               ;ascbin: CONVERT NULL-TERMINATED ASCII NUMBER STRING TO BINARY
00E896  2               ;
00E896  2               ;	---------------------------------------------------
00E896  2               ;	Preparatory Ops: ASCII number string in IBUFFER
00E896  2               ;
00E896  2               ;	Returned Values: FACA: converted parameter
00E896  2               ;	                   .A: used
00E896  2               ;	                   .X: used
00E896  2               ;	                   .Y: used
00E896  2               ;	                   .C: 1 = conversion error
00E896  2               ;	                   .Z: 1 = nothing to convert
00E896  2               ;
00E896  2               ;	Notes: 1) Conversion stops when a non-numeric char-
00E896  2               ;	          acter is encountered.
00E896  2               ;	       2) Radix symbols are as follows:
00E896  2               ;
00E896  2               ;	          % binary
00E896  2               ;	          % octal
00E896  2               ;	          + decimal
00E896  2               ;	          $ hexadecimal
00E896  2               ;
00E896  2               ;	          Hex is the default if no radix is speci-
00E896  2               ;	          fied in the 1st character of the string.
00E896  2               ;	---------------------------------------------------
00E896  2               ;
00E896  2               ascbin:
00E896  2  E2 30                SHORTR
00E898  2  20 01 EA             JSR     clrfaca         ;clear accumulator
00E89B  2  64 42                STZ     charcnt         ;zero char count
00E89D  2  64 40                STZ     radix           ;initialize
00E89F  2               ;
00E89F  2               ;
00E89F  2               ;	process radix if present...
00E89F  2               ;
00E89F  2  20 7B EC             JSR     getcharw        ;get next non-WS char
00E8A2  2  D0 02                BNE     _0270010        ;got something
00E8A4  2               ;
00E8A4  2  18                   CLC                     ;no more input
00E8A5  2  60                   RTS
00E8A6  2               ;
00E8A6  2               _0270010:
00E8A6  2  A2 03                LDX     #n_radix-1      ;number of radices
00E8A8  2               ;
00E8A8  2               _0270020:
00E8A8  2  DD D3 ED             CMP     radxtab,x       ;recognized radix?
00E8AB  2  F0 06                BEQ     _0270030        ;yes
00E8AD  2               ;
00E8AD  2  CA                   DEX
00E8AE  2  10 F8                BPL     _0270020        ;try next
00E8B0  2               ;
00E8B0  2  C6 3D                DEC     ibufidx         ;reposition to previous char
00E8B2  2  E8                   INX                     ;not recognized, assume hex
00E8B3  2               ;
00E8B3  2               _0270030:
00E8B3  2  C9 2B                CMP     #c_dec          ;decimal radix?
00E8B5  2  D0 02                BNE     _0270040        ;not decimal
00E8B7  2               ;
00E8B7  2  66 40                ROR     radix           ;flag decimal conversion
00E8B9  2               ;
00E8B9  2               _0270040:
00E8B9  2  BD BF ED             LDA     basetab,x       ;number bases table
00E8BC  2  85 4E                STA     range           ;set valid numeral range
00E8BE  2  BD C3 ED             LDA     bitsdtab,x      ;get bits per digit
00E8C1  2  85 3E                STA     bitsdig         ;store
00E8C3  2               ;
00E8C3  2               ;
00E8C3  2               ;	process numerals...
00E8C3  2               ;
00E8C3  2               ascbin01:
00E8C3  2  20 1D EC             JSR     getchar         ;get next char
00E8C6  2  D0 03                BNE     _TMP0001        ;not EOI
00E8C8  2  4C 3B E9             JMP     ascbin03        ;EOI
00E8CB  2               ;
00E8CB  2               _TMP0001:
00E8CB  2  C9 20                CMP     #' '
00E8CD  2  F0 6C                BEQ     ascbin03        ;blank - EOF
00E8CF  2               ;
00E8CF  2  C9 2C                CMP     #','
00E8D1  2  F0 68                BEQ     ascbin03        ;comma - EOF
00E8D3  2               ;
00E8D3  2  C9 09                CMP     #a_ht
00E8D5  2  F0 64                BEQ     ascbin03        ;tab - EOF
00E8D7  2               ;
00E8D7  2  20 5B EA             JSR     nybtobin        ;change to binary
00E8DA  2  B0 60                BCS     ascbin04        ;not a recognized numeral
00E8DC  2               ;
00E8DC  2  C5 4E                CMP     range           ;check range
00E8DE  2  B0 5C                BCS     ascbin04        ;not valid for base
00E8E0  2               ;
00E8E0  2  85 3F                STA     numeral         ;save processed numeral
00E8E2  2  E6 42                INC     charcnt         ;bump numeral count
00E8E4  2  24 40                BIT     radix           ;working in base 10?
00E8E6  2  10 15                BPL     _1570030        ;no
00E8E8  2               ;
00E8E8  2               ;
00E8E8  2               ;	compute N*2 for decimal conversion...
00E8E8  2               ;
00E8E8  2  A2 00                LDX     #0              ;accumulator index
00E8EA  2  A0 02                LDY     #s_pfac/2       ;iterations
00E8EC  2  C2 20                SLONGA
00E8EE  2  18                   CLC
00E8EF  2               ;
00E8EF  2               _1570020:
00E8EF  2  B5 25                LDA     faca,x          ;N
00E8F1  2  2A                   ROL                     ;N=N*2
00E8F2  2  95 2D                STA     facb,x
00E8F4  2  E8                   INX
00E8F5  2  E8                   INX
00E8F6  2  88                   DEY
00E8F7  2  D0 F6                BNE     _1570020
00E8F9  2               ;
00E8F9  2  B0 41                BCS     ascbin04        ;overflow - error
00E8FB  2               ;
00E8FB  2  E2 20                SHORTA
00E8FD  2               ;
00E8FD  2               ;
00E8FD  2               ;	compute N*base for binary, octal or hex...
00E8FD  2               ;	or N*8 for decimal...
00E8FD  2               ;
00E8FD  2               _1570030:
00E8FD  2  A6 3E                LDX     bitsdig         ;bits per digit
00E8FF  2  C2 20                SLONGA                  ;16 bit shifts
00E901  2               ;
00E901  2               _1570040:
00E901  2  06 25                ASL     faca
00E903  2  26 27                ROL     faca+s_word
00E905  2  B0 35                BCS     ascbin04        ;overflow - error
00E907  2               ;
00E907  2  CA                   DEX
00E908  2  D0 F7                BNE     _1570040        ;next shift
00E90A  2               ;
00E90A  2  E2 20                SHORTA                  ;back to 8 bits
00E90C  2  24 40                BIT     radix           ;check base
00E90E  2  10 13                BPL     ascbin02        ;not decimal
00E910  2               ;
00E910  2               ;
00E910  2               ;	compute N*10 for decimal (N*8 + N*2)...
00E910  2               ;
00E910  2  A0 04                LDY     #s_pfac
00E912  2  C2 20                SLONGA
00E914  2               ;
00E914  2               _1570050:
00E914  2  B5 25                LDA     faca,x          ;N*8
00E916  2  75 2D                ADC     facb,x          ;N*2
00E918  2  95 25                STA     faca,x          ;now N*10
00E91A  2  E8                   INX
00E91B  2  E8                   INX
00E91C  2  88                   DEY
00E91D  2  D0 F5                BNE     _1570050
00E91F  2               ;
00E91F  2  B0 1B                BCS     ascbin04        ;overflow - error
00E921  2               ;
00E921  2  E2 20                SHORTA
00E923  2               ;
00E923  2               ;
00E923  2               ;	add current numeral to partial result...
00E923  2               ;
00E923  2               ascbin02:
00E923  2  A5 25                LDA     faca            ;N
00E925  2  65 3F                ADC     numeral         ;N=N+D
00E927  2  85 25                STA     faca
00E929  2  A2 01                LDX     #1
00E92B  2  A0 03                LDY     #s_pfac-1
00E92D  2               ;
00E92D  2               _0280010:
00E92D  2  B5 25                LDA     faca,x
00E92F  2  69 00                ADC     #0              ;account for carry
00E931  2  95 25                STA     faca,x
00E933  2  E8                   INX
00E934  2  88                   DEY
00E935  2  D0 F6                BNE     _0280010
00E937  2               ;
00E937  2  90 08                BCC     _0280020        ;next if no overflow
00E939  2               ;
00E939  2  B0 01                BCS     ascbin04        ;overflow - error
00E93B  2               ;
00E93B  2               ;
00E93B  2               ;	finish up...
00E93B  2               ;
00E93B  2               ascbin03:
00E93B  2  18                   CLC                     ;no error
00E93C  2               ;
00E93C  2               ascbin04:
00E93C  2  E2 20                SHORTA                  ;reset if necessary
00E93E  2  A5 42                LDA     charcnt         ;load char count
00E940  2  60                   RTS                     ;done
00E941  2               _0280020:
00E941  2  4C C3 E8             JMP     ascbin01        ;next if no overflow
00E944  2               ;
00E944  2               ;================================================================================
00E944  2               ;
00E944  2               ;bcdasc: CONVERT BCD DIGIT TO ASCII
00E944  2               ;
00E944  2               ;	---------------------------------------
00E944  2               ;	Preparatory Ops: .A: BCD digit, $00-$99
00E944  2               ;
00E944  2               ;	Returned Values: .A: ASCII MSD
00E944  2               ;	                 .X: ASCII LSD
00E944  2               ;	                 .Y: entry value
00E944  2               ;	---------------------------------------
00E944  2               ;
00E944  2               bcdasc:
00E944  2  20 50 E9             JSR     bintonyb        ;extract nybbles
00E947  2  48                   PHA                     ;save tens
00E948  2  8A                   TXA
00E949  2  09 30                ORA     #btoamask       ;change units to ASCII
00E94B  2  AA                   TAX                     ;store
00E94C  2  68                   PLA                     ;get tens
00E94D  2  09 30                ORA     #btoamask       ;change to ASCII
00E94F  2  60                   RTS
00E950  2               ;
00E950  2               ;================================================================================
00E950  2               ;
00E950  2               ;bintonyb: EXTRACT BINARY NYBBLES
00E950  2               ;
00E950  2               ;	---------------------------------
00E950  2               ;	Preparatory Ops: .A: binary value
00E950  2               ;
00E950  2               ;	Returned Values: .A: MSN
00E950  2               ;	                 .X: LSN
00E950  2               ;	                 .Y: entry value
00E950  2               ;	---------------------------------
00E950  2               ;
00E950  2               bintonyb:
00E950  2  48                   PHA                     ;save
00E951  2  29 0F                AND     #bcdumask       ;extract LSN
00E953  2  AA                   TAX                     ;save it
00E954  2  68                   PLA
00E955  2               ;         .rept s_bnybbl        ;extract MSN
00E955  2  4A                   LSR
00E956  2  4A                   LSR
00E957  2  4A                   LSR
00E958  2  4A                   LSR
00E959  2               ;         .endr
00E959  2  60                   RTS
00E95A  2               ;
00E95A  2               ;================================================================================
00E95A  2               ;
00E95A  2               ;binasc: CONVERT 32-BIT BINARY TO NULL-TERMINATED ASCII NUMBER STRING
00E95A  2               ;
00E95A  2               ;	------------------------------------------------------
00E95A  2               ;	Preparatory Ops: FACA: 32-bit operand
00E95A  2               ;	                   .A: radix character, w/bit 7 set to
00E95A  2               ;	                       suppress radix symbol in the
00E95A  2               ;	                       conversion string
00E95A  2               ;
00E95A  2               ;	Returned Values: ibuffer: conversion string
00E95A  2               ;	                      .A: string length
00E95A  2               ;	                      .X: string address LSB
00E95A  2               ;	                      .Y: string address MSB
00E95A  2               ;
00E95A  2               ;	Execution Notes: ibufidx & instsize are overwritten.
00E95A  2               ;	------------------------------------------------------
00E95A  2               ;
00E95A  2               binasc:
00E95A  2  64 3D                STZ     ibufidx         ;initialize string index
00E95C  2  64 44                STZ     instsize        ;clear format flag
00E95E  2               ;
00E95E  2               ;
00E95E  2               ;	evaluate radix...
00E95E  2               ;
00E95E  2  0A                   ASL                     ;extract format flag &...
00E95F  2  66 44                ROR     instsize        ;save it
00E961  2  4A                   LSR                     ;extract radix character
00E962  2  A2 03                LDX     #n_radix-1      ;total radices
00E964  2               ;
00E964  2               _0290010:
00E964  2  DD D3 ED             CMP     radxtab,x       ;recognized radix?
00E967  2  F0 04                BEQ     _0290020        ;yes
00E969  2               ;
00E969  2  CA                   DEX
00E96A  2  10 F8                BPL     _0290010        ;try next
00E96C  2               ;
00E96C  2  E8                   INX                     ;assume hex
00E96D  2               ;
00E96D  2               _0290020:
00E96D  2  86 40                STX     radix           ;save radix index for later
00E96F  2  24 44                BIT     instsize
00E971  2  30 08                BMI     _0290030        ;no radix symbol wanted
00E973  2               ;
00E973  2  BD D3 ED             LDA     radxtab,x       ;radix table
00E976  2  8D 00 02             STA     ibuffer         ;prepend to string
00E979  2  E6 3D                INC     ibufidx         ;bump string index
00E97B  2               ;
00E97B  2               _0290030:
00E97B  2  C9 2B                CMP     #c_dec          ;converting to decimal?
00E97D  2  D0 07                BNE     _0290040        ;no
00E97F  2               ;
00E97F  2  20 13 EA             JSR     facabcd         ;convert operand to BCD
00E982  2  A9 00                LDA     #0
00E984  2  80 17                BRA     _0290070        ;skip binary stuff
00E986  2               ;
00E986  2               ;
00E986  2               ;	prepare for binary, octal or hex conversion...
00E986  2               ;
00E986  2               _0290040:
00E986  2  A2 00                LDX     #0              ;operand index
00E988  2  A0 05                LDY     #s_sfac-1       ;workspace index
00E98A  2               ;
00E98A  2               _0290050:
00E98A  2  B5 25                LDA     faca,x          ;copy operand to...
00E98C  2  99 2D 00             STA     facb,y          ;workspace in...
00E98F  2  88                   DEY                     ;big-endian order
00E990  2  E8                   INX
00E991  2  E0 04                CPX     #s_pfac
00E993  2  D0 F5                BNE     _0290050
00E995  2               ;
00E995  2  A9 00                LDA     #0
00E997  2  BB                   TYX
00E998  2               ;
00E998  2               _0290060:
00E998  2  95 2D                STA     facb,x          ;pad workspace
00E99A  2  CA                   DEX
00E99B  2  10 FB                BPL     _0290060
00E99D  2               ;
00E99D  2               ;
00E99D  2               ;	set up conversion parameters...
00E99D  2               ;
00E99D  2               _0290070:
00E99D  2  85 33                STA     facc            ;initialize byte counter
00E99F  2  A4 40                LDY     radix           ;radix index
00E9A1  2  B9 CF ED             LDA     numstab,y       ;numerals in string
00E9A4  2  85 34                STA     facc+s_byte     ;set remaining numeral count
00E9A6  2  B9 C7 ED             LDA     bitsntab,y      ;bits per numeral
00E9A9  2  85 35                STA     facc+s_word     ;set
00E9AB  2  B9 CB ED             LDA     lzsttab,y       ;leading zero threshold
00E9AE  2  85 36                STA     facc+s_xword    ;set
00E9B0  2               ;
00E9B0  2               ;
00E9B0  2               ;	generate conversion string...
00E9B0  2               ;
00E9B0  2               _0290080:
00E9B0  2  A9 00                LDA     #0
00E9B2  2  A4 35                LDY     facc+s_word     ;bits per numeral
00E9B4  2               ;
00E9B4  2               _0290090:
00E9B4  2  A2 05                LDX     #s_sfac-1       ;workspace size
00E9B6  2  18                   CLC                     ;avoid starting carry
00E9B7  2               ;
00E9B7  2               _0290100:
00E9B7  2  36 2D                ROL     facb,x          ;shift out a bit...
00E9B9  2  CA                   DEX                     ;from the operand or...
00E9BA  2  10 FB                BPL     _0290100        ;BCD conversion result
00E9BC  2               ;
00E9BC  2  2A                   ROL                     ;bit to .A
00E9BD  2  88                   DEY
00E9BE  2  D0 F4                BNE     _0290090        ;more bits to grab
00E9C0  2               ;
00E9C0  2  A8                   TAY                     ;if numeral isn't zero...
00E9C1  2  D0 0A                BNE     _0290110        ;skip leading zero tests
00E9C3  2               ;
00E9C3  2  A6 34                LDX     facc+s_byte     ;remaining numerals
00E9C5  2  E4 36                CPX     facc+s_xword    ;leading zero threshold
00E9C7  2  90 04                BCC     _0290110        ;below it, must convert
00E9C9  2               ;
00E9C9  2  A6 33                LDX     facc            ;processed byte count
00E9CB  2  F0 11                BEQ     _0290130        ;discard leading zero
00E9CD  2               ;
00E9CD  2               _0290110:
00E9CD  2  C9 0A                CMP     #10             ;check range
00E9CF  2  90 02                BCC     _0290120        ;is 0-9
00E9D1  2               ;
00E9D1  2  69 06                ADC     #a_hexdec       ;apply hex adjust
00E9D3  2               ;
00E9D3  2               _0290120:
00E9D3  2  69 30                ADC     #'0'            ;change to ASCII
00E9D5  2  A4 3D                LDY     ibufidx         ;string index
00E9D7  2  99 00 02             STA     ibuffer,y       ;save numeral in buffer
00E9DA  2  E6 3D                INC     ibufidx         ;next buffer position
00E9DC  2  E6 33                INC     facc            ;bytes=bytes+1
00E9DE  2               ;
00E9DE  2               _0290130:
00E9DE  2  C6 34                DEC     facc+s_byte     ;numerals=numerals-1
00E9E0  2  D0 CE                BNE     _0290080        ;not done
00E9E2  2               ;
00E9E2  2               ;
00E9E2  2               ;	terminate string & exit...
00E9E2  2               ;
00E9E2  2  A6 3D                LDX     ibufidx         ;printable string length
00E9E4  2  9E 00 02             STZ     ibuffer,x       ;terminate string
00E9E7  2  8A                   TXA
00E9E8  2  A2 00                LDX     #<ibuffer       ;converted string
00E9EA  2  A0 02                LDY     #>ibuffer
00E9EC  2  18                   CLC                     ;all okay
00E9ED  2  60                   RTS
00E9EE  2               ;
00E9EE  2               ;================================================================================
00E9EE  2               ;
00E9EE  2               ;binhex: CONVERT BINARY BYTE TO HEX ASCII CHARS
00E9EE  2               ;
00E9EE  2               ;	--------------------------------------------
00E9EE  2               ;	Preparatory Ops: .A: byte to convert
00E9EE  2               ;
00E9EE  2               ;	Returned Values: .A: MSN ASCII char
00E9EE  2               ;	                 .X: LSN ASCII char
00E9EE  2               ;	                 .Y: entry value
00E9EE  2               ;	--------------------------------------------
00E9EE  2               ;
00E9EE  2               binhex:
00E9EE  2  20 50 E9             JSR     bintonyb        ;generate binary values
00E9F1  2  48                   PHA                     ;save MSN
00E9F2  2  8A                   TXA
00E9F3  2  20 F8 E9             JSR     _0300010        ;generate ASCII LSN
00E9F6  2  AA                   TAX                     ;save
00E9F7  2  68                   PLA                     ;get input
00E9F8  2               ;
00E9F8  2               ;
00E9F8  2               ;	convert nybble to hex ASCII equivalent...
00E9F8  2               ;
00E9F8  2               _0300010:
00E9F8  2  C9 0A                CMP     #10
00E9FA  2  90 02                BCC     _0300020        ;in decimal range
00E9FC  2               ;
00E9FC  2  69 66                ADC     #k_hex          ;hex compensate
00E9FE  2               ;
00E9FE  2               _0300020:
00E9FE  2  49 30                EOR     #'0'            ;finalize nybble
00EA00  2  60                   RTS                     ;done
00EA01  2               ;
00EA01  2               ;================================================================================
00EA01  2               ;
00EA01  2               ;clrfaca: CLEAR FLOATING ACCUMULATOR A
00EA01  2               ;
00EA01  2               clrfaca:
00EA01  2  08                   PHP
00EA02  2  C2 20                SLONGA
00EA04  2  64 25                STZ     faca
00EA06  2  64 27                STZ     faca+s_word
00EA08  2  28                   PLP
00EA09  2  60                   RTS
00EA0A  2               ;
00EA0A  2               ;================================================================================
00EA0A  2               ;
00EA0A  2               ;clrfacb: CLEAR FLOATING ACCUMULATOR B
00EA0A  2               ;
00EA0A  2               clrfacb:
00EA0A  2  08                   PHP
00EA0B  2  C2 20                SLONGA
00EA0D  2  64 2D                STZ     facb
00EA0F  2  64 2F                STZ     facb+s_word
00EA11  2  28                   PLP
00EA12  2  60                   RTS
00EA13  2               ;
00EA13  2               ;================================================================================
00EA13  2               ;
00EA13  2               ;facabcd: CONVERT FACA INTO BCD
00EA13  2               ;
00EA13  2               facabcd:
00EA13  2  A2 03                LDX     #s_pfac-1       ;primary accumulator size -1
00EA15  2               ;
00EA15  2               _1300010:
00EA15  2  B5 25                LDA     faca,x          ;value to be converted
00EA17  2  48                   PHA                     ;preserve
00EA18  2  CA                   DEX
00EA19  2  10 FA                BPL     _1300010        ;next
00EA1B  2               ;
00EA1B  2  A2 05                LDX     #s_sfac-1       ;workspace size
00EA1D  2               ;
00EA1D  2               _1300020:
00EA1D  2  74 2D                STZ     facb,x          ;clear final result
00EA1F  2  74 33                STZ     facc,x          ;clear scratchpad
00EA21  2  CA                   DEX
00EA22  2  10 F9                BPL     _1300020
00EA24  2               ;
00EA24  2  E6 38                INC     facc+s_sfac-s_byte
00EA26  2  F8                   SED                     ;select decimal mode
00EA27  2  A0 1F                LDY     #m_bits-1       ;bits to convert -1
00EA29  2               ;
00EA29  2               _1300030:
00EA29  2  A2 03                LDX     #s_pfac-1       ;operand size
00EA2B  2  18                   CLC                     ;no carry at start
00EA2C  2               ;
00EA2C  2               _1300040:
00EA2C  2  76 25                ROR     faca,x          ;grab LS bit in operand
00EA2E  2  CA                   DEX
00EA2F  2  10 FB                BPL     _1300040
00EA31  2               ;
00EA31  2  90 0D                BCC     _1300060        ;LS bit clear
00EA33  2               ;
00EA33  2  18                   CLC
00EA34  2  A2 05                LDX     #s_sfac-1
00EA36  2               ;
00EA36  2               _1300050:
00EA36  2  B5 2D                LDA     facb,x          ;partial result
00EA38  2  75 33                ADC     facc,x          ;scratchpad
00EA3A  2  95 2D                STA     facb,x          ;new partial result
00EA3C  2  CA                   DEX
00EA3D  2  10 F7                BPL     _1300050
00EA3F  2               ;
00EA3F  2  18                   CLC
00EA40  2               ;
00EA40  2               _1300060:
00EA40  2  A2 05                LDX     #s_sfac-1
00EA42  2               ;
00EA42  2               _1300070:
00EA42  2  B5 33                LDA     facc,x          ;scratchpad
00EA44  2  75 33                ADC     facc,x          ;double &...
00EA46  2  95 33                STA     facc,x          ;save
00EA48  2  CA                   DEX
00EA49  2  10 F7                BPL     _1300070
00EA4B  2               ;
00EA4B  2  88                   DEY
00EA4C  2  10 DB                BPL     _1300030        ;next operand bit
00EA4E  2               ;
00EA4E  2  D8                   CLD
00EA4F  2  A2 00                LDX     #0
00EA51  2  A0 04                LDY     #s_pfac
00EA53  2               ;
00EA53  2               _1300080:
00EA53  2  68                   PLA                     ;operand
00EA54  2  95 25                STA     faca,x          ;restore
00EA56  2  E8                   INX
00EA57  2  88                   DEY
00EA58  2  D0 F9                BNE     _1300080        ;next
00EA5A  2               ;
00EA5A  2  60                   RTS
00EA5B  2               ;
00EA5B  2               ;================================================================================
00EA5B  2               ;
00EA5B  2               ;nybtobin: CONVERT ASCII NYBBLE TO BINARY
00EA5B  2               ;
00EA5B  2               nybtobin:
00EA5B  2  20 E3 EC             JSR     toupper         ;convert case if necessary
00EA5E  2  38                   SEC
00EA5F  2  E9 30                SBC     #'0'            ;change to binary
00EA61  2  90 08                BCC     _0310020        ;not a numeral - error
00EA63  2               ;
00EA63  2  C9 0A                CMP     #10
00EA65  2  90 03                BCC     _0310010        ;numeral is 0-9
00EA67  2               ;
00EA67  2  E9 07                SBC     #a_hexdec+1     ;10-15 --> A-F
00EA69  2  18                   CLC                     ;no conversion error
00EA6A  2               ;
00EA6A  2               _0310010:
00EA6A  2  60                   RTS
00EA6B  2               ;
00EA6B  2               _0310020:
00EA6B  2  38                   SEC                     ;conversion error
00EA6C  2  60                   RTS
00EA6D  2               ;
00EA6D  2               ;================================================================================
00EA6D  2               ;
00EA6D  2               ;calccnt: COMPUTE BYTE COUNT FROM ADDRESS RANGE
00EA6D  2               ;
00EA6D  2               calccnt:
00EA6D  2  20 0A EA             JSR     clrfacb         ;clear accumulator
00EA70  2  C2 20                SLONGA
00EA72  2  38                   SEC
00EA73  2  A5 22                LDA     addrb           ;ending address
00EA75  2  E5 1F                SBC     addra           ;starting address
00EA77  2  85 2D                STA     facb            ;byte count
00EA79  2  E2 20                SHORTA
00EA7B  2  A5 24                LDA     addrb+s_word    ;handle banks
00EA7D  2  E5 21                SBC     addra+s_word
00EA7F  2  85 2F                STA     facb+s_word
00EA81  2  60                   RTS
00EA82  2               ;
00EA82  2               ;================================================================================
00EA82  2               ;
00EA82  2               ;clroper: CLEAR OPERAND
00EA82  2               ;
00EA82  2               clroper:
00EA82  2  DA                   PHX
00EA83  2  A2 02                LDX     #s_oper-1
00EA85  2               ;
00EA85  2               _0320010:
00EA85  2  74 39                STZ     operand,x
00EA87  2  CA                   DEX
00EA88  2  10 FB                BPL     _0320010
00EA8A  2               ;
00EA8A  2  64 4B                STZ     eopsize
00EA8C  2  FA                   PLX
00EA8D  2  60                   RTS
00EA8E  2               ;
00EA8E  2               ;================================================================================
00EA8E  2               ;
00EA8E  2               ;cpfwsup: FOWARD COPY MEMORY SETUP
00EA8E  2               ;
00EA8E  2               cpfwsup:
00EA8E  2  C2 30                LONGR
00EA90  2  A2 54 00             LDXW    opc_mvn         ;"move next" opcode
00EA93  2  80 05                BRA     cpsup
00EA95  2               ;
00EA95  2               ;================================================================================
00EA95  2               ;
00EA95  2               ;cprvsup: REVERSE COPY MEMORY SETUP
00EA95  2               ;
00EA95  2               cprvsup:
00EA95  2  C2 30                LONGR
00EA97  2  A2 44 00             LDXW    opc_mvp         ;"move previous" opcode
00EA9A  2               ;
00EA9A  2               ;================================================================================
00EA9A  2               ;
00EA9A  2               ;cpsup: COPY MEMORY SETUP
00EA9A  2               ;
00EA9A  2               cpsup:
00EA9A  2  48                   PHA                     ;save banks
00EA9B  2  8A                   TXA                     ;protect...
00EA9C  2  EB                   XBA                     ;opcode
00EA9D  2  E2 20                SHORTA
00EA9F  2  A2 08 00             LDXW    copylen
00EAA2  2               ;
00EAA2  2               _1320010:
00EAA2  2  BF 8F ED 00          LDALX   cpcode          ;transfer copy code to...
00EAA6  2  95 25                STA     mcftwork,x      ;to workspace
00EAA8  2  CA                   DEX
00EAA9  2  10 F7                BPL     _1320010
00EAAB  2               ;
00EAAB  2  EB                   XBA                     ;recover opcode &...
00EAAC  2  85 26                STA     mcftopc         ;set it
00EAAE  2  C2 20                SLONGA
00EAB0  2  68                   PLA                     ;get banks &...
00EAB1  2  85 27                STA     mcftbnk         ;set them
00EAB3  2  60                   RTS
00EAB4  2               ;
00EAB4  2               ;================================================================================
00EAB4  2               ;
00EAB4  2               ;decdcnt: DECREMENT DUMP COUNT
00EAB4  2               ;
00EAB4  2               ;	-------------------------------------------
00EAB4  2               ;	Preparatory Ops: bytes to process in FACB
00EAB4  2               ;	                 bytes processed in CHARCNT
00EAB4  2               ;
00EAB4  2               ;	Returned Values: .A: used
00EAB4  2               ;	                 .X: entry value
00EAB4  2               ;	                 .Y: entry value
00EAB4  2               ;	                 .C: 1 = count = zero
00EAB4  2               ;	-------------------------------------------
00EAB4  2               ;
00EAB4  2               decdcnt:
00EAB4  2  E2 20                SHORTA
00EAB6  2  A9 00                LDA     #0
00EAB8  2  EB                   XBA                     ;clear .B
00EAB9  2  A5 2F                LDA     facb+s_word     ;count MSW
00EABB  2  C2 20                SLONGA
00EABD  2  38                   SEC
00EABE  2  05 2D                ORA     facb            ;count LSW
00EAC0  2  F0 13                BEQ     _0330020        ;zero, just exit
00EAC2  2               ;
00EAC2  2  A5 2D                LDA     facb
00EAC4  2  E5 42                SBC     charcnt         ;bytes processed
00EAC6  2  85 2D                STA     facb
00EAC8  2  E2 20                SHORTA
00EACA  2  A5 2F                LDA     facb+s_word
00EACC  2  E9 00                SBC     #0              ;handle borrow
00EACE  2  90 04                BCC     _0330010        ;underflow
00EAD0  2               ;
00EAD0  2  85 2F                STA     facb+s_word
00EAD2  2  18                   CLC                     ;count > 0
00EAD3  2  60                   RTS
00EAD4  2               ;
00EAD4  2               _0330010:
00EAD4  2  38                   SEC
00EAD5  2               ;
00EAD5  2               _0330020:
00EAD5  2  E2 20                SHORTA
00EAD7  2  60                   RTS
00EAD8  2               ;
00EAD8  2               ;================================================================================
00EAD8  2               ;
00EAD8  2               ;enddest: GET 2ND & 3RD ADDRESSES FOR COMPARE & TRANSFER
00EAD8  2               ;
00EAD8  2               enddest:
00EAD8  2  20 1C EB             JSR     facasize        ;check start...
00EADB  2  C9 04                CMP     #s_dword        ;for range
00EADD  2  B0 1E                BCS     _0340010        ;out of range - error
00EADF  2               ;
00EADF  2  20 FE EA             JSR     facaddra        ;store start
00EAE2  2  20 2C EB             JSR     getparm         ;get end
00EAE5  2  B0 16                BCS     _0340010        ;not entered - error
00EAE7  2               ;
00EAE7  2  20 1C EB             JSR     facasize        ;check end...
00EAEA  2  C9 04                CMP     #s_dword        ;for range
00EAEC  2  B0 0F                BCS     _0340010        ;out of range - error
00EAEE  2               ;
00EAEE  2  20 08 EB             JSR     facaddrb        ;store end
00EAF1  2  20 2C EB             JSR     getparm         ;get destination
00EAF4  2  B0 07                BCS     _0340010        ;not entered - error
00EAF6  2               ;
00EAF6  2  20 1C EB             JSR     facasize        ;check destination...
00EAF9  2  C9 04                CMP     #s_dword        ;for range
00EAFB  2  90 15                BCC     facaoper        ;store dest address
00EAFD  2               ;
00EAFD  2               _0340010:
00EAFD  2  60                   RTS                     ;exit w/error
00EAFE  2               ;
00EAFE  2               ;================================================================================
00EAFE  2               ;
00EAFE  2               ;facaddra: COPY FACA TO ADDRA
00EAFE  2               ;
00EAFE  2               facaddra:
00EAFE  2  A2 02                LDX     #s_xword-1
00EB00  2               ;
00EB00  2               _0350010:
00EB00  2  B5 25                LDA     faca,x
00EB02  2  95 1F                STA     addra,x
00EB04  2  CA                   DEX
00EB05  2  10 F9                BPL     _0350010
00EB07  2               ;
00EB07  2  60                   RTS
00EB08  2               ;
00EB08  2               ;================================================================================
00EB08  2               ;
00EB08  2               ;facaddrb: COPY FACA TO ADDRB
00EB08  2               ;
00EB08  2               facaddrb:
00EB08  2  A2 02                LDX     #s_xword-1
00EB0A  2               ;
00EB0A  2               _1350010:
00EB0A  2  B5 25                LDA     faca,x
00EB0C  2  95 22                STA     addrb,x
00EB0E  2  CA                   DEX
00EB0F  2  10 F9                BPL     _1350010
00EB11  2               ;
00EB11  2  60                   RTS
00EB12  2               ;
00EB12  2               ;================================================================================
00EB12  2               ;
00EB12  2               ;facaoper: COPY FACA TO OPERAND
00EB12  2               ;
00EB12  2               facaoper:
00EB12  2  A2 02                LDX     #s_oper-1
00EB14  2               ;
00EB14  2               _0360010:
00EB14  2  B5 25                LDA     faca,x
00EB16  2  95 39                STA     operand,x
00EB18  2  CA                   DEX
00EB19  2  10 F9                BPL     _0360010
00EB1B  2               ;
00EB1B  2  60                   RTS
00EB1C  2               ;
00EB1C  2               ;================================================================================
00EB1C  2               ;
00EB1C  2               ;facasize: REPORT OPERAND SIZE IN FACA
00EB1C  2               ;
00EB1C  2               ;	------------------------------------------
00EB1C  2               ;	Preparatory Ops: operand in FACA
00EB1C  2               ;
00EB1C  2               ;	Returned Values: .A: s_byte  (1)
00EB1C  2               ;	                     s_word  (2)
00EB1C  2               ;	                     s_xword (3)
00EB1C  2               ;	                     s_dword (4)
00EB1C  2               ;
00EB1C  2               ;	Notes: 1) This function will always report
00EB1C  2               ;	          a non-zero result.
00EB1C  2               ;	------------------------------------------
00EB1C  2               ;
00EB1C  2               facasize:
00EB1C  2  E2 30                SHORTR
00EB1E  2  A2 03                LDX     #s_dword-1
00EB20  2               ;
00EB20  2               _0370010:
00EB20  2  B5 25                LDA     faca,x          ;get byte
00EB22  2  D0 03                BNE     _0370020        ;done
00EB24  2               ;
00EB24  2  CA                   DEX
00EB25  2  D0 F9                BNE     _0370010        ;next byte
00EB27  2               ;
00EB27  2               _0370020:
00EB27  2  E8                   INX                     ;count=index+1
00EB28  2  8A                   TXA
00EB29  2  60                   RTS
00EB2A  2               ;
00EB2A  2               ;================================================================================
00EB2A  2               ;
00EB2A  2               ;getparm: GET A PARAMETER
00EB2A  2               ;
00EB2A  2               ;	-------------------------------------------------
00EB2A  2               ;	Preparatory Ops: null-terminated input in IBUFFER
00EB2A  2               ;
00EB2A  2               ;	Returned Values: .A: chars in converted parameter
00EB2A  2               ;	                 .X: used
00EB2A  2               ;	                 .Y: entry value
00EB2A  2               ;	                 .C: 1 = no parameter entered
00EB2A  2               ;	-------------------------------------------------
00EB2A  2               ;
00EB2A  2               getparmr:
00EB2A  2  C6 3D                DEC     ibufidx         ;reread previous char
00EB2C  2               ;
00EB2C  2               getparm:
00EB2C  2  5A                   PHY                     ;preserve
00EB2D  2  20 96 E8             JSR     ascbin          ;convert parameter to binary
00EB30  2  B0 1C                BCS     _0380040        ;conversion error
00EB32  2               ;
00EB32  2  20 1B EC             JSR     getcharr        ;reread last char
00EB35  2  D0 08                BNE     _0380010        ;not end-of-input
00EB37  2               ;
00EB37  2  C6 3D                DEC     ibufidx         ;reindex to terminator
00EB39  2  A5 42                LDA     charcnt         ;get chars processed so far
00EB3B  2  F0 0C                BEQ     _0380030        ;none
00EB3D  2               ;
00EB3D  2  D0 08                BNE     _0380020        ;some
00EB3F  2               ;
00EB3F  2               _0380010:
00EB3F  2  C9 20                CMP     #a_blank        ;recognized delimiter
00EB41  2  F0 04                BEQ     _0380020        ;end of parameter
00EB43  2               ;
00EB43  2  C9 2C                CMP     #','            ;recognized delimiter
00EB45  2  D0 07                BNE     _0380040        ;unknown delimter
00EB47  2               ;
00EB47  2               _0380020:
00EB47  2  18                   CLC
00EB48  2  24                   .BYTE   bitzp           ;skip SEC below
00EB49  2               ;
00EB49  2               _0380030:
00EB49  2  38                   SEC
00EB4A  2  7A                   PLY                     ;restore
00EB4B  2  A5 42                LDA     charcnt         ;get count
00EB4D  2  60                   RTS                     ;done
00EB4E  2               ;
00EB4E  2               _0380040:                       ;.rept 3               ;clean up stack
00EB4E  2  68                   PLA
00EB4F  2  68                   PLA
00EB50  2  68                   PLA
00EB51  2               ;.endr
00EB51  2  4C 1B E2             JMP     monerr          ;abort w/error
00EB54  2               ;
00EB54  2               ;================================================================================
00EB54  2               ;
00EB54  2               ;nxtaddra: TEST & INCREMENT WORKING ADDRESS 'A'
00EB54  2               ;
00EB54  2               ;	--------------------------------------------------
00EB54  2               ;	Calling syntax: JSR NXTADDRA
00EB54  2               ;
00EB54  2               ;	Exit registers: .A: used
00EB54  2               ;	                .B: used
00EB54  2               ;	                .X: entry value
00EB54  2               ;	                .Y: entry value
00EB54  2               ;	                DB: entry value
00EB54  2               ;	                DP: entry value
00EB54  2               ;	                PB: entry value
00EB54  2               ;	                SR: NVmxDIZC
00EB54  2               ;	                    ||||||||
00EB54  2               ;	                    |||||||+---> 0: ADDRA < ADDRB
00EB54  2               ;	                    |||||||      1: ADDRA >= ADDRB
00EB54  2               ;	                    ||||||+----> undefined
00EB54  2               ;	                    |||+++-----> entry value
00EB54  2               ;	                    ||+--------> 1
00EB54  2               ;	                    ++---------> undefined
00EB54  2               ;	--------------------------------------------------
00EB54  2               ;
00EB54  2               nxtaddra:
00EB54  2  E2 20                SHORTA
00EB56  2  A5 21                LDA     addra+s_word    ;bits 16-23
00EB58  2  C5 24                CMP     addrb+s_word
00EB5A  2  90 0F                BCC     incaddra        ;increment
00EB5C  2               ;
00EB5C  2  D0 0A                BNE     _0390010        ;don't increment
00EB5E  2               ;
00EB5E  2  C2 20                SLONGA
00EB60  2  A5 1F                LDA     addra           ;bits 0-15
00EB62  2  C5 22                CMP     addrb           ;condition flags
00EB64  2  E2 20                SHORTA
00EB66  2  90 03                BCC     incaddra        ;increment
00EB68  2               ;
00EB68  2               _0390010:
00EB68  2  60                   RTS
00EB69  2               ;
00EB69  2               ;================================================================================
00EB69  2               ;
00EB69  2               ;getbyte: GET A BYTE FROM MEMORY
00EB69  2               ;
00EB69  2               getbyte:
00EB69  2  A7 1F                LDAIL   addra           ;get a byte
00EB6B  2               ;
00EB6B  2               ;================================================================================
00EB6B  2               ;
00EB6B  2               ;incaddra: INCREMENT WORKING ADDRESS 'A'
00EB6B  2               ;
00EB6B  2               ;	--------------------------------------------------
00EB6B  2               ;	Calling syntax: JSR INCADDRA
00EB6B  2               ;
00EB6B  2               ;	Exit registers: .A: entry value
00EB6B  2               ;	                .B: entry value
00EB6B  2               ;	                .X: entry value
00EB6B  2               ;	                .Y: entry value
00EB6B  2               ;	                DB: entry value
00EB6B  2               ;	                DP: entry value
00EB6B  2               ;	                PB: entry value
00EB6B  2               ;	                SR: NVmxDIZC
00EB6B  2               ;	                    ||||||||
00EB6B  2               ;	                    ++++++++---> entry value
00EB6B  2               ;	--------------------------------------------------
00EB6B  2               ;
00EB6B  2               incaddra:
00EB6B  2  08                   PHP
00EB6C  2  C2 20                SLONGA
00EB6E  2  E6 1F                INC     addra           ;bump bits 0-15
00EB70  2  D0 04                BNE     _0400010
00EB72  2               ;
00EB72  2  E2 20                SHORTA
00EB74  2  E6 21                INC     addra+s_word    ;bump bits 16-23
00EB76  2               ;
00EB76  2               _0400010:
00EB76  2  28                   PLP
00EB77  2  60                   RTS
00EB78  2               ;
00EB78  2               ;================================================================================
00EB78  2               ;
00EB78  2               ;incoper: INCREMENT OPERAND ADDRESS
00EB78  2               ;
00EB78  2               incoper:
00EB78  2  18                   CLC
00EB79  2  08                   PHP
00EB7A  2  C2 30                LONGR
00EB7C  2  48                   PHA
00EB7D  2  E6 39                INC     operand         ;handle base address
00EB7F  2  D0 06                BNE     _0410010
00EB81  2               ;
00EB81  2  E2 20                SHORTA
00EB83  2  E6 3B                INC     operand+s_word  ;handle bank
00EB85  2  C2 20                SLONGA
00EB87  2               ;
00EB87  2               _0410010:
00EB87  2  68                   PLA
00EB88  2  28                   PLP
00EB89  2  60                   RTS
00EB8A  2               ;
00EB8A  2               ;================================================================================
00EB8A  2               ;
00EB8A  2               ;instdata: GET INSTRUCTION SIZE & ADDRESSING MODE DATA
00EB8A  2               ;
00EB8A  2               ;	----------------------------------
00EB8A  2               ;	Preparatory Ops: .X: 65C816 opcode
00EB8A  2               ;
00EB8A  2               ;	Returned Values: .A: mode flags
00EB8A  2               ;	                 .X: operand size
00EB8A  2               ;	                 .Y: mode index
00EB8A  2               ;	----------------------------------
00EB8A  2               ;
00EB8A  2               instdata:
00EB8A  2  E2 30                SHORTR
00EB8C  2  BD 98 EF             LDA     mnetabam,x      ;addressing mode data
00EB8F  2  48                   PHA                     ;save mode flag bits
00EB90  2  48                   PHA                     ;save size data
00EB91  2  29 0F                AND     #amodmask       ;extract mode index &...
00EB93  2  A8                   TAY                     ;save
00EB94  2  68                   PLA                     ;recover data
00EB95  2  29 30                AND     #opsmask        ;mask mode fields &...
00EB97  2               ;         .rept n_opslsr        ;extract operand size
00EB97  2  4A                   LSR
00EB98  2  4A                   LSR
00EB99  2  4A                   LSR
00EB9A  2  4A                   LSR
00EB9B  2               ;         .endr
00EB9B  2  AA                   TAX                     ;operand size
00EB9C  2  68                   PLA                     ;recover mode flags
00EB9D  2  29 C0                AND     #vopsmask       ;discard mode & size fields
00EB9F  2  60                   RTS
00EBA0  2               ;
00EBA0  2               ;================================================================================
00EBA0  2               ;
00EBA0  2               ;offtarg: CONVERT BRANCH OFFSET TO TARGET ADDRESS
00EBA0  2               ;
00EBA0  2               ;	-----------------------------------------------
00EBA0  2               ;	Preparatory Ops:    ADDRA: base address
00EBA0  2               ;	                 INSTSIZE: instruction size
00EBA0  2               ;	                  OPERAND: offset
00EBA0  2               ;
00EBA0  2               ;	Returned Values:  OPERAND: target address (L/H)
00EBA0  2               ;	                       .A: used
00EBA0  2               ;	                       .X: entry value
00EBA0  2               ;                              .Y: entry value
00EBA0  2               ;	-----------------------------------------------
00EBA0  2               ;
00EBA0  2               offtarg:
00EBA0  2  C2 20                SLONGA
00EBA2  2  A5 1F                LDA     addra           ;base address
00EBA4  2  E2 20                SHORTA
00EBA6  2  46 44                LSR     instsize        ;bit 0 will be set if...
00EBA8  2  B0 07                BCS     _0420010        ;a long branch
00EBAA  2               ;
00EBAA  2  24 39                BIT     operand         ;short forward or backward?
00EBAC  2  10 03                BPL     _0420010        ;forward
00EBAE  2               ;
00EBAE  2  EB                   XBA                     ;expose address MSB
00EBAF  2  3A                   DEA                     ;back a page
00EBB0  2  EB                   XBA                     ;expose address LSB
00EBB1  2               ;
00EBB1  2               _0420010:
00EBB1  2  C2 20                SLONGA
00EBB3  2  18                   CLC
00EBB4  2  65 39                ADC     operand         ;calculate target address
00EBB6  2  85 39                STA     operand         ;new operand
00EBB8  2  E2 20                SHORTA
00EBBA  2  A9 03                LDA     #s_xword
00EBBC  2  85 44                STA     instsize        ;effective instruction size
00EBBE  2  60                   RTS
00EBBF  2               ;
00EBBF  2               ;================================================================================
00EBBF  2               ;
00EBBF  2               ;setxaddr: SET EXECUTION ADDRESS
00EBBF  2               ;
00EBBF  2               setxaddr:
00EBBF  2  B0 13                BCS     _0430010        ;no address given
00EBC1  2               ;
00EBC1  2  20 1C EB             JSR     facasize        ;check address...
00EBC4  2  C9 04                CMP     #s_dword        ;range
00EBC6  2  B0 0D                BCS     _0430020        ;out of range
00EBC8  2               ;
00EBC8  2  C2 20                SLONGA
00EBCA  2  A5 25                LDA     faca            ;execution address
00EBCC  2  85 11                STA     reg_pcx         ;set new PC value
00EBCE  2  E2 20                SHORTA
00EBD0  2  A5 27                LDA     faca+s_word
00EBD2  2  85 10                STA     reg_pbx         ;set new PB value
00EBD4  2               ;
00EBD4  2               _0430010:
00EBD4  2  18                   CLC                     ;no error
00EBD5  2               ;
00EBD5  2               _0430020:
00EBD5  2  60                   RTS
00EBD6  2               ;
00EBD6  2               ;================================================================================
00EBD6  2               ;
00EBD6  2               ;targoff: CONVERT BRANCH TARGET ADDRESS TO BRANCH OFFSET
00EBD6  2               ;
00EBD6  2               ;	-------------------------------------------------
00EBD6  2               ;	Preparatory Ops:   ADDRA: instruction address
00EBD6  2               ;	                 OPERAND: target address
00EBD6  2               ;
00EBD6  2               ;	Returned Values: OPERAND: computed offset
00EBD6  2               ;	                      .A: effective operand size
00EBD6  2               ;	                      .X: entry value
00EBD6  2               ;                             .Y: entry value
00EBD6  2               ;	                      .C: 1 = branch out of range
00EBD6  2               ;
00EBD6  2               ;	Execution notes: ADDRB is set to the branch base
00EBD6  2               ;	                 address.
00EBD6  2               ;	-------------------------------------------------
00EBD6  2               ;
00EBD6  2               targoff:
00EBD6  2  64 45                STZ     instsize+s_byte ;always zero
00EBD8  2  A5 44                LDA     instsize        ;instruction size will tell...
00EBDA  2  4A                   LSR                     ;if long or short branch
00EBDB  2               ;
00EBDB  2               ;-------------------------------------------------
00EBDB  2               _btype          = facc+5        ;branch type flag
00EBDB  2               ;-------------------------------------------------
00EBDB  2               ;
00EBDB  2  66 38                ROR     _btype          ;set branch type...
00EBDD  2               ;
00EBDD  2               ;	x0000000
00EBDD  2               ;	|
00EBDD  2               ;	+----------> 0: short
00EBDD  2               ;	             1: long
00EBDD  2               ;
00EBDD  2  C2 20                SLONGA
00EBDF  2  18                   CLC
00EBE0  2  A5 1F                LDA     addra           ;instruction address
00EBE2  2  65 44                ADC     instsize        ;instruction size
00EBE4  2  85 22                STA     addrb           ;base address
00EBE6  2  38                   SEC
00EBE7  2  A5 39                LDA     operand         ;target address
00EBE9  2  E5 22                SBC     addrb           ;base address
00EBEB  2  85 39                STA     operand         ;offset
00EBED  2  E2 20                SHORTA
00EBEF  2  90 15                BCC     _0440040        ;backward branch
00EBF1  2               ;
00EBF1  2  24 38                BIT     _btype          ;check branch range
00EBF3  2  30 0A                BMI     _0440020        ;long
00EBF5  2               ;
00EBF5  2               ;
00EBF5  2               ;	process short forward branch...
00EBF5  2               ;
00EBF5  2  EB                   XBA                     ;offset MSB should be zero
00EBF6  2  D0 21                BNE     _0440060        ;it isn't - out of range
00EBF8  2               ;
00EBF8  2  EB                   XBA                     ;offset LSB should be $00-$7F
00EBF9  2  30 1E                BMI     _0440060        ;it isn't - out of range
00EBFB  2               ;
00EBFB  2               _0440010:
00EBFB  2  A9 01                LDA     #s_byte         ;final instruction size
00EBFD  2  18                   CLC                     ;branch in range
00EBFE  2  60                   RTS
00EBFF  2               ;
00EBFF  2               ;
00EBFF  2               ;	process long forward branch...
00EBFF  2               ;
00EBFF  2               _0440020:
00EBFF  2  EB                   XBA                     ;offset MSB should be positive
00EC00  2  30 17                BMI     _0440060        ;it isn't - branch out of range
00EC02  2               ;
00EC02  2               _0440030:
00EC02  2  A9 02                LDA     #s_word
00EC04  2  18                   CLC
00EC05  2  60                   RTS
00EC06  2               ;
00EC06  2               ;
00EC06  2               ;	process backward branch...
00EC06  2               ;
00EC06  2               _0440040:
00EC06  2  24 38                BIT     _btype          ;long or short?
00EC08  2  30 0C                BMI     _0440050        ;long
00EC0A  2               ;
00EC0A  2               ;
00EC0A  2               ;	process short backward branch...
00EC0A  2               ;
00EC0A  2  EB                   XBA                     ;offset MSB should be negative
00EC0B  2  10 0C                BPL     _0440060        ;it isn't - out of range
00EC0D  2               ;
00EC0D  2  49 FF                EOR     #%11111111      ;complement offset MSB 2s
00EC0F  2  D0 08                BNE     _0440060        ;out of range
00EC11  2               ;
00EC11  2  EB                   XBA                     ;offset LSB should be $80-$FF
00EC12  2  30 E7                BMI     _0440010        ;it is - branch in range
00EC14  2               ;
00EC14  2  80 03                BRA     _0440060        ;branch out of range
00EC16  2               ;
00EC16  2               ;
00EC16  2               ;	process long backward branch...
00EC16  2               ;
00EC16  2               _0440050:
00EC16  2  EB                   XBA                     ;offset MSB should be negative
00EC17  2  30 E9                BMI     _0440030        ;it is - branch in range
00EC19  2               ;
00EC19  2               _0440060:
00EC19  2  38                   SEC                     ;range error
00EC1A  2  60                   RTS
00EC1B  2               ;
00EC1B  2               ;================================================================================
00EC1B  2               ;
00EC1B  2               ;getcharr: GET PREVIOUS INPUT BUFFER CHARACTER
00EC1B  2               ;
00EC1B  2               getcharr:
00EC1B  2  C6 3D                DEC     ibufidx         ;move back a char
00EC1D  2               ;
00EC1D  2               ;================================================================================
00EC1D  2               ;
00EC1D  2               ;getchar: GET A CHARACTER FROM INPUT BUFFER
00EC1D  2               ;
00EC1D  2               ;	----------------------------------------------
00EC1D  2               ;	Preparatory Ops : none
00EC1D  2               ;
00EC1D  2               ;	Register Returns: .A: character or <NUL>
00EC1D  2               ;	                  .B: entry value
00EC1D  2               ;	                  .X: entry value
00EC1D  2               ;	                  .Y: entry value
00EC1D  2               ;
00EC1D  2               ;	MPU Flags: NVmxDIZC
00EC1D  2               ;	           ||||||||
00EC1D  2               ;	           |||||||+---> entry value
00EC1D  2               ;	           ||||||+----> 1: <NUL> gotten
00EC1D  2               ;	           |||||+-----> entry value
00EC1D  2               ;	           ||||+------> entry value
00EC1D  2               ;	           |||+-------> entry value
00EC1D  2               ;	           ||+--------> entry value
00EC1D  2               ;	           |+---------> not defined
00EC1D  2               ;	           +----------> not defined
00EC1D  2               ;	----------------------------------------------
00EC1D  2               ;
00EC1D  2               getchar:
00EC1D  2  DA                   PHX
00EC1E  2  5A                   PHY
00EC1F  2  08                   PHP                     ;save register sizes
00EC20  2  E2 30                SHORTR                  ;force 8 bits
00EC22  2  A6 3D                LDX     ibufidx         ;buffer index
00EC24  2  BD 00 02             LDA     ibuffer,x       ;get char
00EC27  2  E6 3D                INC     ibufidx         ;bump index
00EC29  2  28                   PLP                     ;restore register widths
00EC2A  2  7A                   PLY
00EC2B  2  FA                   PLX
00EC2C  2  EB                   XBA                     ;condition...
00EC2D  2  EB                   XBA                     ;.Z
00EC2E  2  60                   RTS
00EC2F  2               ;
00EC2F  2               ;================================================================================
00EC2F  2               ;
00EC2F  2               ;getpat: GET PATTERN FOR MEMORY CHANGE or SEARCH
00EC2F  2               ;
00EC2F  2               ;	-----------------------------------------------------
00EC2F  2               ;	Preparatory Ops: Null-terminated pattern in IBUFFER.
00EC2F  2               ;
00EC2F  2               ;	Returned Values: .A: used
00EC2F  2               ;	                 .X: used
00EC2F  2               ;	                 .Y: pattern length if entered
00EC2F  2               ;	                 .C: 0 = pattern valid
00EC2F  2               ;	                     1 = exception:
00EC2F  2               ;	                 .N  0 = no pattern entered
00EC2F  2               ;	                     1 = evaluation error
00EC2F  2               ;
00EC2F  2               ;	Notes: 1) If pattern is preceded by "'" the following
00EC2F  2               ;	          characters are interpreted as ASCII.
00EC2F  2               ;	       2) A maximum of 32 bytes or characters is
00EC2F  2               ;	          accepted.  Excess input will be discarded.
00EC2F  2               ;	-----------------------------------------------------
00EC2F  2               ;
00EC2F  2               getpat:
00EC2F  2  64 49                STZ     status          ;clear pattern type indicator
00EC31  2  A0 00                LDY     #0              ;pattern index
00EC33  2  20 1B EC             JSR     getcharr        ;get last char
00EC36  2  F0 3C                BEQ     _0450070        ;EOS
00EC38  2               ;
00EC38  2  A6 3D                LDX     ibufidx         ;current buffer index
00EC3A  2  20 7B EC             JSR     getcharw        ;get next
00EC3D  2  F0 35                BEQ     _0450070        ;EOS
00EC3F  2               ;
00EC3F  2  C9 27                CMP     #$27            ; single quote
00EC41  2  D0 04                BNE     _0450010        ;not ASCII input
00EC43  2               ;
00EC43  2  66 49                ROR     status          ;condition flag
00EC45  2  80 12                BRA     _0450030        ;balance of input is ASCII
00EC47  2               ;
00EC47  2               _0450010:
00EC47  2  86 3D                STX     ibufidx         ;restore buffer index
00EC49  2               ;
00EC49  2               _0450020:
00EC49  2  20 2C EB             JSR     getparm         ;evaluate numeric pattern
00EC4C  2  B0 21                BCS     _0450060        ;done w/pattern
00EC4E  2               ;
00EC4E  2  20 1C EB             JSR     facasize        ;size
00EC51  2  C9 02                CMP     #s_word
00EC53  2  B0 1F                BCS     _0450070        ;not a byte - error
00EC55  2               ;
00EC55  2  A5 25                LDA     faca            ;get byte &...
00EC57  2  80 05                BRA     _0450040        ;store
00EC59  2               ;
00EC59  2               _0450030:
00EC59  2  20 1D EC             JSR     getchar         ;get ASCII char
00EC5C  2  F0 11                BEQ     _0450060        ;done w/pattern
00EC5E  2               ;
00EC5E  2               _0450040:
00EC5E  2  C0 20                CPY     #s_auxbuf       ;pattern buffer full?
00EC60  2  F0 0A                BEQ     _0450050        ;yes
00EC62  2               ;
00EC62  2  99 46 02             STA     auxbuf,y        ;store pattern
00EC65  2  C8                   INY
00EC66  2  24 49                BIT     status
00EC68  2  10 DF                BPL     _0450020        ;get next numeric value
00EC6A  2               ;
00EC6A  2  80 ED                BRA     _0450030        ;get next ASCII char
00EC6C  2               ;
00EC6C  2               _0450050:
00EC6C  2  20 74 E8             JSR     alert           ;excess input
00EC6F  2               ;
00EC6F  2               _0450060:
00EC6F  2  84 3C                STY     auxbufix        ;save pattern size
00EC71  2  98                   TYA                     ;condition .Z
00EC72  2  18                   CLC                     ;pattern valid
00EC73  2  60                   RTS
00EC74  2               ;
00EC74  2               ;
00EC74  2               ;	no pattern entered...
00EC74  2               ;
00EC74  2               _0450070:
00EC74  2  C2 80                REP     #%10000000
00EC76  2  38                   SEC
00EC77  2  60                   RTS
00EC78  2               ;
00EC78  2               ;
00EC78  2               ;	evaluation error...
00EC78  2               ;
00EC78  2               _0450080:
00EC78  2  E2 81                SEP     #%10000001
00EC7A  2  60                   RTS
00EC7B  2               ;
00EC7B  2               ;================================================================================
00EC7B  2               ;
00EC7B  2               ;getcharw: GET FROM INPUT BUFFER, DISCARDING WHITESPACE
00EC7B  2               ;
00EC7B  2               ;	--------------------------------------------------
00EC7B  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00EC7B  2               ;
00EC7B  2               ;	Returned Values: .A: char or null
00EC7B  2               ;	                 .X: entry value
00EC7B  2               ;	                 .Y: entry value
00EC7B  2               ;	                 .Z: 1 = null terminator detected
00EC7B  2               ;
00EC7B  2               ;	Notes: Whitespace is defined as a blank ($20) or a
00EC7B  2               ;	       horizontal tab ($09).
00EC7B  2               ;	--------------------------------------------------
00EC7B  2               ;
00EC7B  2               getcharw:
00EC7B  2  20 1D EC             JSR     getchar         ;get from buffer
00EC7E  2  F0 08                BEQ     _0460010        ;EOI
00EC80  2               ;
00EC80  2  C9 20                CMP     #a_blank
00EC82  2  F0 F7                BEQ     getcharw        ;discard whitespace
00EC84  2               ;
00EC84  2  C9 09                CMP     #a_ht           ;also whitespace
00EC86  2  F0 F3                BEQ     getcharw
00EC88  2               ;
00EC88  2               _0460010:
00EC88  2  18                   CLC
00EC89  2  60                   RTS
00EC8A  2               ;
00EC8A  2               ;================================================================================
00EC8A  2               ;
00EC8A  2               ;input: INTERACTIVE INPUT FROM CONSOLE CHANNEL
00EC8A  2               ;
00EC8A  2               ;	-----------------------------------------------------------
00EC8A  2               ;	Preparatory Ops: Zero IBUFIDX or load IBUFFER with default
00EC8A  2               ;	                 input & set IBUFIDX to the number of chars
00EC8A  2               ;	                 loaded into the buffer.
00EC8A  2               ;
00EC8A  2               ;	Returned Values: .A: used
00EC8A  2               ;	                 .X: characters entered
00EC8A  2               ;	                 .Y: used
00EC8A  2               ;
00EC8A  2               ;	Example: STZ IBUFIDX
00EC8A  2               ;	         JSR INPUT
00EC8A  2               ;
00EC8A  2               ;	Notes: Input is collected in IBUFFER & is null-terminated.
00EC8A  2               ;	       IBUFIDX is reset to zero upon exit.
00EC8A  2               ;	-----------------------------------------------------------
00EC8A  2               ;
00EC8A  2               input:
00EC8A  2  A6 3D                LDX     ibufidx
00EC8C  2  9E 00 02             STZ     ibuffer,x       ;be sure buffer is terminated
00EC8F  2  20 F1 E7             JSR     dpyibuf         ;print default input if any
00EC92  2               
00EC92  2  A6 3D                LDX     ibufidx         ;starting buffer index
00EC94  2               ;
00EC94  2               ;
00EC94  2               ;	main input loop...
00EC94  2               ;
00EC94  2               _0470010:
00EC94  2  20 E2 E0             JSR     CURSOR
00EC97  2               _047001A:
00EC97  2  20 74 FF             JSR     getcha          ;poll for input
00EC9A  2  90 02                BCC     _0470020        ;got something
00EC9C  2               ;
00EC9C  2               ;         wai                   ;wait 'til any IRQ &...
00EC9C  2  80 F9                BRA     _047001A        ;try again
00EC9E  2               ;
00EC9E  2               _0470020:
00EC9E  2  C9 7F                CMP     #a_del          ;above ASCII range?
00ECA0  2  B0 F5                BCS     _047001A        ;yes, ignore
00ECA2  2               
00ECA2  2  20 E2 E0             JSR     UNCURSOR
00ECA5  2               ;
00ECA5  2  C9 09                CMP     #a_ht           ;horizontal tab?
00ECA7  2  D0 02                BNE     _0470030        ;no
00ECA9  2               ;
00ECA9  2  A9 20                LDA     #a_blank        ;replace <HT> w/blank
00ECAB  2               ;
00ECAB  2               _0470030:
00ECAB  2  C9 20                CMP     #a_blank        ;control char?
00ECAD  2  90 10                BCC     _0470050        ;yes
00ECAF  2               ;
00ECAF  2               ;
00ECAF  2               ;	process QWERTY character...
00ECAF  2               ;
00ECAF  2  E0 45                CPX     #s_ibuf         ;room in buffer?
00ECB1  2  B0 05                BCS     _0470040        ;no
00ECB3  2               ;
00ECB3  2  9D 00 02             STA     ibuffer,x       ;store char
00ECB6  2  E8                   INX                     ;bump index
00ECB7  2  2C                   .BYTE   bitabs          ;echo char
00ECB8  2               ;
00ECB8  2               _0470040:
00ECB8  2  A9 07                LDA     #a_bel          ;alert user
00ECBA  2  20 71 FF             JSR     putcha
00ECBD  2  80 D5                BRA     _0470010        ;get some more
00ECBF  2               ;
00ECBF  2               ;
00ECBF  2               ;	process carriage return...
00ECBF  2               ;
00ECBF  2               _0470050:
00ECBF  2  C9 0D                CMP     #a_cr           ;carriage return?
00ECC1  2  D0 06                BNE     _0470060        ;no
00ECC3  2               ;
00ECC3  2               ;         phx                   ;protect input count
00ECC3  2               ;         pea dc_co
00ECC3  2               ;         jsr sprint            ;cursor off
00ECC3  2               ;         plx                   ;recover input count
00ECC3  2  9E 00 02             STZ     ibuffer,x       ;terminate input &...
00ECC6  2  64 3D                STZ     ibufidx         ;reset buffer index
00ECC8  2  60                   RTS                     ;done
00ECC9  2               ;
00ECC9  2               ;
00ECC9  2               ;	process backspace...
00ECC9  2               ;
00ECC9  2               _0470060:
00ECC9  2  C9 08                CMP     #a_bs           ;backspace?
00ECCB  2  D0 C7                BNE     _0470010        ;no
00ECCD  2               ;
00ECCD  2  8A                   TXA
00ECCE  2  F0 C4                BEQ     _0470010        ;no input, ignore <BS>
00ECD0  2               ;
00ECD0  2  CA                   DEX                     ;1 less char
00ECD1  2  DA                   PHX                     ;preserve count
00ECD2  2  20 31 E8             JSR     gendbs          ;destructive backspace
00ECD5  2  FA                   PLX                     ;restore count
00ECD6  2  80 BC                BRA     _0470010        ;get more input
00ECD8  2               ;
00ECD8  2               ;================================================================================
00ECD8  2               ;
00ECD8  2               ;lodbnk: LOAD SOURCE & DESTINATION BANKS
00ECD8  2               ;
00ECD8  2               lodbnk:
00ECD8  2  E2 20                SHORTA
00ECDA  2  A5 3B                LDA     operand+s_word  ;destination bank
00ECDC  2  EB                   XBA                     ;make it MSB
00ECDD  2  A5 21                LDA     addra+s_word    ;source bank is LSB
00ECDF  2  60                   RTS
00ECE0  2               ;
00ECE0  2               ;================================================================================
00ECE0  2               ;
00ECE0  2               ;getcharc: GET A CHARACTER FROM INPUT BUFFER & CONVERT CASE
00ECE0  2               ;
00ECE0  2               ;	--------------------------------------------------
00ECE0  2               ;	Preparatory Ops: Null-terminated input in IBUFFER.
00ECE0  2               ;
00ECE0  2               ;	Returned Values: .A: char or null
00ECE0  2               ;	                 .X: entry value
00ECE0  2               ;	                 .Y: entry value
00ECE0  2               ;	                 .Z: 1 = null terminator detected
00ECE0  2               ;	--------------------------------------------------
00ECE0  2               ;
00ECE0  2               getcharc:
00ECE0  2  20 1D EC             JSR     getchar         ;get from buffer
00ECE3  2               ;
00ECE3  2               ;================================================================================
00ECE3  2               ;
00ECE3  2               ;toupper: FORCE CHARACTER TO UPPER CASE
00ECE3  2               ;
00ECE3  2               ;	------------------------------------------------
00ECE3  2               ;	Preparatory Ops : .A: 8 bit character to convert
00ECE3  2               ;
00ECE3  2               ;	Register Returns: .A: converted character
00ECE3  2               ;	                  .B: entry value
00ECE3  2               ;	                  .X: entry value
00ECE3  2               ;	                  .Y: entry value
00ECE3  2               ;
00ECE3  2               ;	MPU Flags: no change
00ECE3  2               ;
00ECE3  2               ;	Notes: 1) This subroutine has no effect on char-
00ECE3  2               ;	          acters that are not alpha.
00ECE3  2               ;	------------------------------------------------
00ECE3  2               ;
00ECE3  2               toupper:
00ECE3  2  08                   PHP                     ;protect flags
00ECE4  2  C9 61                CMP     #a_asclcl       ;check char range
00ECE6  2  90 06                BCC     _0480010        ;not LC alpha
00ECE8  2               ;
00ECE8  2  C9 7B                CMP     #a_asclch+s_byte
00ECEA  2  B0 02                BCS     _0480010        ;not LC alpha
00ECEC  2               ;
00ECEC  2  29 5F                AND     #a_lctouc       ;force to UC
00ECEE  2               ;
00ECEE  2               _0480010:
00ECEE  2  28                   PLP                     ;restore flags
00ECEF  2               ;
00ECEF  2               touppera:
00ECEF  2  60                   RTS
00ECF0  2               ;
00ECF0  2               ;================================================================================
00ECF0  2               ;
00ECF0  2               ;teststop: TEST FOR STOP KEY
00ECF0  2               ;
00ECF0  2               ;	----------------------------------------------
00ECF0  2               ;	Preparatory Ops: none
00ECF0  2               ;
00ECF0  2               ;	Returned Values: .A: detected keypress, if any
00ECF0  2               ;	                 .X: entry value
00ECF0  2               ;	                 .Y: entry value
00ECF0  2               ;
00ECF0  2               ;	MPU Flags: NVmxDIZC
00ECF0  2               ;	           ||||||||
00ECF0  2               ;	           |||||||+---> 0: normal key detected
00ECF0  2               ;	           |||||||      1: <STOP> detected
00ECF0  2               ;	           +++++++----> not defined
00ECF0  2               ;
00ECF0  2               ;	Example: jsr teststop
00ECF0  2               ;	         bcs stopped
00ECF0  2               ;
00ECF0  2               ;	Notes: The symbol STOPKEY defines the ASCII
00ECF0  2               ;	       value of the "stop key."
00ECF0  2               ;	----------------------------------------------
00ECF0  2               ;
00ECF0  2               teststop:
00ECF0  2  20 74 FF             JSR     getcha          ;poll console
00ECF3  2  B0 04                BCS     _0490010        ;no input
00ECF5  2               ;
00ECF5  2  C9 03                CMP     #stopkey        ;stop key pressed?
00ECF7  2  F0 01                BEQ     _0490020        ;yes
00ECF9  2               ;
00ECF9  2               _0490010:
00ECF9  2  18                   CLC
00ECFA  2               ;
00ECFA  2               _0490020:
00ECFA  2  60                   RTS
00ECFB  2               
00ECFB  2               
00ECFB  2               ;__LOAD_________________________________________________________
00ECFB  2               ; LOAD A MOTOROLA FORMATTED HEX FILE (S28)
00ECFB  2               ;
00ECFB  2               ;_______________________________________________________________
00ECFB  2               LOADS19:
00ECFB  2  08                   PHP
00ECFC  2  E2 30                SHORTR
00ECFE  2  F4 60 F1             PEA     mm_S19_prmpt
00ED01  2  20 7D E8             JSR     sprint          ;display input prompt
00ED04  2               
00ED04  2               
00ED04  2               LOADS19_1:
00ED04  2  20 82 ED             JSR     getc            ;
00ED07  2  C9 53                CMP     #'S'            ;
00ED09  2  D0 F9                BNE     LOADS19_1       ; FIRST CHAR NOT (S)
00ED0B  2  20 82 ED             JSR     getc            ; READ CHAR
00ED0E  2  C9 38                CMP     #'8'            ;
00ED10  2  F0 44                BEQ     LOAD21          ;
00ED12  2  C9 32                CMP     #'2'            ;
00ED14  2  D0 EE                BNE     LOADS19_1       ; SECOND CHAR NOT (2)
00ED16  2  A9 00                LDA     #$00            ;
00ED18  2  85 25                STA     faca            ; ZERO CHECKSUM
00ED1A  2               
00ED1A  2  20 5A ED             JSR     GETBYTE         ; READ BYTE
00ED1D  2  E9 02                SBC     #$02            ;
00ED1F  2  85 2D                STA     facb            ; BYTE COUNT
00ED21  2               ; BUILD ADDRESS
00ED21  2  20 5A ED             JSR     GETBYTE         ; READ 2 FRAMES
00ED24  2  85 21                STA     addra+2         ;
00ED26  2  20 5A ED             JSR     GETBYTE         ; READ 2 FRAMES
00ED29  2  85 20                STA     addra+1         ;
00ED2B  2  20 5A ED             JSR     GETBYTE         ;
00ED2E  2  85 1F                STA     addra           ;
00ED30  2               
00ED30  2  A0 00                LDY     #$00            ;
00ED32  2               LOAD11:
00ED32  2  20 5A ED             JSR     GETBYTE         ;
00ED35  2  C6 2D                DEC     facb            ;
00ED37  2  F0 14                BEQ     LOAD15          ; ZERO BYTE COUNT
00ED39  2  97 1F                STA     [addra],Y       ; STORE DATA
00ED3B  2  C2 20                SLONGA
00ED3D  2  E6 1F                INC     addra           ;
00ED3F  2  C9 00 00             CMPW    $0000
00ED42  2  D0 04                BNE     LOAD11A
00ED44  2  E2 20                SHORTA
00ED46  2  E6 21                INC     addra+2         ;
00ED48  2               LOAD11A:
00ED48  2  E2 20                SHORTA
00ED4A  2  4C 32 ED             JMP     LOAD11          ;
00ED4D  2               
00ED4D  2               LOAD15:
00ED4D  2  E6 25                INC     faca            ;
00ED4F  2  F0 B3                BEQ     LOADS19_1       ;
00ED51  2               LOAD19:
00ED51  2  A9 3F                LDA     #'?'            ;
00ED53  2  20 71 FF             JSR     putcha          ;
00ED56  2               LOAD21:
00ED56  2  28                   PLP
00ED57  2  4C DC E1             JMP     monce           ;back to executive
00ED5A  2               GETBYTE:
00ED5A  2  20 72 ED             JSR     INHEX           ; GET HEX CHAR
00ED5D  2  0A                   ASL     A               ;
00ED5E  2  0A                   ASL     A               ;
00ED5F  2  0A                   ASL     A               ;
00ED60  2  0A                   ASL     A               ;
00ED61  2  85 3F                STA     numeral         ;
00ED63  2  20 72 ED             JSR     INHEX           ;
00ED66  2  29 0F                AND     #$0F            ; MASK TO 4 BITS
00ED68  2  05 3F                ORA     numeral         ;
00ED6A  2  48                   PHA                     ;
00ED6B  2  18                   CLC                     ;
00ED6C  2  65 25                ADC     faca            ;
00ED6E  2  85 25                STA     faca            ;
00ED70  2  68                   PLA                     ;
00ED71  2  60                   RTS                     ;
00ED72  2               ; INPUT HEX CHAR
00ED72  2               INHEX:
00ED72  2  20 82 ED             JSR     getc            ;
00ED75  2  C9 3A                CMP     #$3A            ; LESS THAN 9?
00ED77  2  B0 02                BCS     INHEX_BIG       ; NO, SKIP NEXT
00ED79  2  E9 2F                SBC     #$2F            ; CONVERT 0-9
00ED7B  2               INHEX_BIG:
00ED7B  2  C9 41                CMP     #$41            ; A OR MORE?
00ED7D  2  90 02                BCC     INHEX_SMALL     ; NO, SKIP NEXT
00ED7F  2  E9 37                SBC     #$37            ; CONVERT A-F
00ED81  2               INHEX_SMALL:
00ED81  2  60                   RTS                     ;
00ED82  2               getc:
00ED82  2  20 74 FF             JSR     getcha          ;poll for input
00ED85  2  90 02                BCC     getcd           ;got something
00ED87  2  80 F9                BRA     getc            ;try again
00ED89  2               getcd:
00ED89  2  48                   PHA                     ;
00ED8A  2  20 71 FF             JSR     putcha          ;
00ED8D  2  68                   PLA                     ;
00ED8E  2  60                   RTS
00ED8F  2               
00ED8F  2               
00ED8F  2               
00ED8F  2               ;
00ED8F  2               ;cpcode: COPY MEMORY CODE
00ED8F  2               ;
00ED8F  2               ;	-------------------------------------------
00ED8F  2               ;	This code is transfered to workspace when a
00ED8F  2               ;	copy or fill operation is to be performed.
00ED8F  2               ;	-------------------------------------------
00ED8F  2               ;
00ED8F  2               cpcode:
00ED8F  2  8B                   PHB                     ;must preserve data bank
00ED90  2               ;.rept s_mvinst
00ED90  2  EA                   NOP                     ;placeholder
00ED91  2  EA                   NOP                     ;placeholder
00ED92  2  EA                   NOP                     ;placeholder
00ED93  2               ;.endr
00ED93  2  AB                   PLB                     ;restore data bank
00ED94  2  5C DC E1 00          JML     monce           ;return to command executive
00ED98  2               cpcodeee:                       ;placeholder - do not delete
00ED98  2               copylen         = cpcodeee-cpcode-1
00ED98  2               ;
00ED98  2               ;================================================================================
00ED98  2               ;
00ED98  2               ;COMMAND PROCESSING DATA TABLES
00ED98  2               ;
00ED98  2               ;
00ED98  2               ;	monitor commands...
00ED98  2               ;
00ED98  2               mpctab:
00ED98  2  41                   .BYTE   "A"             ;assemble code
00ED99  2  43                   .BYTE   "C"             ;compare memory ranges
00ED9A  2  44                   .BYTE   "D"             ;disassemble code
00ED9B  2  46                   .BYTE   "F"             ;fill memory
00ED9C  2  47                   .BYTE   "G"             ;execute code
00ED9D  2  48                   .BYTE   "H"             ;search memory
00ED9E  2  4A                   .BYTE   "J"             ;execute code as subroutine
00ED9F  2  4C                   .BYTE   "L"             ;load S19 file
00EDA0  2  4D                   .BYTE   "M"             ;dump memory range
00EDA1  2  52                   .BYTE   "R"             ;dump registers
00EDA2  2  54                   .BYTE   "T"             ;copy memory range
00EDA3  2               ;         .BYTE "X"             ;exit from monitor
00EDA3  2  3E                   .BYTE   ">"             ;change memory
00EDA4  2  3B                   .BYTE   ";"             ;change registers
00EDA5  2               n_mpctab        = *-mpctab      ;entries in above table
00EDA5  2               ;
00EDA5  2               ;
00EDA5  2               ;	monitor command jump table...
00EDA5  2               ;
00EDA5  2               mpcextab:
00EDA5  2  21 E2                .WORD   monasc-s_byte   ; A  assemble code
00EDA7  2  E3 E4                .WORD   moncmp-s_byte   ; C  compare memory ranges
00EDA9  2  FD E3                .WORD   mondsc-s_byte   ; D  disassemble code
00EDAB  2  B4 E5                .WORD   monfil-s_byte   ; F  fill memory
00EDAD  2  51 E4                .WORD   monjmp-s_byte   ; G  execute code
00EDAF  2  1A E6                .WORD   monhnt-s_byte   ; H  search memory
00EDB1  2  82 E4                .WORD   monjsr-s_byte   ; J  execute code as subroutine
00EDB3  2  FA EC                .WORD   LOADS19-s_byte  ; L  Load S19 File
00EDB5  2  62 E5                .WORD   mondmp-s_byte   ; M  dump memory range
00EDB7  2  7D E1                .WORD   monreg-s_byte   ; R  dump registers
00EDB9  2  11 E5                .WORD   moncpy-s_byte   ; T  copy memory range
00EDBB  2               ;         .WORD monxit-s_byte   ; X  exit from monitor
00EDBB  2  B8 E4                .WORD   monchm-s_byte   ; >  change memory
00EDBD  2  90 E6                .WORD   monchr-s_byte   ; ;  change registers
00EDBF  2               ;
00EDBF  2               ;
00EDBF  2               ;	number conversion...
00EDBF  2               ;
00EDBF  2               basetab:
00EDBF  2  10 0A 08 02          .BYTE   16,10,8,2       ;supported number bases
00EDC3  2               bitsdtab:
00EDC3  2  04 03 03 01          .BYTE   4,3,3,1         ;bits per binary digit
00EDC7  2               bitsntab:
00EDC7  2  04 04 03 01          .BYTE   4,4,3,1         ;bits per ASCII character
00EDCB  2               lzsttab:
00EDCB  2  03 02 09 02          .BYTE   3,2,9,2         ;leading zero suppression thresholds
00EDCF  2               numstab:
00EDCF  2  0C 0C 10 30          .BYTE   12,12,16,48     ;bin to ASCII conversion numerals
00EDD3  2               radxtab:
00EDD3  2  24                   .BYTE   c_hex           ;hexadecimal radix
00EDD4  2  2B                   .BYTE   c_dec           ;decimal radix
00EDD5  2  40                   .BYTE   c_oct           ;octal radix
00EDD6  2  25                   .BYTE   c_bin           ;binary radix
00EDD7  2               n_radix         = *-radxtab     ;number of recognized radices
00EDD7  2               ;
00EDD7  2               ;
00EDD7  2               ;	shadow MPU register sizes...
00EDD7  2               ;
00EDD7  2               rcvltab:
00EDD7  2  02                   .BYTE   s_mpupbx+s_byte ; PB
00EDD8  2  03                   .BYTE   s_mpupcx+s_byte ; PC
00EDD9  2  02                   .BYTE   s_mpusrx+s_byte ; SR
00EDDA  2  03                   .BYTE   s_word+s_byte   ; .C
00EDDB  2  03                   .BYTE   s_word+s_byte   ; .X
00EDDC  2  03                   .BYTE   s_word+s_byte   ; .Y
00EDDD  2  03                   .BYTE   s_mpuspx+s_byte ; SP
00EDDE  2  03                   .BYTE   s_mpudpx+s_byte ; DP
00EDDF  2  02                   .BYTE   s_mpudbx+s_byte ; DB
00EDE0  2               n_regchv        = *-rcvltab     ;total shadow registers
00EDE0  2               ;
00EDE0  2               ;================================================================================
00EDE0  2               ;
00EDE0  2               ;ASSEMBLER/DISASSEMBLER DATA TABLES
00EDE0  2               ;
00EDE0  2               ;
00EDE0  2               ;	numerically sorted & encoded W65C816S mnemonics...
00EDE0  2               ;
00EDE0  2               mnetab:
00EDE0  2  F2 10                .WORD   mne_xba         ;  0 - XBA
00EDE2  2  5A 11                .WORD   mne_lda         ;  1 - LDA
00EDE4  2  A2 11                .WORD   mne_pea         ;  2 - PEA
00EDE6  2  62 12                .WORD   mne_pha         ;  3 - PHA
00EDE8  2  62 13                .WORD   mne_pla         ;  4 - PLA
00EDEA  2  C6 14                .WORD   mne_bra         ;  5 - BRA
00EDEC  2  E0 14                .WORD   mne_ora         ;  6 - ORA
00EDEE  2  68 15                .WORD   mne_sta         ;  7 - STA
00EDF0  2  6A 16                .WORD   mne_txa         ;  8 - TXA
00EDF2  2  AA 16                .WORD   mne_tya         ;  9 - TYA
00EDF4  2  62 1A                .WORD   mne_phb         ; 10 - PHB
00EDF6  2  62 1B                .WORD   mne_plb         ; 11 - PLB
00EDF8  2  EA 1C                .WORD   mne_trb         ; 12 - TRB
00EDFA  2  2A 1D                .WORD   mne_tsb         ; 13 - TSB
00EDFC  2  E8 20                .WORD   mne_sbc         ; 14 - SBC
00EDFE  2  06 21                .WORD   mne_bcc         ; 15 - BCC
00EE00  2  44 21                .WORD   mne_adc         ; 16 - ADC
00EE02  2  6A 21                .WORD   mne_tdc         ; 17 - TDC
00EE04  2  8A 21                .WORD   mne_dec         ; 18 - DEC
00EE06  2  A8 21                .WORD   mne_sec         ; 19 - SEC
00EE08  2  48 23                .WORD   mne_clc         ; 20 - CLC
00EE0A  2  D4 23                .WORD   mne_inc         ; 21 - INC
00EE0C  2  2A 25                .WORD   mne_tsc         ; 22 - TSC
00EE0E  2  C6 25                .WORD   mne_bvc         ; 23 - BVC
00EE10  2  2A 29                .WORD   mne_tcd         ; 24 - TCD
00EE12  2  A8 29                .WORD   mne_sed         ; 25 - SED
00EE14  2  62 2A                .WORD   mne_phd         ; 26 - PHD
00EE16  2  48 2B                .WORD   mne_cld         ; 27 - CLD
00EE18  2  62 2B                .WORD   mne_pld         ; 28 - PLD
00EE1A  2  C4 2B                .WORD   mne_and         ; 29 - AND
00EE1C  2  32 31                .WORD   mne_xce         ; 30 - XCE
00EE1E  2  C6 33                .WORD   mne_bne         ; 31 - BNE
00EE20  2  B0 50                .WORD   mne_wai         ; 32 - WAI
00EE22  2  A2 51                .WORD   mne_pei         ; 33 - PEI
00EE24  2  A8 51                .WORD   mne_sei         ; 34 - SEI
00EE26  2  48 53                .WORD   mne_cli         ; 35 - CLI
00EE28  2  86 53                .WORD   mne_bmi         ; 36 - BMI
00EE2A  2  66 55                .WORD   mne_rti         ; 37 - RTI
00EE2C  2  62 62                .WORD   mne_phk         ; 38 - PHK
00EE2E  2  C6 64                .WORD   mne_brk         ; 39 - BRK
00EE30  2  96 6B                .WORD   mne_jml         ; 40 - JML
00EE32  2  26 6C                .WORD   mne_rol         ; 41 - ROL
00EE34  2  46 6C                .WORD   mne_bpl         ; 42 - BPL
00EE36  2  C6 6C                .WORD   mne_brl         ; 43 - BRL
00EE38  2  04 6D                .WORD   mne_asl         ; 44 - ASL
00EE3A  2  16 6D                .WORD   mne_jsl         ; 45 - JSL
00EE3C  2  66 6D                .WORD   mne_rtl         ; 46 - RTL
00EE3E  2  70 71                .WORD   mne_wdm         ; 47 - WDM
00EE40  2  DC 7D                .WORD   mne_mvn         ; 48 - MVN
00EE42  2  A6 89                .WORD   mne_rep         ; 49 - REP
00EE44  2  A8 89                .WORD   mne_sep         ; 50 - SEP
00EE46  2  62 8A                .WORD   mne_php         ; 51 - PHP
00EE48  2  62 8B                .WORD   mne_plp         ; 52 - PLP
00EE4A  2  88 8B                .WORD   mne_cmp         ; 53 - CMP
00EE4C  2  96 8B                .WORD   mne_jmp         ; 54 - JMP
00EE4E  2  08 8C                .WORD   mne_cop         ; 55 - COP
00EE50  2  1E 8C                .WORD   mne_nop         ; 56 - NOP
00EE52  2  68 8D                .WORD   mne_stp         ; 57 - STP
00EE54  2  DC 8D                .WORD   mne_mvp         ; 58 - MVP
00EE56  2  86 91                .WORD   mne_beq         ; 59 - BEQ
00EE58  2  A2 99                .WORD   mne_per         ; 60 - PER
00EE5A  2  0C 9C                .WORD   mne_eor         ; 61 - EOR
00EE5C  2  26 9C                .WORD   mne_ror         ; 62 - ROR
00EE5E  2  16 9D                .WORD   mne_jsr         ; 63 - JSR
00EE60  2  1A 9D                .WORD   mne_lsr         ; 64 - LSR
00EE62  2  06 A1                .WORD   mne_bcs         ; 65 - BCS
00EE64  2  2A A1                .WORD   mne_tcs         ; 66 - TCS
00EE66  2  66 A5                .WORD   mne_rts         ; 67 - RTS
00EE68  2  C6 A5                .WORD   mne_bvs         ; 68 - BVS
00EE6A  2  6A A6                .WORD   mne_txs         ; 69 - TXS
00EE6C  2  86 AA                .WORD   mne_bit         ; 70 - BIT
00EE6E  2  48 BB                .WORD   mne_clv         ; 71 - CLV
00EE70  2  AA C8                .WORD   mne_tax         ; 72 - TAX
00EE72  2  5A C9                .WORD   mne_ldx         ; 73 - LDX
00EE74  2  8A C9                .WORD   mne_dex         ; 74 - DEX
00EE76  2  62 CA                .WORD   mne_phx         ; 75 - PHX
00EE78  2  62 CB                .WORD   mne_plx         ; 76 - PLX
00EE7A  2  D4 CB                .WORD   mne_inx         ; 77 - INX
00EE7C  2  48 CC                .WORD   mne_cpx         ; 78 - CPX
00EE7E  2  2A CD                .WORD   mne_tsx         ; 79 - TSX
00EE80  2  68 CD                .WORD   mne_stx         ; 80 - STX
00EE82  2  AA CE                .WORD   mne_tyx         ; 81 - TYX
00EE84  2  AA D0                .WORD   mne_tay         ; 82 - TAY
00EE86  2  5A D1                .WORD   mne_ldy         ; 83 - LDY
00EE88  2  8A D1                .WORD   mne_dey         ; 84 - DEY
00EE8A  2  62 D2                .WORD   mne_phy         ; 85 - PHY
00EE8C  2  62 D3                .WORD   mne_ply         ; 86 - PLY
00EE8E  2  D4 D3                .WORD   mne_iny         ; 87 - INY
00EE90  2  48 D4                .WORD   mne_cpy         ; 88 - CPY
00EE92  2  68 D5                .WORD   mne_sty         ; 89 - STY
00EE94  2  6A D6                .WORD   mne_txy         ; 90 - TXY
00EE96  2  68 DD                .WORD   mne_stz         ; 91 - STZ
00EE98  2               ;
00EE98  2               s_mnetab        = *-mnetab      ;mnemonic table size
00EE98  2               n_mnemon        = s_mnetab/s_word;total mnemonics
00EE98  2               ;
00EE98  2               ;
00EE98  2               ;	mnemonic lookup indices in opcode order...
00EE98  2               ;
00EE98  2               mnetabix:
00EE98  2  27                   .BYTE   mne_brkx        ; $00  BRK
00EE99  2  06                   .BYTE   mne_orax        ; $01  ORA (dp,X)
00EE9A  2  37                   .BYTE   mne_copx        ; $02  COP
00EE9B  2  06                   .BYTE   mne_orax        ; $03  ORA <offset>,S
00EE9C  2  0D                   .BYTE   mne_tsbx        ; $04  TSB dp
00EE9D  2  06                   .BYTE   mne_orax        ; $05  ORA dp
00EE9E  2  2C                   .BYTE   mne_aslx        ; $06  ASL dp
00EE9F  2  06                   .BYTE   mne_orax        ; $07  ORA [dp]
00EEA0  2  33                   .BYTE   mne_phpx        ; $08  PHP
00EEA1  2  06                   .BYTE   mne_orax        ; $09  ORA #
00EEA2  2  2C                   .BYTE   mne_aslx        ; $0A  ASL A
00EEA3  2  1A                   .BYTE   mne_phdx        ; $0B  PHD
00EEA4  2  0D                   .BYTE   mne_tsbx        ; $0C  TSB abs
00EEA5  2  06                   .BYTE   mne_orax        ; $0D  ORA abs
00EEA6  2  2C                   .BYTE   mne_aslx        ; $0E  ASL abs
00EEA7  2  06                   .BYTE   mne_orax        ; $0F  ORA absl
00EEA8  2               ;
00EEA8  2  2A                   .BYTE   mne_bplx        ; $10  BPL abs
00EEA9  2  06                   .BYTE   mne_orax        ; $11  ORA (<dp>),Y
00EEAA  2  06                   .BYTE   mne_orax        ; $12  ORA (dp)
00EEAB  2  06                   .BYTE   mne_orax        ; $13  ORA (<offset>,S),Y
00EEAC  2  0C                   .BYTE   mne_trbx        ; $14  TRB dp
00EEAD  2  06                   .BYTE   mne_orax        ; $15  ORA dp,X
00EEAE  2  2C                   .BYTE   mne_aslx        ; $16  ASL dp,X
00EEAF  2  06                   .BYTE   mne_orax        ; $17  ORA [dp],Y
00EEB0  2  14                   .BYTE   mne_clcx        ; $18  CLC
00EEB1  2  06                   .BYTE   mne_orax        ; $19  ORA abs
00EEB2  2  15                   .BYTE   mne_incx        ; $1A  INC A
00EEB3  2  42                   .BYTE   mne_tcsx        ; $1B  TCS
00EEB4  2  0C                   .BYTE   mne_trbx        ; $1C  TRB abs
00EEB5  2  06                   .BYTE   mne_orax        ; $1D  ORA abs,X
00EEB6  2  2C                   .BYTE   mne_aslx        ; $1E  ASL abs,X
00EEB7  2  06                   .BYTE   mne_orax        ; $1F  ORA absl,X
00EEB8  2               ;
00EEB8  2  3F                   .BYTE   mne_jsrx        ; $20  JSR abs
00EEB9  2  1D                   .BYTE   mne_andx        ; $21  AND (dp,X)
00EEBA  2  2D                   .BYTE   mne_jslx        ; $22  JSL absl
00EEBB  2  1D                   .BYTE   mne_andx        ; $23  AND <offset>,S
00EEBC  2  46                   .BYTE   mne_bitx        ; $24  BIT dp
00EEBD  2  1D                   .BYTE   mne_andx        ; $25  AND dp
00EEBE  2  29                   .BYTE   mne_rolx        ; $26  ROL dp
00EEBF  2  1D                   .BYTE   mne_andx        ; $27  AND [dp]
00EEC0  2  34                   .BYTE   mne_plpx        ; $28  PLP
00EEC1  2  1D                   .BYTE   mne_andx        ; $29  AND #
00EEC2  2  29                   .BYTE   mne_rolx        ; $2A  ROL A
00EEC3  2  1C                   .BYTE   mne_pldx        ; $2B  PLD
00EEC4  2  46                   .BYTE   mne_bitx        ; $2C  BIT abs
00EEC5  2  1D                   .BYTE   mne_andx        ; $2D  AND abs
00EEC6  2  29                   .BYTE   mne_rolx        ; $2E  ROL abs
00EEC7  2  1D                   .BYTE   mne_andx        ; $2F  AND absl
00EEC8  2               ;
00EEC8  2  24                   .BYTE   mne_bmix        ; $30  BMI abs
00EEC9  2  1D                   .BYTE   mne_andx        ; $31  AND (<dp>),Y
00EECA  2  1D                   .BYTE   mne_andx        ; $32  AND (dp)
00EECB  2  1D                   .BYTE   mne_andx        ; $33  AND (<offset>,S),Y
00EECC  2  46                   .BYTE   mne_bitx        ; $34  BIT dp,X
00EECD  2  1D                   .BYTE   mne_andx        ; $35  AND dp,X
00EECE  2  29                   .BYTE   mne_rolx        ; $36  ROL dp,X
00EECF  2  1D                   .BYTE   mne_andx        ; $37  AND [dp],Y
00EED0  2  13                   .BYTE   mne_secx        ; $38  SEC
00EED1  2  1D                   .BYTE   mne_andx        ; $39  AND abs,Y
00EED2  2  12                   .BYTE   mne_decx        ; $3A  DEC A
00EED3  2  16                   .BYTE   mne_tscx        ; $3B  TSC
00EED4  2  46                   .BYTE   mne_bitx        ; $3C  BIT abs,X
00EED5  2  1D                   .BYTE   mne_andx        ; $3D  AND abs,X
00EED6  2  29                   .BYTE   mne_rolx        ; $3E  ROL abs,X
00EED7  2  1D                   .BYTE   mne_andx        ; $3F  AND absl,X
00EED8  2               ;
00EED8  2  25                   .BYTE   mne_rtix        ; $40  RTI
00EED9  2  3D                   .BYTE   mne_eorx        ; $41  EOR (dp,X)
00EEDA  2  2F                   .BYTE   mne_wdmx        ; $42  WDM
00EEDB  2  3D                   .BYTE   mne_eorx        ; $43  EOR <offset>,S
00EEDC  2  3A                   .BYTE   mne_mvpx        ; $44  MVP sb,db
00EEDD  2  3D                   .BYTE   mne_eorx        ; $45  EOR dp
00EEDE  2  40                   .BYTE   mne_lsrx        ; $46  LSR dp
00EEDF  2  3D                   .BYTE   mne_eorx        ; $47  EOR [dp]
00EEE0  2  03                   .BYTE   mne_phax        ; $48  PHA
00EEE1  2  3D                   .BYTE   mne_eorx        ; $49  EOR #
00EEE2  2  40                   .BYTE   mne_lsrx        ; $4A  LSR A
00EEE3  2  26                   .BYTE   mne_phkx        ; $4B  PHK
00EEE4  2  36                   .BYTE   mne_jmpx        ; $4C  JMP abs
00EEE5  2  3D                   .BYTE   mne_eorx        ; $4D  EOR abs
00EEE6  2  40                   .BYTE   mne_lsrx        ; $4E  LSR abs
00EEE7  2  3D                   .BYTE   mne_eorx        ; $4F  EOR absl
00EEE8  2               ;
00EEE8  2  17                   .BYTE   mne_bvcx        ; $50  BVC abs
00EEE9  2  3D                   .BYTE   mne_eorx        ; $51  EOR (<dp>),Y
00EEEA  2  3D                   .BYTE   mne_eorx        ; $52  EOR (dp)
00EEEB  2  3D                   .BYTE   mne_eorx        ; $53  EOR (<offset>,S),Y
00EEEC  2  30                   .BYTE   mne_mvnx        ; $54  MVN sb,db
00EEED  2  3D                   .BYTE   mne_eorx        ; $55  EOR dp,X
00EEEE  2  40                   .BYTE   mne_lsrx        ; $56  LSR dp,X
00EEEF  2  3D                   .BYTE   mne_eorx        ; $57  EOR [dp],Y
00EEF0  2  23                   .BYTE   mne_clix        ; $58  CLI
00EEF1  2  3D                   .BYTE   mne_eorx        ; $59  EOR abs,Y
00EEF2  2  55                   .BYTE   mne_phyx        ; $5A  PHY
00EEF3  2  18                   .BYTE   mne_tcdx        ; $5B  TCD
00EEF4  2  28                   .BYTE   mne_jmlx        ; $5C  JML absl
00EEF5  2  3D                   .BYTE   mne_eorx        ; $5D  EOR abs,X
00EEF6  2  40                   .BYTE   mne_lsrx        ; $5E  LSR abs,X
00EEF7  2  3D                   .BYTE   mne_eorx        ; $5F  EOR absl,X
00EEF8  2               ;
00EEF8  2  43                   .BYTE   mne_rtsx        ; $60  RTS
00EEF9  2  10                   .BYTE   mne_adcx        ; $61  ADC (dp,X)
00EEFA  2  3C                   .BYTE   mne_perx        ; $62  PER
00EEFB  2  10                   .BYTE   mne_adcx        ; $63  ADC <offset>,S
00EEFC  2  5B                   .BYTE   mne_stzx        ; $64  STZ dp
00EEFD  2  10                   .BYTE   mne_adcx        ; $65  ADC dp
00EEFE  2  3E                   .BYTE   mne_rorx        ; $66  ROR dp
00EEFF  2  10                   .BYTE   mne_adcx        ; $67  ADC [dp]
00EF00  2  04                   .BYTE   mne_plax        ; $68  PLA
00EF01  2  10                   .BYTE   mne_adcx        ; $69  ADC #
00EF02  2  3E                   .BYTE   mne_rorx        ; $6A  ROR A
00EF03  2  2E                   .BYTE   mne_rtlx        ; $6B  RTL
00EF04  2  36                   .BYTE   mne_jmpx        ; $6C  JMP (abs)
00EF05  2  10                   .BYTE   mne_adcx        ; $6D  ADC abs
00EF06  2  3E                   .BYTE   mne_rorx        ; $6E  ROR abs
00EF07  2  10                   .BYTE   mne_adcx        ; $6F  ADC absl
00EF08  2               ;
00EF08  2  44                   .BYTE   mne_bvsx        ; $70  BVS abs
00EF09  2  10                   .BYTE   mne_adcx        ; $71  ADC (<dp>),Y
00EF0A  2  10                   .BYTE   mne_adcx        ; $72  ADC (dp)
00EF0B  2  10                   .BYTE   mne_adcx        ; $73  ADC (<offset>,S),Y
00EF0C  2  5B                   .BYTE   mne_stzx        ; $74  STZ dp,X
00EF0D  2  10                   .BYTE   mne_adcx        ; $75  ADC dp,X
00EF0E  2  3E                   .BYTE   mne_rorx        ; $76  ROR dp,X
00EF0F  2  10                   .BYTE   mne_adcx        ; $77  ADC [dp],Y
00EF10  2  22                   .BYTE   mne_seix        ; $78  SEI
00EF11  2  10                   .BYTE   mne_adcx        ; $79  ADC abs,Y
00EF12  2  56                   .BYTE   mne_plyx        ; $7A  PLY
00EF13  2  11                   .BYTE   mne_tdcx        ; $7B  TDC
00EF14  2  36                   .BYTE   mne_jmpx        ; $7C  JMP (abs,X)
00EF15  2  10                   .BYTE   mne_adcx        ; $7D  ADC abs,X
00EF16  2  3E                   .BYTE   mne_rorx        ; $7E  ROR abs,X
00EF17  2  10                   .BYTE   mne_adcx        ; $7F  ADC absl,X
00EF18  2               ;
00EF18  2  05                   .BYTE   mne_brax        ; $80  BRA abs
00EF19  2  07                   .BYTE   mne_stax        ; $81  STA (dp,X)
00EF1A  2  2B                   .BYTE   mne_brlx        ; $82  BRL abs
00EF1B  2  07                   .BYTE   mne_stax        ; $83  STA <offset>,S
00EF1C  2  59                   .BYTE   mne_styx        ; $84  STY dp
00EF1D  2  07                   .BYTE   mne_stax        ; $85  STA dp
00EF1E  2  50                   .BYTE   mne_stxx        ; $86  STX dp
00EF1F  2  07                   .BYTE   mne_stax        ; $87  STA [dp]
00EF20  2  54                   .BYTE   mne_deyx        ; $88  DEY
00EF21  2  46                   .BYTE   mne_bitx        ; $89  BIT #
00EF22  2  08                   .BYTE   mne_txax        ; $8A  TXA
00EF23  2  0A                   .BYTE   mne_phbx        ; $8B  PHB
00EF24  2  59                   .BYTE   mne_styx        ; $8C  STY abs
00EF25  2  07                   .BYTE   mne_stax        ; $8D  STA abs
00EF26  2  50                   .BYTE   mne_stxx        ; $8E  STX abs
00EF27  2  07                   .BYTE   mne_stax        ; $8F  STA absl
00EF28  2               ;
00EF28  2  0F                   .BYTE   mne_bccx        ; $90  BCC abs
00EF29  2  07                   .BYTE   mne_stax        ; $91  STA (<dp>),Y
00EF2A  2  07                   .BYTE   mne_stax        ; $92  STA (dp)
00EF2B  2  07                   .BYTE   mne_stax        ; $93  STA (<offset>,S),Y
00EF2C  2  59                   .BYTE   mne_styx        ; $94  STY dp,X
00EF2D  2  07                   .BYTE   mne_stax        ; $95  STA dp,X
00EF2E  2  50                   .BYTE   mne_stxx        ; $96  STX dp,Y
00EF2F  2  07                   .BYTE   mne_stax        ; $97  STA [dp],Y
00EF30  2  09                   .BYTE   mne_tyax        ; $98  TYA
00EF31  2  07                   .BYTE   mne_stax        ; $99  STA abs,Y
00EF32  2  45                   .BYTE   mne_txsx        ; $9A  TXS
00EF33  2  5A                   .BYTE   mne_txyx        ; $9B  TXY
00EF34  2  5B                   .BYTE   mne_stzx        ; $9C  STZ abs
00EF35  2  07                   .BYTE   mne_stax        ; $9D  STA abs,X
00EF36  2  5B                   .BYTE   mne_stzx        ; $9E  STZ abs,X
00EF37  2  07                   .BYTE   mne_stax        ; $9F  STA absl,X
00EF38  2               ;
00EF38  2  53                   .BYTE   mne_ldyx        ; $A0  LDY #
00EF39  2  01                   .BYTE   mne_ldax        ; $A1  LDA (dp,X)
00EF3A  2  49                   .BYTE   mne_ldxx        ; $A2  LDX #
00EF3B  2  01                   .BYTE   mne_ldax        ; $A3  LDA <offset>,S
00EF3C  2  53                   .BYTE   mne_ldyx        ; $A4  LDY dp
00EF3D  2  01                   .BYTE   mne_ldax        ; $A5  LDA dp
00EF3E  2  49                   .BYTE   mne_ldxx        ; $A6  LDX dp
00EF3F  2  01                   .BYTE   mne_ldax        ; $A7  LDA [dp]
00EF40  2  52                   .BYTE   mne_tayx        ; $A8  TAY
00EF41  2  01                   .BYTE   mne_ldax        ; $A9  LDA #
00EF42  2  48                   .BYTE   mne_taxx        ; $AA  TAX
00EF43  2  0B                   .BYTE   mne_plbx        ; $AB  PLB
00EF44  2  53                   .BYTE   mne_ldyx        ; $AC  LDY abs
00EF45  2  01                   .BYTE   mne_ldax        ; $AD  LDA abs
00EF46  2  49                   .BYTE   mne_ldxx        ; $AE  LDX abs
00EF47  2  01                   .BYTE   mne_ldax        ; $AF  LDA absl
00EF48  2               ;
00EF48  2  41                   .BYTE   mne_bcsx        ; $B0  BCS abs
00EF49  2  01                   .BYTE   mne_ldax        ; $B1  LDA (<dp>),Y
00EF4A  2  01                   .BYTE   mne_ldax        ; $B2  LDA (dp)
00EF4B  2  01                   .BYTE   mne_ldax        ; $B3  LDA (<offset>,S),Y
00EF4C  2  53                   .BYTE   mne_ldyx        ; $B4  LDY dp,X
00EF4D  2  01                   .BYTE   mne_ldax        ; $B5  LDA dp,X
00EF4E  2  49                   .BYTE   mne_ldxx        ; $B6  LDX dp,Y
00EF4F  2  01                   .BYTE   mne_ldax        ; $B7  LDA [dp],Y
00EF50  2  47                   .BYTE   mne_clvx        ; $B8  CLV
00EF51  2  01                   .BYTE   mne_ldax        ; $B9  LDA abs,Y
00EF52  2  4F                   .BYTE   mne_tsxx        ; $BA  TSX
00EF53  2  51                   .BYTE   mne_tyxx        ; $BB  TYX
00EF54  2  53                   .BYTE   mne_ldyx        ; $BC  LDY abs,X
00EF55  2  01                   .BYTE   mne_ldax        ; $BD  LDA abs,X
00EF56  2  49                   .BYTE   mne_ldxx        ; $BE  LDX abs,Y
00EF57  2  01                   .BYTE   mne_ldax        ; $BF  LDA absl,X
00EF58  2               ;
00EF58  2  58                   .BYTE   mne_cpyx        ; $C0  CPY #
00EF59  2  35                   .BYTE   mne_cmpx        ; $C1  CMP (dp,X)
00EF5A  2  31                   .BYTE   mne_repx        ; $C2  REP #
00EF5B  2  35                   .BYTE   mne_cmpx        ; $C3  CMP <offset>,S
00EF5C  2  58                   .BYTE   mne_cpyx        ; $C4  CPY dp
00EF5D  2  35                   .BYTE   mne_cmpx        ; $C5  CMP dp
00EF5E  2  12                   .BYTE   mne_decx        ; $C6  DEC dp
00EF5F  2  35                   .BYTE   mne_cmpx        ; $C7  CMP [dp]
00EF60  2  57                   .BYTE   mne_inyx        ; $C8  INY
00EF61  2  35                   .BYTE   mne_cmpx        ; $C9  CMP #
00EF62  2  4A                   .BYTE   mne_dexx        ; $CA  DEX
00EF63  2  20                   .BYTE   mne_waix        ; $CB  WAI
00EF64  2  58                   .BYTE   mne_cpyx        ; $CC  CPY abs
00EF65  2  35                   .BYTE   mne_cmpx        ; $CD  CMP abs
00EF66  2  12                   .BYTE   mne_decx        ; $CE  DEC abs
00EF67  2  35                   .BYTE   mne_cmpx        ; $CF  CMP absl
00EF68  2               ;
00EF68  2  1F                   .BYTE   mne_bnex        ; $D0  BNE abs
00EF69  2  35                   .BYTE   mne_cmpx        ; $D1  CMP (<dp>),Y
00EF6A  2  35                   .BYTE   mne_cmpx        ; $D2  CMP (dp)
00EF6B  2  35                   .BYTE   mne_cmpx        ; $D3  CMP (<offset>,S),Y
00EF6C  2  21                   .BYTE   mne_peix        ; $D4  PEI dp
00EF6D  2  35                   .BYTE   mne_cmpx        ; $D5  CMP dp,X
00EF6E  2  12                   .BYTE   mne_decx        ; $D6  DEC dp,X
00EF6F  2  35                   .BYTE   mne_cmpx        ; $D7  CMP [dp],Y
00EF70  2  1B                   .BYTE   mne_cldx        ; $D8  CLD
00EF71  2  35                   .BYTE   mne_cmpx        ; $D9  CMP abs,Y
00EF72  2  4B                   .BYTE   mne_phxx        ; $DA  PHX
00EF73  2  39                   .BYTE   mne_stpx        ; $DB  STP
00EF74  2  36                   .BYTE   mne_jmpx        ; $DC  JMP [abs]
00EF75  2  35                   .BYTE   mne_cmpx        ; $DD  CMP abs,X
00EF76  2  12                   .BYTE   mne_decx        ; $DE  DEC abs,X
00EF77  2  35                   .BYTE   mne_cmpx        ; $DF  CMP absl,X
00EF78  2               ;
00EF78  2  4E                   .BYTE   mne_cpxx        ; $E0  CPX #
00EF79  2  0E                   .BYTE   mne_sbcx        ; $E1  SBC (dp,X)
00EF7A  2  32                   .BYTE   mne_sepx        ; $E2  SEP #
00EF7B  2  0E                   .BYTE   mne_sbcx        ; $E3  SBC <offset>,S
00EF7C  2  4E                   .BYTE   mne_cpxx        ; $E4  CPX dp
00EF7D  2  0E                   .BYTE   mne_sbcx        ; $E5  SBC dp
00EF7E  2  15                   .BYTE   mne_incx        ; $E6  INC dp
00EF7F  2  0E                   .BYTE   mne_sbcx        ; $E7  SBC [dp]
00EF80  2  4D                   .BYTE   mne_inxx        ; $E8  INX
00EF81  2  0E                   .BYTE   mne_sbcx        ; $E9  SBC #
00EF82  2  38                   .BYTE   mne_nopx        ; $EA  NOP
00EF83  2  00                   .BYTE   mne_xbax        ; $EB  XBA
00EF84  2  4E                   .BYTE   mne_cpxx        ; $EC  CPX abs
00EF85  2  0E                   .BYTE   mne_sbcx        ; $ED  SBC abs
00EF86  2  15                   .BYTE   mne_incx        ; $EE  INC abs
00EF87  2  0E                   .BYTE   mne_sbcx        ; $EF  SBC absl
00EF88  2               ;
00EF88  2  3B                   .BYTE   mne_beqx        ; $F0  BEQ abs
00EF89  2  0E                   .BYTE   mne_sbcx        ; $F1  SBC (<dp>),Y
00EF8A  2  0E                   .BYTE   mne_sbcx        ; $F2  SBC (dp)
00EF8B  2  0E                   .BYTE   mne_sbcx        ; $F3  SBC (<offset>,S),Y
00EF8C  2  02                   .BYTE   mne_peax        ; $F4  PEA #
00EF8D  2  0E                   .BYTE   mne_sbcx        ; $F5  SBC dp,X
00EF8E  2  15                   .BYTE   mne_incx        ; $F6  INC dp,X
00EF8F  2  0E                   .BYTE   mne_sbcx        ; $F7  SBC [dp],Y
00EF90  2  19                   .BYTE   mne_sedx        ; $F8  SED
00EF91  2  0E                   .BYTE   mne_sbcx        ; $F9  SBC abs,Y
00EF92  2  4C                   .BYTE   mne_plxx        ; $FA  PLX
00EF93  2  1E                   .BYTE   mne_xcex        ; $FB  XCE
00EF94  2  3F                   .BYTE   mne_jsrx        ; $FC  JSR (abs,X)
00EF95  2  0E                   .BYTE   mne_sbcx        ; $FD  SBC abs,X
00EF96  2  15                   .BYTE   mne_incx        ; $FE  INC abs,X
00EF97  2  0E                   .BYTE   mne_sbcx        ; $FF  SBC absl,X
00EF98  2               ;
00EF98  2               ;
00EF98  2               ;	instruction addressing modes & sizes in opcode order...
00EF98  2               ;
00EF98  2               ;	    xxxxxxxx
00EF98  2               ;	    ||||||||
00EF98  2               ;	    ||||++++---> Addressing Mode
00EF98  2               ;	    ||||         ----------------------------------
00EF98  2               ;	    ||||          0000  dp, abs, absl, implied or A
00EF98  2               ;	    ||||          0001  #
00EF98  2               ;	    ||||          0010  dp,X, abs,X or absl,X
00EF98  2               ;	    ||||          0011  dp,Y or abs,Y
00EF98  2               ;	    ||||          0100  (dp) or (abs)
00EF98  2               ;	    ||||          0101  [dp] or [abs]
00EF98  2               ;	    ||||          0110  [dp],Y
00EF98  2               ;	    ||||          0111  (dp,X) or (abs,X)
00EF98  2               ;	    ||||          1000  (<dp>),Y
00EF98  2               ;	    ||||          1001  <offset>,S
00EF98  2               ;	    ||||          1010  (<offset>,S),Y
00EF98  2               ;	    ||||          1011  sbnk,dbnk (MVN or MVP)
00EF98  2               ;	    ||||          ---------------------------------
00EF98  2               ;	    ||||           #    = immediate
00EF98  2               ;	    ||||           A    = accumulator
00EF98  2               ;	    ||||           abs  = absolute
00EF98  2               ;	    ||||           absl = absolute long
00EF98  2               ;	    ||||           dbnk = destination bank
00EF98  2               ;	    ||||           dp   = direct (zero) page
00EF98  2               ;	    ||||           S    = stack relative
00EF98  2               ;	    ||||           sbnk = source bank
00EF98  2               ;	    ||||         ----------------------------------
00EF98  2               ;	    ||||
00EF98  2               ;	    ||++-------> binary-encoded operand size
00EF98  2               ;	    |+---------> 1: relative branch instruction
00EF98  2               ;	    +----------> 1: variable operand size...
00EF98  2               ;
00EF98  2               ;	    -------------------------------------------------------------
00EF98  2               ;	    Variable operand size refers to an immediate mode instruction
00EF98  2               ;	    that can accept either an 8 or 16 bit operand.  During instr-
00EF98  2               ;	    uction assembly, an 8 bit operand can be forced to 16 bits by
00EF98  2               ;	    preceding the operand field with !,  e.g.,  LDA !#$01,  which
00EF98  2               ;	    will assemble as $A9 $01 $00.
00EF98  2               ;	    -------------------------------------------------------------
00EF98  2               ;
00EF98  2               mnetabam:
00EF98  2  00                   .BYTE   ops0|am_nam     ; $00  BRK
00EF99  2  17                   .BYTE   ops1|am_indx    ; $01  ORA (dp,X)
00EF9A  2  10                   .BYTE   ops1|am_nam     ; $02  COP
00EF9B  2  19                   .BYTE   ops1|am_stk     ; $03  ORA <offset>,S
00EF9C  2  10                   .BYTE   ops1|am_nam     ; $04  TSB dp
00EF9D  2  10                   .BYTE   ops1|am_nam     ; $05  ORA dp
00EF9E  2  10                   .BYTE   ops1|am_nam     ; $06  ASL dp
00EF9F  2  15                   .BYTE   ops1|am_indl    ; $07  ORA [dp]
00EFA0  2  00                   .BYTE   ops0|am_nam     ; $08  PHP
00EFA1  2  91                   .BYTE   vops|am_imm     ; $09  ORA #
00EFA2  2  00                   .BYTE   ops0|am_nam     ; $0A  ASL A
00EFA3  2  00                   .BYTE   ops0|am_nam     ; $0B  PHD
00EFA4  2  20                   .BYTE   ops2|am_nam     ; $0C  TSB abs
00EFA5  2  20                   .BYTE   ops2|am_nam     ; $0D  ORA abs
00EFA6  2  20                   .BYTE   ops2|am_nam     ; $0E  ASL abs
00EFA7  2  30                   .BYTE   ops3|am_nam     ; $0F  ORA absl
00EFA8  2               ;
00EFA8  2  50                   .BYTE   bop1|am_nam     ; $10  BPL abs
00EFA9  2  18                   .BYTE   ops1|am_indy    ; $11  ORA (<dp>),Y
00EFAA  2  14                   .BYTE   ops1|am_ind     ; $12  ORA (dp)
00EFAB  2  1A                   .BYTE   ops1|am_stky    ; $13  ORA (<offset>,S),Y
00EFAC  2  10                   .BYTE   ops1|am_nam     ; $14  TRB dp
00EFAD  2  12                   .BYTE   ops1|am_adrx    ; $15  ORA dp,X
00EFAE  2  12                   .BYTE   ops1|am_adrx    ; $16  ASL dp,X
00EFAF  2  16                   .BYTE   ops1|am_indly   ; $17  ORA [dp],Y
00EFB0  2  00                   .BYTE   ops0|am_nam     ; $18  CLC
00EFB1  2  20                   .BYTE   ops2|am_nam     ; $19  ORA abs
00EFB2  2  00                   .BYTE   ops0|am_nam     ; $1A  INC A
00EFB3  2  00                   .BYTE   ops0|am_nam     ; $1B  TCS
00EFB4  2  20                   .BYTE   ops2|am_nam     ; $1C  TRB abs
00EFB5  2  22                   .BYTE   ops2|am_adrx    ; $1D  ORA abs,X
00EFB6  2  22                   .BYTE   ops2|am_adrx    ; $1E  ASL abs,X
00EFB7  2  32                   .BYTE   ops3|am_adrx    ; $1F  ORA absl,X
00EFB8  2               ;
00EFB8  2  20                   .BYTE   ops2|am_nam     ; $20  JSR abs
00EFB9  2  17                   .BYTE   ops1|am_indx    ; $21  AND (dp,X)
00EFBA  2  30                   .BYTE   ops3|am_nam     ; $22  JSL absl
00EFBB  2  19                   .BYTE   ops1|am_stk     ; $23  AND <offset>,S
00EFBC  2  10                   .BYTE   ops1|am_nam     ; $24  BIT dp
00EFBD  2  10                   .BYTE   ops1|am_nam     ; $25  AND dp
00EFBE  2  10                   .BYTE   ops1|am_nam     ; $26  ROL dp
00EFBF  2  15                   .BYTE   ops1|am_indl    ; $27  AND [dp]
00EFC0  2  00                   .BYTE   ops0|am_nam     ; $28  PLP
00EFC1  2  91                   .BYTE   vops|am_imm     ; $29  AND #
00EFC2  2  00                   .BYTE   ops0|am_nam     ; $2A  ROL A
00EFC3  2  00                   .BYTE   ops0|am_nam     ; $2B  PLD
00EFC4  2  20                   .BYTE   ops2|am_nam     ; $2C  BIT abs
00EFC5  2  20                   .BYTE   ops2|am_nam     ; $2D  AND abs
00EFC6  2  20                   .BYTE   ops2|am_nam     ; $2E  ROL abs
00EFC7  2  30                   .BYTE   ops3|am_nam     ; $2F  AND absl
00EFC8  2               ;
00EFC8  2  50                   .BYTE   bop1|am_nam     ; $30  BMI abs
00EFC9  2  18                   .BYTE   ops1|am_indy    ; $31  AND (<dp>),Y
00EFCA  2  14                   .BYTE   ops1|am_ind     ; $32  AND (dp)
00EFCB  2  1A                   .BYTE   ops1|am_stky    ; $33  AND (<offset>,S),Y
00EFCC  2  12                   .BYTE   ops1|am_adrx    ; $34  BIT dp,X
00EFCD  2  12                   .BYTE   ops1|am_adrx    ; $35  AND dp,X
00EFCE  2  12                   .BYTE   ops1|am_adrx    ; $36  ROL dp,X
00EFCF  2  16                   .BYTE   ops1|am_indly   ; $37  AND [dp],Y
00EFD0  2  00                   .BYTE   ops0|am_nam     ; $38  SEC
00EFD1  2  23                   .BYTE   ops2|am_adry    ; $39  AND abs,Y
00EFD2  2  00                   .BYTE   ops0|am_nam     ; $3A  DEC A
00EFD3  2  00                   .BYTE   ops0|am_nam     ; $3B  TSC
00EFD4  2  22                   .BYTE   ops2|am_adrx    ; $3C  BIT abs,X
00EFD5  2  22                   .BYTE   ops2|am_adrx    ; $3D  AND abs,X
00EFD6  2  22                   .BYTE   ops2|am_adrx    ; $3E  ROL abs,X
00EFD7  2  32                   .BYTE   ops3|am_adrx    ; $3F  AND absl,X
00EFD8  2               ;
00EFD8  2  00                   .BYTE   ops0|am_nam     ; $40  RTI
00EFD9  2  17                   .BYTE   ops1|am_indx    ; $41  EOR (dp,X)
00EFDA  2  00                   .BYTE   ops0|am_nam     ; $42  WDM
00EFDB  2  19                   .BYTE   ops1|am_stk     ; $43  EOR <offset>,S
00EFDC  2  2B                   .BYTE   ops2|am_move    ; $44  MVP sb,db
00EFDD  2  10                   .BYTE   ops1|am_nam     ; $45  EOR dp
00EFDE  2  10                   .BYTE   ops1|am_nam     ; $46  LSR dp
00EFDF  2  15                   .BYTE   ops1|am_indl    ; $47  EOR [dp]
00EFE0  2  00                   .BYTE   ops0|am_nam     ; $48  PHA
00EFE1  2  91                   .BYTE   vops|am_imm     ; $49  EOR #
00EFE2  2  00                   .BYTE   ops0|am_nam     ; $4A  LSR A
00EFE3  2  00                   .BYTE   ops0|am_nam     ; $4B  PHK
00EFE4  2  20                   .BYTE   ops2|am_nam     ; $4C  JMP abs
00EFE5  2  20                   .BYTE   ops2|am_nam     ; $4D  EOR abs
00EFE6  2  20                   .BYTE   ops2|am_nam     ; $4E  LSR abs
00EFE7  2  30                   .BYTE   ops3|am_nam     ; $4F  EOR absl
00EFE8  2               ;
00EFE8  2  50                   .BYTE   bop1|am_nam     ; $50  BVC abs
00EFE9  2  18                   .BYTE   ops1|am_indy    ; $51  EOR (<dp>),Y
00EFEA  2  14                   .BYTE   ops1|am_ind     ; $52  EOR (dp)
00EFEB  2  1A                   .BYTE   ops1|am_stky    ; $53  EOR (<offset>,S),Y
00EFEC  2  2B                   .BYTE   ops2|am_move    ; $54  MVN sb,db
00EFED  2  12                   .BYTE   ops1|am_adrx    ; $55  EOR dp,X
00EFEE  2  12                   .BYTE   ops1|am_adrx    ; $56  LSR dp,X
00EFEF  2  16                   .BYTE   ops1|am_indly   ; $57  EOR [dp],Y
00EFF0  2  00                   .BYTE   ops0|am_nam     ; $58  CLI
00EFF1  2  23                   .BYTE   ops2|am_adry    ; $59  EOR abs,Y
00EFF2  2  00                   .BYTE   ops0|am_nam     ; $5A  PHY
00EFF3  2  00                   .BYTE   ops0|am_nam     ; $5B  TCD
00EFF4  2  30                   .BYTE   ops3|am_nam     ; $5C  JML absl
00EFF5  2  22                   .BYTE   ops2|am_adrx    ; $5D  EOR abs,X
00EFF6  2  22                   .BYTE   ops2|am_adrx    ; $5E  LSR abs,X
00EFF7  2  32                   .BYTE   ops3|am_adrx    ; $5F  EOR absl,X
00EFF8  2               ;
00EFF8  2  00                   .BYTE   ops0|am_nam     ; $60  RTS
00EFF9  2  17                   .BYTE   ops1|am_indx    ; $61  ADC (dp,X)
00EFFA  2  60                   .BYTE   bop2|am_nam     ; $62  PER
00EFFB  2  19                   .BYTE   ops1|am_stk     ; $63  ADC <offset>,S
00EFFC  2  10                   .BYTE   ops1|am_nam     ; $64  STZ dp
00EFFD  2  10                   .BYTE   ops1|am_nam     ; $65  ADC dp
00EFFE  2  10                   .BYTE   ops1|am_nam     ; $66  ROR dp
00EFFF  2  15                   .BYTE   ops1|am_indl    ; $67  ADC [dp]
00F000  2  00                   .BYTE   ops0|am_nam     ; $68  PLA
00F001  2  91                   .BYTE   vops|am_imm     ; $69  ADC #
00F002  2  00                   .BYTE   ops0|am_nam     ; $6A  ROR A
00F003  2  00                   .BYTE   ops0|am_nam     ; $6B  RTL
00F004  2  24                   .BYTE   ops2|am_ind     ; $6C  JMP (abs)
00F005  2  20                   .BYTE   ops2|am_nam     ; $6D  ADC abs
00F006  2  20                   .BYTE   ops2|am_nam     ; $6E  ROR abs
00F007  2  30                   .BYTE   ops3|am_nam     ; $6F  ADC absl
00F008  2               ;
00F008  2  50                   .BYTE   bop1|am_nam     ; $70  BVS abs
00F009  2  18                   .BYTE   ops1|am_indy    ; $71  ADC (<dp>),Y
00F00A  2  14                   .BYTE   ops1|am_ind     ; $72  ADC (dp)
00F00B  2  1A                   .BYTE   ops1|am_stky    ; $73  ADC (<offset>,S),Y
00F00C  2  12                   .BYTE   ops1|am_adrx    ; $74  STZ dp,X
00F00D  2  12                   .BYTE   ops1|am_adrx    ; $75  ADC dp,X
00F00E  2  12                   .BYTE   ops1|am_adrx    ; $76  ROR dp,X
00F00F  2  16                   .BYTE   ops1|am_indly   ; $77  ADC [dp],Y
00F010  2  00                   .BYTE   ops0|am_nam     ; $78  SEI
00F011  2  23                   .BYTE   ops2|am_adry    ; $79  ADC abs,Y
00F012  2  00                   .BYTE   ops0|am_nam     ; $7A  PLY
00F013  2  00                   .BYTE   ops0|am_nam     ; $7B  TDC
00F014  2  27                   .BYTE   ops2|am_indx    ; $7C  JMP (abs,X)
00F015  2  22                   .BYTE   ops2|am_adrx    ; $7D  ADC abs,X
00F016  2  22                   .BYTE   ops2|am_adrx    ; $7E  ROR abs,X
00F017  2  32                   .BYTE   ops3|am_adrx    ; $7F  ADC absl,X
00F018  2               ;
00F018  2  50                   .BYTE   bop1|am_nam     ; $80  BRA abs
00F019  2  17                   .BYTE   ops1|am_indx    ; $81  STA (dp,X)
00F01A  2  60                   .BYTE   bop2|am_nam     ; $82  BRL abs
00F01B  2  19                   .BYTE   ops1|am_stk     ; $83  STA <offset>,S
00F01C  2  10                   .BYTE   ops1|am_nam     ; $84  STY dp
00F01D  2  10                   .BYTE   ops1|am_nam     ; $85  STA dp
00F01E  2  10                   .BYTE   ops1|am_nam     ; $86  STX dp
00F01F  2  15                   .BYTE   ops1|am_indl    ; $87  STA [dp]
00F020  2  00                   .BYTE   ops0|am_nam     ; $88  DEY
00F021  2  91                   .BYTE   vops|am_imm     ; $89  BIT #
00F022  2  00                   .BYTE   ops0|am_nam     ; $8A  TXA
00F023  2  00                   .BYTE   ops0|am_nam     ; $8B  PHB
00F024  2  20                   .BYTE   ops2|am_nam     ; $8C  STY abs
00F025  2  20                   .BYTE   ops2|am_nam     ; $8D  STA abs
00F026  2  20                   .BYTE   ops2|am_nam     ; $8E  STX abs
00F027  2  30                   .BYTE   ops3|am_nam     ; $8F  STA absl
00F028  2               ;
00F028  2  50                   .BYTE   bop1|am_nam     ; $90  BCC abs
00F029  2  18                   .BYTE   ops1|am_indy    ; $91  STA (<dp>),Y
00F02A  2  14                   .BYTE   ops1|am_ind     ; $92  STA (dp)
00F02B  2  1A                   .BYTE   ops1|am_stky    ; $93  STA (<offset>,S),Y
00F02C  2  12                   .BYTE   ops1|am_adrx    ; $94  STY dp,X
00F02D  2  12                   .BYTE   ops1|am_adrx    ; $95  STA dp,X
00F02E  2  13                   .BYTE   ops1|am_adry    ; $96  STX dp,Y
00F02F  2  16                   .BYTE   ops1|am_indly   ; $97  STA [dp],Y
00F030  2  00                   .BYTE   ops0|am_nam     ; $98  TYA
00F031  2  23                   .BYTE   ops2|am_adry    ; $99  STA abs,Y
00F032  2  00                   .BYTE   ops0|am_nam     ; $9A  TXS
00F033  2  00                   .BYTE   ops0|am_nam     ; $9B  TXY
00F034  2  20                   .BYTE   ops2|am_nam     ; $9C  STZ abs
00F035  2  22                   .BYTE   ops2|am_adrx    ; $9D  STA abs,X
00F036  2  22                   .BYTE   ops2|am_adrx    ; $9E  STZ abs,X
00F037  2  32                   .BYTE   ops3|am_adrx    ; $9F  STA absl,X
00F038  2               ;
00F038  2  91                   .BYTE   vops|am_imm     ; $A0  LDY #
00F039  2  17                   .BYTE   ops1|am_indx    ; $A1  LDA (dp,X)
00F03A  2  91                   .BYTE   vops|am_imm     ; $A2  LDX #
00F03B  2  19                   .BYTE   ops1|am_stk     ; $A3  LDA <offset>,S
00F03C  2  10                   .BYTE   ops1|am_nam     ; $A4  LDY dp
00F03D  2  10                   .BYTE   ops1|am_nam     ; $A5  LDA dp
00F03E  2  10                   .BYTE   ops1|am_nam     ; $A6  LDX dp
00F03F  2  15                   .BYTE   ops1|am_indl    ; $A7  LDA [dp]
00F040  2  00                   .BYTE   ops0|am_nam     ; $A8  TAY
00F041  2  91                   .BYTE   vops|am_imm     ; $A9  LDA #
00F042  2  00                   .BYTE   ops0|am_nam     ; $AA  TAX
00F043  2  00                   .BYTE   ops0|am_nam     ; $AB  PLB
00F044  2  20                   .BYTE   ops2|am_nam     ; $AC  LDY abs
00F045  2  20                   .BYTE   ops2|am_nam     ; $AD  LDA abs
00F046  2  20                   .BYTE   ops2|am_nam     ; $AE  LDX abs
00F047  2  30                   .BYTE   ops3|am_nam     ; $AF  LDA absl
00F048  2               ;
00F048  2  50                   .BYTE   bop1|am_nam     ; $B0  BCS abs
00F049  2  18                   .BYTE   ops1|am_indy    ; $B1  LDA (<dp>),Y
00F04A  2  14                   .BYTE   ops1|am_ind     ; $B2  LDA (dp)
00F04B  2  1A                   .BYTE   ops1|am_stky    ; $B3  LDA (<offset>,S),Y
00F04C  2  12                   .BYTE   ops1|am_adrx    ; $B4  LDY dp,X
00F04D  2  12                   .BYTE   ops1|am_adrx    ; $B5  LDA dp,X
00F04E  2  13                   .BYTE   ops1|am_adry    ; $B6  LDX dp,Y
00F04F  2  16                   .BYTE   ops1|am_indly   ; $B7  LDA [dp],Y
00F050  2  00                   .BYTE   ops0|am_nam     ; $B8  CLV
00F051  2  23                   .BYTE   ops2|am_adry    ; $B9  LDA abs,Y
00F052  2  00                   .BYTE   ops0|am_nam     ; $BA  TSX
00F053  2  00                   .BYTE   ops0|am_nam     ; $BB  TYX
00F054  2  22                   .BYTE   ops2|am_adrx    ; $BC  LDY abs,X
00F055  2  22                   .BYTE   ops2|am_adrx    ; $BD  LDA abs,X
00F056  2  23                   .BYTE   ops2|am_adry    ; $BE  LDX abs,Y
00F057  2  32                   .BYTE   ops3|am_adrx    ; $BF  LDA absl,X
00F058  2               ;
00F058  2  91                   .BYTE   vops|am_imm     ; $C0  CPY #
00F059  2  17                   .BYTE   ops1|am_indx    ; $C1  CMP (dp,X)
00F05A  2  11                   .BYTE   ops1|am_imm     ; $C2  REP #
00F05B  2  19                   .BYTE   ops1|am_stk     ; $C3  CMP <offset>,S
00F05C  2  10                   .BYTE   ops1|am_nam     ; $C4  CPY dp
00F05D  2  10                   .BYTE   ops1|am_nam     ; $C5  CMP dp
00F05E  2  10                   .BYTE   ops1|am_nam     ; $C6  DEC dp
00F05F  2  15                   .BYTE   ops1|am_indl    ; $C7  CMP [dp]
00F060  2  00                   .BYTE   ops0|am_nam     ; $C8  INY
00F061  2  91                   .BYTE   vops|am_imm     ; $C9  CMP #
00F062  2  00                   .BYTE   ops0|am_nam     ; $CA  DEX
00F063  2  00                   .BYTE   ops0|am_nam     ; $CB  WAI
00F064  2  20                   .BYTE   ops2|am_nam     ; $CC  CPY abs
00F065  2  20                   .BYTE   ops2|am_nam     ; $CD  CMP abs
00F066  2  20                   .BYTE   ops2|am_nam     ; $CE  DEC abs
00F067  2  30                   .BYTE   ops3|am_nam     ; $CF  CMP absl
00F068  2               ;
00F068  2  50                   .BYTE   bop1|am_nam     ; $D0  BNE abs
00F069  2  18                   .BYTE   ops1|am_indy    ; $D1  CMP (<dp>),Y
00F06A  2  14                   .BYTE   ops1|am_ind     ; $D2  CMP (dp)
00F06B  2  1A                   .BYTE   ops1|am_stky    ; $D3  CMP (<offset>,S),Y
00F06C  2  10                   .BYTE   ops1|am_nam     ; $D4  PEI dp
00F06D  2  12                   .BYTE   ops1|am_adrx    ; $D5  CMP dp,X
00F06E  2  12                   .BYTE   ops1|am_adrx    ; $D6  DEC dp,X
00F06F  2  16                   .BYTE   ops1|am_indly   ; $D7  CMP [dp],Y
00F070  2  00                   .BYTE   ops0|am_nam     ; $D8  CLD
00F071  2  23                   .BYTE   ops2|am_adry    ; $D9  CMP abs,Y
00F072  2  00                   .BYTE   ops0|am_nam     ; $DA  PHX
00F073  2  00                   .BYTE   ops0|am_nam     ; $DB  STP
00F074  2  25                   .BYTE   ops2|am_indl    ; $DC  JMP [abs]
00F075  2  22                   .BYTE   ops2|am_adrx    ; $DD  CMP abs,X
00F076  2  22                   .BYTE   ops2|am_adrx    ; $DE  DEC abs,X
00F077  2  32                   .BYTE   ops3|am_adrx    ; $DF  CMP absl,X
00F078  2               ;
00F078  2  91                   .BYTE   vops|am_imm     ; $E0  CPX #
00F079  2  17                   .BYTE   ops1|am_indx    ; $E1  SBC (dp,X)
00F07A  2  11                   .BYTE   ops1|am_imm     ; $E2  SEP #
00F07B  2  19                   .BYTE   ops1|am_stk     ; $E3  SBC <offset>,S
00F07C  2  10                   .BYTE   ops1|am_nam     ; $E4  CPX dp
00F07D  2  10                   .BYTE   ops1|am_nam     ; $E5  SBC dp
00F07E  2  10                   .BYTE   ops1|am_nam     ; $E6  INC dp
00F07F  2  15                   .BYTE   ops1|am_indl    ; $E7  SBC [dp]
00F080  2  00                   .BYTE   ops0|am_nam     ; $E8  INX
00F081  2  91                   .BYTE   vops|am_imm     ; $E9  SBC #
00F082  2  00                   .BYTE   ops0|am_nam     ; $EA  NOP
00F083  2  00                   .BYTE   ops0|am_nam     ; $EB  XBA
00F084  2  20                   .BYTE   ops2|am_nam     ; $EC  CPX abs
00F085  2  20                   .BYTE   ops2|am_nam     ; $ED  SBC abs
00F086  2  20                   .BYTE   ops2|am_nam     ; $EE  INC abs
00F087  2  30                   .BYTE   ops3|am_nam     ; $EF  SBC absl
00F088  2               ;
00F088  2  50                   .BYTE   bop1|am_nam     ; $F0  BEQ abs
00F089  2  18                   .BYTE   ops1|am_indy    ; $F1  SBC (<dp>),Y
00F08A  2  14                   .BYTE   ops1|am_ind     ; $F2  SBC (dp)
00F08B  2  1A                   .BYTE   ops1|am_stky    ; $F3  SBC (<offset>,S),Y
00F08C  2  21                   .BYTE   ops2|am_imm     ; $F4  PEA #
00F08D  2  12                   .BYTE   ops1|am_adrx    ; $F5  SBC dp,X
00F08E  2  12                   .BYTE   ops1|am_adrx    ; $F6  INC dp,X
00F08F  2  16                   .BYTE   ops1|am_indly   ; $F7  SBC [dp],Y
00F090  2  00                   .BYTE   ops0|am_nam     ; $F8  SED
00F091  2  23                   .BYTE   ops2|am_adry    ; $F9  SBC abs,Y
00F092  2  00                   .BYTE   ops0|am_nam     ; $FA  PLX
00F093  2  00                   .BYTE   ops0|am_nam     ; $FB  XCE
00F094  2  27                   .BYTE   ops2|am_indx    ; $FC  JSR (abs,X)
00F095  2  22                   .BYTE   ops2|am_adrx    ; $FD  SBC abs,X
00F096  2  22                   .BYTE   ops2|am_adrx    ; $FE  INC abs,X
00F097  2  32                   .BYTE   ops3|am_adrx    ; $FF  SBC absl,X
00F098  2               ;
00F098  2               ;
00F098  2               ;	.X & .Y immediate mode opcodes...
00F098  2               ;
00F098  2               vopidx:
00F098  2  E0                   .BYTE   opc_cpxi        ;CPX #
00F099  2  C0                   .BYTE   opc_cpyi        ;CPY #
00F09A  2  A2                   .BYTE   opc_ldxi        ;LDX #
00F09B  2  A0                   .BYTE   opc_ldyi        ;LDY #
00F09C  2               n_vopidx        = *-vopidx      ;number of opcodes
00F09C  2               ;
00F09C  2               ;
00F09C  2               ;	addressing mode symbology lookup...
00F09C  2               ;
00F09C  2               ms_lutab:
00F09C  2  B4 F0                .WORD   ms_nam          ;no symbol
00F09E  2  BE F0                .WORD   ms_imm          ;#
00F0A0  2  B6 F0                .WORD   ms_addrx        ;<addr>,X
00F0A2  2  BA F0                .WORD   ms_addry        ;<addr>,Y
00F0A4  2  C0 F0                .WORD   ms_ind          ;(<addr>)
00F0A6  2  C3 F0                .WORD   ms_indl         ;[<dp>]
00F0A8  2  C6 F0                .WORD   ms_indly        ;[<dp>],Y
00F0AA  2  CB F0                .WORD   ms_indx         ;(<addr>,X)
00F0AC  2  D0 F0                .WORD   ms_indy         ;(<dp>),Y
00F0AE  2  D8 F0                .WORD   ms_stk          ;<offset>,S
00F0B0  2  DC F0                .WORD   ms_stky         ;(<offset>,S),Y
00F0B2  2  B4 F0                .WORD   ms_nam          ;<sbnk>,<dbnk>
00F0B4  2               ;
00F0B4  2               ;
00F0B4  2               ;	addressing mode symbology strings...
00F0B4  2               ;
00F0B4  2               ms_nam:
00F0B4  2  20 00                .BYTE   " ",0           ;no symbol
00F0B6  2               ms_addrx:
00F0B6  2  20 2C 58 00          .BYTE   " ,X",0         ;<addr>,X
00F0BA  2               ms_addry:
00F0BA  2  20 2C 59 00          .BYTE   " ,Y",0         ;<addr>,Y
00F0BE  2               ms_imm:
00F0BE  2  23 00                .BYTE   "#",0           ;#
00F0C0  2               ms_ind:
00F0C0  2  28 29 00             .BYTE   "()",0          ;(<addr>)
00F0C3  2               ms_indl:
00F0C3  2  5B 5D 00             .BYTE   "[]",0          ;[<dp>]
00F0C6  2               ms_indly:
00F0C6  2  5B 5D 2C 59          .BYTE   "[],Y",0        ;[<dp>],Y
00F0CA  2  00           
00F0CB  2               ms_indx:
00F0CB  2  28 2C 58 29          .BYTE   "(,X)",0        ;(<addr>,X)
00F0CF  2  00           
00F0D0  2               ms_indy:
00F0D0  2  28 29 2C 59          .BYTE   "(),Y",0        ;(<dp>),Y
00F0D4  2  00           
00F0D5  2               ms_move:
00F0D5  2  2C 24 00             .BYTE   ",$",0          ;<sbnk>,<dbnk>
00F0D8  2               ms_stk:
00F0D8  2  20 2C 53 00          .BYTE   " ,S",0         ;<offset>,S
00F0DC  2               ms_stky:
00F0DC  2  28 2C 53 29          .BYTE   "(,S),Y",0      ;(<offset>,S),Y
00F0E0  2  2C 59 00     
00F0E3  2               ;
00F0E3  2               ;================================================================================
00F0E3  2               ;
00F0E3  2               ;CONSOLE DISPLAY CONTROL STRINGS
00F0E3  2               ;
00F0E3  2               dc_lf:
00F0E3  2  0D 0A                LF                      ;newline
00F0E5  2  00                   .BYTE   0
00F0E6  2               ;
00F0E6  2               dc_bs:  ;destructive backspace
00F0E6  2  08                   .BYTE   a_bs
00F0E7  2  20                   .BYTE   $20
00F0E8  2  08                   .BYTE   a_bs
00F0E9  2  00                   .BYTE   0
00F0EA  2               ;
00F0EA  2               dc_cl_DUMB:                     ;clear to end of line
00F0EA  2  0D 0A                .BYTE   $0d,$0a
00F0EC  2  00                   .BYTE   0
00F0ED  2               dc_cl_ANSI:                     ;clear to end of line
00F0ED  2  1B 5B 4B             .BYTE   a_esc,"[K"
00F0F0  2  00                   .BYTE   0
00F0F1  2               dc_cl_WYSE:                     ;clear to end of line
00F0F1  2  1B 54                .BYTE   a_esc,"T"
00F0F3  2  00                   .BYTE   0
00F0F4  2               
00F0F4  2               ;
00F0F4  2               ;
00F0F4  2               
00F0F4  2               ;
00F0F4  2               ;================================================================================
00F0F4  2               ;
00F0F4  2               ;TEXT STRINGS
00F0F4  2               ;
00F0F4  2               mm_brk:
00F0F4  2  07                   RB
00F0F5  2  0D 0A                LF
00F0F7  2  2A 42 52 4B          .BYTE   "*BRK"
00F0FB  2  0D 0A                LF
00F0FD  2  00                   .BYTE   0
00F0FE  2               ;
00F0FE  2               mm_entry:
00F0FE  2  0D 0A                LF
00F100  2  53 75 70 65          .BYTE   "Supermon 816 "
00F104  2  72 6D 6F 6E  
00F108  2  20 38 31 36  
00F10D  2  31 2E 30 2E          SOFTVERS
00F111  2  32           
00F112  2  20                   .BYTE   " "
00F113  2  0D 0A                LF
00F115  2  00                   .BYTE   0
00F116  2               ;
00F116  2               mm_err:
00F116  2  20 2A 45 52          .BYTE   " *ERR ",0
00F11A  2  52 20 00     
00F11D  2               ;
00F11D  2               mm_prmpt:
00F11D  2  0D 0A                LF
00F11F  2  2E 00                .BYTE   ".",0
00F121  2               ;
00F121  2               mm_regs:
00F121  2  0D 0A                LF
00F123  2  50 42 20 20          .BYTE   "PB  PC   NVmxDIZC  .C   .X   .Y   SP"
00F127  2  50 43 20 20  
00F12B  2  20 4E 56 6D  
00F147  2  0D 0A                LF
00F149  2  00                   .BYTE   0
00F14A  2               mm_regs1:
00F14A  2  0D 0A                LF
00F14C  2  20 44 50 20          .BYTE   " DP  DB"
00F150  2  20 44 42     
00F153  2  0D 0A                LF
00F155  2  00                   .BYTE   0
00F156  2               
00F156  2               ;
00F156  2               mm_rts:
00F156  2  07                   RB
00F157  2  0D 0A                LF
00F159  2  2A 52 54 53          .BYTE   "*RTS"
00F15D  2  0D 0A                LF
00F15F  2  00                   .BYTE   0
00F160  2               
00F160  2               
00F160  2               mm_S19_prmpt:
00F160  2  0D 0A                LF
00F162  2  42 65 67 69          .BYTE   "Begin sending S28 encoded file. . ."
00F166  2  6E 20 73 65  
00F16A  2  6E 64 69 6E  
00F185  2  0D 0A                LF
00F187  2  00                   .BYTE   0
00F188  2               
00F188  2               ;
00F188  2               ALIVEM:
00F188  2  0D 0A                .BYTE   $0D,$0A
00F18A  2  0D 0A                .BYTE   $0D,$0A
00F18C  2  20 20 20 5F          .BYTE   "   __ _____  ___  __   __",$0D,$0A
00F190  2  5F 20 5F 5F  
00F194  2  5F 5F 5F 20  
00F1A7  2  20 20 2F 20          .BYTE   "  / /| ____|/ _ \/_ | / /",$0D,$0A
00F1AB  2  2F 7C 20 5F  
00F1AF  2  5F 5F 5F 7C  
00F1C2  2  20 2F 20 2F          .BYTE   " / /_| |__ | (_) || |/ /_",$0D,$0A
00F1C6  2  5F 7C 20 7C  
00F1CA  2  5F 5F 20 7C  
00F1DD  2  7C 20 20 5F          .BYTE   "|  _ \___ \ > _ < | |  _ \",$0D,$0A
00F1E1  2  20 5C 5F 5F  
00F1E5  2  5F 20 5C 20  
00F1F9  2  7C 20 28 5F          .BYTE   "| (_) |__) | (_) || | (_) |",$0D,$0A
00F1FD  2  29 20 7C 5F  
00F201  2  5F 29 20 7C  
00F216  2  20 5C 5F 5F          .BYTE   " \___/____/ \___/ |_|\___/ ",$0D,$0A
00F21A  2  5F 2F 5F 5F  
00F21E  2  5F 5F 2F 20  
00F233  2  0D 0A                .BYTE   $0D,$0A
00F235  2  36 35 63 38          .BYTE   "65c816 BIOS (NATIVE MODE)",$0D,$0A
00F239  2  31 36 20 42  
00F23D  2  49 4F 53 20  
00F250  2  44 55 4F 44          .BYTE   "DUODYNE v1 9/30/2022 - D.WERNER",$0D,$0A
00F254  2  59 4E 45 20  
00F258  2  76 31 20 39  
00F271  2  2D 2D 2D 2D          .BYTE   "-------------------------------------",$0D,$0A
00F275  2  2D 2D 2D 2D  
00F279  2  2D 2D 2D 2D  
00F298  2  0D 0A 00             .BYTE   $0D,$0A,0
00F29B  2               ;
00F29B  2               
00F29B  2               
00F29B  2               _txtend_        = *             ;end of program text
00F29B  2               ;
00F29B  2               ;================================================================================
00F29B  2               
00F29B  1               
00F29B  1                       .SEGMENT "NJUMP"
00F29B  1               ; BIOS JUMP TABLE (NATIVE)
00F29B  1                       .ORG    $FD00
00FD00  1               LPRINTVEC:
00FD00  1  20 61 E0             JSR     OUTCH
00FD03  1  6B                   RTL
00FD04  1               LINPVEC:
00FD04  1  20 7B E0             JSR     INCH
00FD07  1  6B                   RTL
00FD08  1               LINPWVEC:
00FD08  1  20 6F E0             JSR     INCHW
00FD0B  1  6B                   RTL
00FD0C  1                       .SEGMENT "EJUMP"
00FD0C  1               ; BIOS JUMP TABLE (Emulation)
00FD0C  1                       .ORG    $FF71
00FF71  1               PRINTVEC:
00FF71  1  4C 61 E0             JMP     OUTCH
00FF74  1               INPVEC:
00FF74  1  4C 7B E0             JMP     INCH
00FF77  1               INPWVEC:
00FF77  1  4C 6F E0             JMP     INCHW
00FF7A  1               
00FF7A  1                       .SEGMENT "VECTORS"
00FF7A  1               ; 65c816 Native Vectors
00FF7A  1                       .ORG    $FFE4
00FFE4  1               COPVECTOR:
00FFE4  1  36 E0                .WORD   RCOPVECTOR
00FFE6  1               BRKVECTOR:
00FFE6  1  39 E0                .WORD   RBRKVECTOR
00FFE8  1               ABTVECTOR:
00FFE8  1  3C E0                .WORD   RABTVECTOR
00FFEA  1               NMIVECTOR:
00FFEA  1  3F E0                .WORD   RNMIVECTOR
00FFEC  1               resv1:
00FFEC  1  00 00                .WORD   $0000           ;
00FFEE  1               IRQVECTOR:
00FFEE  1  42 E0                .WORD   RIRQVECTOR      ; ROM VECTOR FOR IRQ
00FFF0  1               
00FFF0  1  00 00                .WORD   $0000           ;
00FFF2  1  00 00                .WORD   $0000           ;
00FFF4  1               
00FFF4  1               ; 6502 Emulation Vectors
00FFF4  1                       .ORG    $FFF4
00FFF4  1               ECOPVECTOR:
00FFF4  1  45 E0                .WORD   RECOPVECTOR
00FFF6  1               resv2:
00FFF6  1  00 00                .WORD   $0000
00FFF8  1               EABTVECTOR:
00FFF8  1  48 E0                .WORD   REABTVECTOR
00FFFA  1               ENMIVECTOR:
00FFFA  1  4B E0                .WORD   RENMIVECTOR
00FFFC  1               RSTVECTOR:
00FFFC  1  00 E0                .WORD   COLD_START      ;
00FFFE  1               EINTVECTOR:
00FFFE  1  4E E0                .WORD   REINTVECTOR     ; ROM VECTOR FOR IRQ
010000  1               
010000  1                       .END
