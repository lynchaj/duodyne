     1                                  %ifndef SOFT_DEBUG
     2                                  ;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ; RBIOS.ASM -- Relocatable BIOS for the RetroBrew SBC-188 v.0.4 to 3.1
     6                                  ; Updated for the Duodyne 80c188 SBC 10/2024
     7                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     8                                  ;
     9                                  ;   This version is for assembly by  NASM 0.98.39 or later
    10                                  ;
    11                                  ; Copyright (C) 2011-2017 John R. Coffman.  All rights reserved.
    12                                  ; Provided for hobbyist use on the RetroBrew SBC-188 board.
    13                                  ;
    14                                  ; This program is free software: you can redistribute it and/or modify
    15                                  ; it under the terms of the GNU General Public License as published by
    16                                  ; the Free Software Foundation, either version 3 of the License, or
    17                                  ; (at your option) any later version.
    18                                  ;
    19                                  ; This program is distributed in the hope that it will be useful,
    20                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    21                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    22                                  ; GNU General Public License for more details.
    23                                  ;
    24                                  ; You should have received a copy of the GNU General Public License
    25                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    26                                  ;
    27                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                                  
    29                                  	cpu	186
    30                                  
    31                                  
    32                                  
    33                                  
    34                                  %include	"config.asm"
    35                              <1> ;/*
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; ANSI.CFG
    38                              <1> ;   Copied to CONFIG.ASM for general release.
    39                              <1> ;
    40                              <1> ;       Modify the parameters below to reflect your system
    41                              <1> ;
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    46                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    48                              <1> ;
    49                              <1> ; Define the serial terminal that the Video BIOS must emulate
    50                              <1> ; Set one of the following to 1
    51                              <1> ; If you have no idea what to choose, set TTY to 1
    52                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    53                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    54                              <1> ANSI    equ     1       ; very smart, like a VT-100
    55                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    56                              <1> ; others may get added in the future
    57                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    58                              <1> ;
    59                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    60                              <1> ;UART_RATE	equ	0		; 1200
    61                              <1> ;UART_RATE	equ	1		; 2400
    62                              <1> ;UART_RATE	equ	2		; 4800
    63                              <1> UART_RATE	equ	3		; 9600
    64                              <1> ;UART_RATE	equ	4		; 19200
    65                              <1> ;UART_RATE	equ	5		; 38400
    66                              <1> ;UART_RATE	equ	6		; 57600
    67                              <1> ;UART_RATE	equ	7		; 115200
    68                              <1> 
    69                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    70                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    71                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    72                              <1> 						; but not ANSI
    73                              <1> ; Define the size of the ROM image on the system in Kilobytes
    74                              <1> ; It may be smaller than the actual EPROM in use.
    75                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    76                              <1> %ifndef ROM
    77                              <1> ROM             equ     32              ; 64 is the default
    78                              <1> %endif
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the ROM operates
    81                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    82                              <1> 
    83                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    84                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    85                              <1> RAM_DOS         equ     640
    86                              <1> 
    87                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    88                              <1> ; the default is 512 kilobytes
    89                              <1> RAM             equ     512             ; (512 is the default)
    90                              <1> 
    91                              <1> ; Define the number of Wait States at which the RAM operates
    92                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    93                              <1> 
    94                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    95                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    96                              <1> 
    97                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    98                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    99                              <1> 
   100                              <1> ; Define the time zone in which we build the Relocatable BIOS
   101                              <1> %ifndef TIMEZONE
   102                              <1> %define TIMEZONE "CST"
   103                              <1> %endif
   104                              <1> 
   105                              <1> ; Has the REDBUG debugger been loaded?
   106                              <1> %ifndef SOFT_DEBUG
   107                              <1> %define SOFT_DEBUG 0
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   111                              <1> %ifndef TBASIC
   112                              <1> TBASIC          equ     1		; default is 1
   113                              <1> %endif
   114                              <1> 
   115                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   116                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   117                              <1> %ifndef FPEM
   118                              <1> FPEM            equ     1               ; default is 1
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   122                              <1> EMM_BOARDS      equ     0
   123                              <1> 
   124                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   125                              <1> ; or at locations 0280h..3FFh in low memory?
   126                              <1> %if SOFT_DEBUG
   127                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   128                              <1> %else
   129                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   130                              <1> %endif
   131                              <1> 
   132                              <1> ; Define the size of the EPROM that is to be installed on the system
   133                              <1> ; It may be larger than the actual ROM image to be generated.
   134                              <1> %ifndef CHIP
   135                              <1> CHIP            equ     64
   136                              <1> %endif
   137                              <1> 
   138                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   139                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   140                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   141                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   142                              <1> 
   143                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   144                              <1> ; If the wiring update is installed, or you have a later board, then
   145                              <1> ; set this to 0.  If you are using the software workaround, then set this
   146                              <1> ; to 1.  The rev 1.0 board has this fix already.
   147                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   148                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   149                              <1> 
   150                              <1> ; Define the UART oscillator speed
   151                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   152                              <1> 
   153                              <1> 
   154                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   155                              <1> ; end of the User configuration
   156                              <1> ;       Do Not modify anything below this point
   157                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   158                              <1> 
   159                              <1> ; Define existence of any uart chip
   160                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   161                              <1> startuplength   equ     512                     ; may be up to 1024
   162                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   163                              <1> highrom         equ     (ROM*400h)&0FFFFh
   164                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   165                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   166                              <1> 
   167                              <1> 
   168                              <1> %define ARG(n) [bp+2+(n)*2]
   169                              <1> 
   170                              <1> %macro  check   1.nolist
   171                              <1>  %if (%1)
   172                              <1>    %error Check Failure: %1
   173                              <1>  %endif
   174                              <1> %endm
   175                              <1> %macro  range   3.nolist
   176                              <1>  %if (%1)<(%2)
   177                              <1>    %error Out of Range: %1
   178                              <1>  %elif (%1)>(%3)
   179                              <1>    %error Out of Range: %1
   180                              <1>  %endif
   181                              <1> %endm
   182                              <1> _terminal equ UART
   183                              <1>  check   RAM_DOS&15
   184                              <1>  check   RAM&(RAM-1)
   185                              <1>  check   ROM&(ROM-1)
   186                              <1>  range   RAM,32,512
   187                              <1>  range   ROM,32,256
   188                              <1>  range   RAM_WS,0,3
   189                              <1>  range   ROM_WS,0,3
   190                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   191                              <1>  range   LCL_IO_WS,0,3
   192                              <1>  range   BUS_IO_WS,0,3
   193                              <1>  range   UART_OSC,500000,16000000
   194                              <1>  range   UART_RATE,0,7
   195                              <1>  range	 UART,0,1
   196                              <1>  range	 _terminal,1,2
   197                              <1> 
   198                              <1> %ifndef SOFT_DEBUG
   199                              <1> %define SOFT_DEBUG 0
   200                              <1> %endif
   201                              <1> 
   202                              <1> %ifndef TRACE
   203                              <1> %define TRACE 0
   204                              <1> %endif
   205                              <1> 
   206                              <1> %ifdef MAKE_OBJECT_FILE
   207                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   208                              <1>         export _ROMsize
   209                              <1>         export _CHIPsize
   210                              <1> _ROMsize        dw      ROM
   211                              <1> _CHIPsize       dw      CHIP
   212                              <1> %endif
   213                              <1> ; end of the Hardware configuration file
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> ;*/
    35                                  %include	"cpuregs.asm"
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; CPUREGS.ASM
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    41                              <1> ;
    42                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    43                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    44                              <1> ;
    45                              <1> ; This program is free software: you can redistribute it and/or modify
    46                              <1> ; it under the terms of the GNU General Public License as published by
    47                              <1> ; the Free Software Foundation, either version 3 of the License, or
    48                              <1> ; (at your option) any later version.
    49                              <1> ;
    50                              <1> ; This program is distributed in the hope that it will be useful,
    51                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    52                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    53                              <1> ; GNU General Public License for more details.
    54                              <1> ;
    55                              <1> ; You should have received a copy of the GNU General Public License
    56                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    57                              <1> ;
    58                              <1> ; Updated for the Duodyne 80c188 SBC
    59                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                              <1> %include	"macros.inc"
    61                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <2> ; MACROS.INC  
    63                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <2> ;
    65                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    66                              <2> ;
    67                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    68                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    69                              <2> ;
    70                              <2> ; This program is free software: you can redistribute it and/or modify
    71                              <2> ; it under the terms of the GNU General Public License as published by
    72                              <2> ; the Free Software Foundation, either version 3 of the License, or
    73                              <2> ; (at your option) any later version.
    74                              <2> ;
    75                              <2> ; This program is distributed in the hope that it will be useful,
    76                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    77                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    78                              <2> ; GNU General Public License for more details.
    79                              <2> ;
    80                              <2> ; You should have received a copy of the GNU General Public License
    81                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    82                              <2> ;
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> 
    85                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    86                              <2> ;
    87                              <2> ;
    88                              <2> %ifndef __MACROS_DEFINED_
    89                              <2> %define __MACROS_DEFINED_ 1
    90                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    91                              <2> ;
    92                              <2> ; some useful macros:
    93                              <2> ;
    94                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                              <2> ;
    96                              <2> 	cpu	186
    97                              <2> 
    98                              <2> %imacro setloc  1.nolist
    99                              <2>  times   (%1-($-$$)) db 0FFh
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro db_lo   1
   103                              <2>  db (%1)&255
   104                              <2> %endm
   105                              <2> 
   106                              <2> %imacro cnop    0.nolist
   107                              <2> %if SOFT_DEBUG
   108                              <2>         nop
   109                              <2> %endif
   110                              <2> %endm
   111                              <2> 
   112                              <2> %imacro popm 1-*.nolist
   113                              <2> %rep %0
   114                              <2> %ifidni %1,ALL
   115                              <2>  popa
   116                              <2> %elifidni %1,F
   117                              <2>  popf
   118                              <2> %else
   119                              <2>  pop %1
   120                              <2> %ifidni %1,DS
   121                              <2>  cnop
   122                              <2> %elifidni %1,ES
   123                              <2>  cnop
   124                              <2> %endif
   125                              <2> %endif
   126                              <2> %rotate 1
   127                              <2> %endrep
   128                              <2> %endm
   129                              <2> 
   130                              <2> %imacro pushm 1-*.nolist
   131                              <2> %rep %0
   132                              <2> %rotate -1
   133                              <2> %ifidni %1,ALL
   134                              <2>  pusha
   135                              <2> %elifidni %1,F
   136                              <2>  pushf
   137                              <2> %else
   138                              <2>  push %1
   139                              <2> %endif
   140                              <2> %endrep
   141                              <2> %endm
   142                              <2> 
   143                              <2> ;
   144                              <2> ; added from the 386EX project
   145                              <2> ;
   146                              <2> 
   147                              <2> ; call arguments
   148                              <2> %define ARG(n) [bp+2+(n)*2]
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the BYTE initialization table:  address, byte
   152                              <2> ;
   153                              <2> %imacro  binit 2
   154                              <2>         dw      %1
   155                              <2>         db      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> ;
   160                              <2> ; format of the WORD initialization table:  address, word
   161                              <2> ;
   162                              <2> %imacro  winit 2
   163                              <2>         dw      %1
   164                              <2>         dw      %2
   165                              <2> %endmacro
   166                              <2> ; end with DW -1
   167                              <2> 
   168                              <2> 
   169                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   170                              <2> %imacro get_bda	1.nolist
   171                              <2> 	push	0x0040
   172                              <2> 	pop	%1
   173                              <2> 	cnop
   174                              <2> %endm
   175                              <2> 
   176                              <2> 
   177                              <2> %endif
    61                              <1> 
    62                              <1> 	cpu     186
    63                              <1> ;
    64                              <1> ;
    65                              <1> ; IBM model byte -- must be less than a 286
    66                              <1> ;
    67                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    68                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    69                              <1> 
    70                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    71                              <1> SUBMODEL_BYTE		equ	00h	;  "
    72                              <1> 
    73                              <1> 
    74                              <1> ; 80188 peripheral control register block address
    75                              <1> CPU_CSCR	        equ	0FF00h
    76                              <1> 
    77                              <1> ; Compatible Mode registers
    78                              <1> 
    79                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    80                              <1> 
    81                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    82                              <1> 
    83                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    84                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    85                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    86                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    87                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    88                              <1> 
    89                              <1> ; Enhanced Mode registers
    90                              <1> 
    91                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    92                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    93                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    94                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    95                              <1> 
    96                              <1> 
    97                              <1> ; On-board internal peripheral equates
    98                              <1> ; Programmable Interrupt Controller
    99                              <1> PIC	        equ	CPU_CSCR+020H
   100                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
   101                              <1> PIC_POLLR	equ	PIC+4
   102                              <1> PIC_POLLSR	equ	PIC+6
   103                              <1> PIC_IMASK	equ	PIC+8
   104                              <1> PIC_PMREG	equ	PIC+0AH
   105                              <1> PIC_SRVR	equ	PIC+0CH
   106                              <1> PIC_IRQR	equ	PIC+0EH
   107                              <1> PIC_IRQSR	equ	PIC+10H
   108                              <1> PIC_TCR	        equ	PIC+12H
   109                              <1> PIC_DMA0CR	equ	PIC+14H
   110                              <1> PIC_DMA1CR	equ	PIC+16H
   111                              <1> PIC_I0CON	equ	PIC+18H
   112                              <1> PIC_I1CON	equ	PIC+1AH
   113                              <1> PIC_I2CON	equ	PIC+1CH
   114                              <1> PIC_I3CON	equ	PIC+1EH
   115                              <1> 
   116                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   117                              <1> 
   118                              <1> ; Interrupt masks (Master Mode)
   119                              <1> ;
   120                              <1> mask_timer_all          equ     0001h
   121                              <1> mask_dma0               equ     0004h
   122                              <1> mask_dma1               equ     0008h
   123                              <1> mask_int0               equ     0010h
   124                              <1> mask_int1               equ     0020h
   125                              <1> mask_int2               equ     0040h
   126                              <1> mask_int3               equ     0080h
   127                              <1> 
   128                              <1> 
   129                              <1> 
   130                              <1> ; Timers
   131                              <1> TIM0	        equ	CPU_CSCR+050H
   132                              <1> TIM1	        equ	CPU_CSCR+058H
   133                              <1> TIM2	        equ	CPU_CSCR+060H
   134                              <1> 
   135                              <1> TCNT	        equ	0	; count register
   136                              <1> CMPA	        equ	2	; max count A
   137                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   138                              <1> TCON	        equ	6	; mode/control word
   139                              <1> 
   140                              <1> ; Timer control bits:
   141                              <1> tc_EN           equ     8000h   ; Enable bit
   142                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   143                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   144                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   145                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   146                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   147                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   148                              <1> tc_EXT          equ     0004h   ; External clock
   149                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   150                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   151                              <1> 
   152                              <1> 
   153                              <1> 
   154                              <1> 
   155                              <1> ; DMA
   156                              <1> DMA0	        equ	CPU_CSCR+0C0H
   157                              <1> DMA1	        equ	CPU_CSCR+0D0H
   158                              <1> DMASPL	        equ	0	; source pointer low
   159                              <1> DMASPU	        equ	2	; source pointer high
   160                              <1> DMADPL	        equ	4	; destination pointer low
   161                              <1> DMADPU	        equ	6	; destination pointer high
   162                              <1> DMATC	        equ	8	; terminal count
   163                              <1> DMACW	        equ	0AH	; control word
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ;
   171                              <1> ;       SBC-188 external devices
   172                              <1> ;
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> 
   175                              <1> IO_BASE			equ	0400h
   176                              <1> 
   177                              <1> 
   178                              <1> 
   179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   180                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   181                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   182                              <1> 
   183                              <1> uart_base               equ     IO_BASE+0280h
   184                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   185                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   186                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   187                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   188                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   189                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   190                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   191                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   192                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   193                              <1> uart_sr			equ	uart_base+7	;Scratch
   194                              <1> 
   195                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   196                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   197                              <1> 
   198                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   200                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   201                              <1> CTRL259		equ	IO_BASE+0238H
   202                              <1> ; LEDS are at addresses 0..3
   203                              <1> ; other control ports on 4..7
   204                              <1> LED0		equ	CTRL259+0
   205                              <1> LED1		equ	LED0+1
   206                              <1> LED2		equ	LED0+2
   207                              <1> LED3		equ	LED0+3
   208                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   209                              <1> ;unused		equ	CTRL259+5
   210                              <1> ;unused		equ	CTRL259+6
   211                              <1> ;unused		equ	CTRL259+7
   212                              <1> 
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   216                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   217                              <1> 
   218                              <1> 
   219                              <1> 
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> ; Floppy controller (Duodyne Disk IO)
   222                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223                              <1> FDC	        equ	IO_BASE+0200H
   224                              <1> FDC_MSR         equ     FDC
   225                              <1> FDC_DATA        equ     FDC_MSR+1
   226                              <1> FDC_DACK        equ	FDC+10H
   227                              <1> FDC_LDOR	equ	FDC+20H
   228                              <1> FDC_LDCR	equ	FDC+30H
   229                              <1> FDC_TC	        equ	FDC+40H
   230                              <1> FDC_RES	        equ	FDC+40H
   231                              <1> FDC_DACK_TC     equ     FDC_DACK | FDC_TC
   232                              <1> 
   233                              <1> 
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   237                              <1> RTC	equ	IO_BASE+0094H
   238                              <1> 
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   241                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   242                              <1> PPI	        equ	IO_BASE+0088H
   243                              <1> 
   244                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   245                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   246                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   247                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   248                              <1> 
   249                              <1> portA           equ     PPI+0   ;
   250                              <1> portB           equ     PPI+1   ;
   251                              <1> portC           equ     PPI+2   ;
   252                              <1> 
   253                              <1> ; end CPUREGS.ASM
    36                                  %include	"date.asm"
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> ; date.asm
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    41                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    42                              <1> ;
    43                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    44                              <1> ;
    45                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    46                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    47                              <1> ;
    48                              <1> ; Definitions for version 3.5-2:
    49                              <1> ;
    50                              <1> ; Updated for the Duodyne 80c188 SBC
    51                              <1> 
    52                              <1> %define DATE_STRING0	"10/27/24"
    53                              <1> %define DATE_STRING1	"27-Oct-2024"
    54                              <1> 
    55                              <1> %define VERSION_MAJOR		3
    56                              <1> %define VERSION_MINOR		5
    57                              <1> %define VERSION_REVISION	2
    58                              <1> %define VERSION_SUFFIX		""
    59                              <1> %define VERSION_SEQUENCE	66
    60                              <1> 
    61                              <1> %define VERSION_STRING		"3.5-D",VERSION_SUFFIX
    62                              <1> 
    63                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <1> ; Revision information:
    65                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    66                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    67                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    68                              <1> ;	    &  Dual SDcard & Minix boot
    69                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    70                              <1> ;	3.0 -- VGA3 support
    71                              <1> ;	3.1 -- SBC-188 v.3 board support
    72                              <1> ;	3.2 -- IDE8 support on the v.3 board
    73                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    74                              <1> ;	3.4 -- floppy drives did not work
    75                              <1> ;	3.5 -- back to 3.3, sequence #51
    76                              <1> ;		change NVRAM battery backup setup to #53
    77                              <1> ;		re-install 3.4 boot fix for FreeDOS
    78                              <1> ;       3.5-D  Remove SBC-188 specific items and customize for Duodyne
    79                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                                  %include	"equates.asm"
    38                              <1> ;========================================================================
    39                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    40                              <1> ;========================================================================
    41                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    46                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;
    48                              <1> ; This program is free software: you can redistribute it and/or modify
    49                              <1> ; it under the terms of the GNU General Public License as published by
    50                              <1> ; the Free Software Foundation, either version 3 of the License, or
    51                              <1> ; (at your option) any later version.
    52                              <1> ;
    53                              <1> ; This program is distributed in the hope that it will be useful,
    54                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    55                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    56                              <1> ; GNU General Public License for more details.
    57                              <1> ;
    58                              <1> ; You should have received a copy of the GNU General Public License
    59                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    60                              <1> ;
    61                              <1> ;========================================================================
    62                              <1> 
    63                              <1>         global  FPEM_segment
    64                              <1> 
    65                              <1> 
    66                              <1> %include "segdef.asm"
    67                              <2> ;========================================================================
    68                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    69                              <2> ;========================================================================
    70                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    71                              <2> ;
    72                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    73                              <2> ;
    74                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    75                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    76                              <2> ;
    77                              <2> ; This program is free software: you can redistribute it and/or modify
    78                              <2> ; it under the terms of the GNU General Public License as published by
    79                              <2> ; the Free Software Foundation, either version 3 of the License, or
    80                              <2> ; (at your option) any later version.
    81                              <2> ;
    82                              <2> ; This program is distributed in the hope that it will be useful,
    83                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    84                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    85                              <2> ; GNU General Public License for more details.
    86                              <2> ;
    87                              <2> ; You should have received a copy of the GNU General Public License
    88                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    89                              <2> ;
    90                              <2> ;========================================================================
    91                              <2> 
    92                              <2> %ifndef __SEGDEF_
    93                              <2> %define __SEGDEF_
    94                              <2> 
    95                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    96                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    97                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    98                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    99                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   100                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   101                              <2> 
   102                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   103                              <2> 
   104                              <2> %endif
   105                              <2> 
    67                              <1> %include "ascii.asm"
    68                              <2> ; ascii.asm
    69                              <2> ;
    70                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    71                              <2> 
    72                              <2> NUL     equ     00h
    73                              <2> BEL     equ     (CTRL & 'G')
    74                              <2> BS      equ     08h		; ^H
    75                              <2> HT      equ     09h		; ^I
    76                              <2> LF	equ	0Ah		; ^J
    77                              <2> NL      equ     LF
    78                              <2> VT	equ	0Bh		; ^K
    79                              <2> FWD	equ	0Ch		; ^L
    80                              <2> CR	equ	0Dh
    81                              <2> XON     equ     (CTRL & 'Q')
    82                              <2> XOFF    equ     (CTRL & 'S')
    83                              <2> DC1     equ     XON
    84                              <2> DC3     equ     XOFF
    85                              <2> ESC     equ	1Bh
    86                              <2> 
    87                              <2> 
    68                              <1> 
    69                              <1> 
    70                              <1> ; POST error codes. Presently one byte but can expand to word.
    71                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    72                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    73                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    74                              <1> ER_FDC	equ	08h		; Bad FDC
    75                              <1> ER_UNK1	equ	10h		; {unassigned}
    76                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    77                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    78                              <1> ER_UNK2	equ	80h		; {unassigned}
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ;; ************************ BIOS Data Segment ******************************
    83                              <1> ;; BIOS data segment - not all will  be used
    84                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    85                              <1> %include "bda.inc"
    86                              <2> ;/*======================================================================
    87                              <2> ; bda.inc -- BIOS data area definitions
    88                              <2> ;========================================================================
    89                              <2> ;   for the N8VEM SBC-188
    90                              <2> ;
    91                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    92                              <2> ;
    93                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    94                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    95                              <2> ;
    96                              <2> ; This program is free software: you can redistribute it and/or modify
    97                              <2> ; it under the terms of the GNU General Public License as published by
    98                              <2> ; the Free Software Foundation, either version 3 of the License, or
    99                              <2> ; (at your option) any later version.
   100                              <2> ;
   101                              <2> ; This program is distributed in the hope that it will be useful,
   102                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   103                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   104                              <2> ; GNU General Public License for more details.
   105                              <2> ;
   106                              <2> ; You should have received a copy of the GNU General Public License
   107                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   108                              <2> ;
   109                              <2> ;========================================================================
   110                              <2> 
   111                              <2> 			;*/ extern				/*
   112                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   113 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   114 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   115 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   116                              <2> ;	dw	?		; 40:10 	; Equipment present word
   117                              <2> ;  						;  = (1 iff floppies) *     1.
   118                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   119                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   120                              <2> ;  						;  + (init crt mode ) *    16.
   121                              <2> ;  						;  + (# of floppies ) *    64.
   122                              <2> ;  						;  + (# serial ports) *   512.
   123                              <2> ;  						;  + (1 iff toy port) *  4096.
   124                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   125                              <2> ;  						;  + (# parallel LPT) * 16384.
   126 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   127 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   128                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   129 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   130 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   131                              <2> ;;---------------[Keyboard data area]------------;
   132 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   133                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   134 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   135 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   136 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   137 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   138                              <2> kbd_buffer_last	equ	$	;*/				/*
   139                              <2> ;;---------------[Diskette data area]------------;
   140 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   141 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   142 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   143 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   144                              <2> ;				Floppy return code stat byte
   145                              <2> ;				;  1 = bad ic 765 command req.
   146                              <2> ;				;  2 = address mark not found
   147                              <2> ;				;  3 = write to protected disk
   148                              <2> ;				;  4 = sector not found
   149                              <2> ;				;  8 = data late (DMA overrun)
   150                              <2> ;				;  9 = DMA failed 64K page end
   151                              <2> ;				; 16 = bad CRC on floppy read
   152                              <2> ;				; 32 = bad NEC 765 controller
   153                              <2> ;				; 64 = seek operation failed
   154                              <2> ;				;128 = disk drive timed out
   155 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   156                              <2> ;;---------------[Video display area]------------;
   157 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   158                              <2> ;			 	; Current CRT mode  (software)
   159                              <2> ;				;  0 = 40 x 25 text (no color)
   160                              <2> ;				;  1 = 40 x 25 text (16 color)
   161                              <2> ;				;  2 = 80 x 25 text (no color)
   162                              <2> ;				;  3 = 80 x 25 text (16 color)
   163                              <2> ;				;  4 = 320 x 200 grafix 4 color
   164                              <2> ;				;  5 = 320 x 200 grafix 0 color
   165                              <2> ;				;  6 = 640 x 200 grafix 0 color
   166                              <2> ;				;  7 = 80 x 25 text (mono card)
   167 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   168 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   169 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   170 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   171 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   172 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   173 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   174 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   175 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   176                              <2> ;;---------------[Used to setup ROM]-------------;
   177 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   178 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   179                              <2> ;;---------------[Timer data area]---------------;
   180 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   181 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   182                              <2> ;;---------------[System data area]--------------;
   183 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   184 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   185                              <2> ;;---------------[Hard disk scratchpad]----------;
   186 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   187                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   188 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   189 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   190                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   191 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   192 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   193                              <2> ;;---------------[EGA stuff]---------------------;
   194 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   195                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   196 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   197 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   198 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   199 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   200 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   201                              <2> ;;---------------[Additional KBD flags]----------------;
   202 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   203 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   204                              <2> ;;---------------[RTC/timer1 data]---------------------;
   205 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   206 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   207 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   208                              <2> ;;---------------[Cassette I/O stuff]------------------;
   209 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   210 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   211                              <2> ;									Post Acknowleged=00;
   212 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   213 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   214 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   215                              <2> ;
   216 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   217 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   218 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   219 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   220                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   221 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   222 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   223 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   224 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   225 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   226 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   227 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   228 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   229 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   230 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   231 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   232 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   233 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   234 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   235 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   236                              <2> ;
   237                              <2> ;
   238                              <2> 
   239 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   240                              <2> 
   241 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   242                              <2> 
   243 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   244 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   245                              <2> 
   246 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   247                              <2> 
   248 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   249                              <2> 
   250 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   251                              <2> 
   252 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   253                              <2> ;								   CPU clock is half of this
   254                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <2> ;
   256                              <2> ;  System configuration stuff below
   257                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   258                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <2> %if 0				;*/
   260                              <2> #define FIXED_DISK_MAX 4		/*
   261                              <2> %else
   262                              <2> %define FIXED_DISK_MAX 4
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define PPIDE_driver 1		/*
   266                              <2> %else
   267                              <2> %define PPIDE_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define DIDE_driver 0		/*
   271                              <2> %else
   272                              <2> %define DIDE_driver 0
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DISKIO_driver 1		/*
   276                              <2> %else
   277                              <2> %define DISKIO_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define MFPIC_driver 1		/*
   281                              <2> %else
   282                              <2> %define MFPIC_driver 1
   283                              <2> %endif
   284                              <2> %if 0				;*/
   285                              <2> #define DSD_driver 1		/*
   286                              <2> %else
   287                              <2> %define DSD_driver 1
   288                              <2> %endif
   289                              <2> %if 0				;*/
   290                              <2> #define V3IDE8_driver (SBC188==3)		/*
   291                              <2> %else
   292                              <2> %define V3IDE8_driver (SBC188==3)
   293                              <2> %endif
   294                              <2> 				;*/
    86                              <1> 
    87                              <1> ;  this must be the same in EQUATES.H */
    88                              <1> %if SOFT_DEBUG
    89                              <1> %define NBREAK  8
    90                              <1> %endif
    91                              <1> 
    92                              <1> 
    93                              <1> %if 0
    94                              <1>         segment _TEXT
    95                              <1> ;; *************************************************************************
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ;; ************************ DOS Data Segment *******************************
   101                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   102                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   103                              <1> ;						;  1 if PrtSc xeroxing screen
   104                              <1> ;						;255 if PrtSc error in xerox
   105                              <1> ;						;  ...non-grafix PrtSc in bios
   106                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   107                              <1> ;						;  ...IBMBIO.COM buffers the
   108                              <1> ;						;  ...directory of the boot
   109                              <1> ;						;  ...device here at IPL time
   110                              <1> ;						;  ...when locating the guts
   111                              <1> ;						;  ...of the operating system
   112                              <1> ;						;  ...filename "IBMDOS.COM"
   113                              <1> ;dosdir	ends
   114                              <1> ;; *************************************************************************
   115                              <1> ;; ************************ DOS IPL Segment ********************************
   116                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   117                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   118                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   119                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   120                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   121                              <1> ;dosseg	ends					;			      !
   122                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   123                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   124                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   125                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   126                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   127                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   128                              <1> ;iplseg	ends
   129                              <1> 
   130                              <1> %endif
    38                                  
    39                                  %define	VERSION	VERSION_STRING
    40                                  %define	DATE	DATE_STRING1
    41                                  
    42                                  ;;      global  begin_here
    43                                  	global	cold_boot
    44                                          global  initialization
    45                                  	extern	ident2
    46                                          extern  _cprintf
    47                                  %if TRACE
    48                                  	extern	int_trace
    49                                  %endif	; TRACE
    50                                  
    51                                  
    52                                  	segment         _TEXT
    53                                  
    54                                  cold_boot:
    55 00000000 FA                              cli                     ; Should be clear already
    56 00000001 89C3                    	mov	bx,ax		; save board revision in BX
    57                                  %if SOFT_DEBUG
    58                                          mov     dx,FRONT_PANEL_LED
    59                                          mov     al,0A5h         ; A5 to the LITES
    60                                          out     dx,al
    61                                  %endif
    62 00000003 B84000                          mov     ax,bios_data_seg
    63 00000006 8ED0                            mov     ss,ax
    64 00000008 BC0070                          mov     sp,7000h        ; Stack should be out of the way
    65                                  ; cannot use the stack yet, since memory is not tested
    66                                  %if 0
    67                                      ss	mov	bx,word [warm_boot]	; check for 1234h == Warm Boot
    68                                  %else
    69 0000000B 30FF                    	xor	bh,bh			; not warm boot
    70 0000000D 36813E72003412              ss  cmp	word [warm_boot],1234h
    71 00000014 7504                    	jne	.1
    72 00000016 FEC7                    	inc	bh			; it IS a warm boot
    73 00000018 EB08                    	jmp	cold_continue		; JRC - DEBUG test
    74                                  .1:
    75                                  %endif
    76                                  %if SOFT_DEBUG
    77                                  	push	5Ah
    78                                  	call	lites
    79                                  %endif
    80                                  memory_testing:
    81                                  ; Immediately test low memory
    82 0000001A 31C0                            xor     ax,ax           ; Segment 0
    83 0000001C BD[2200]                        mov     bp,.0           ; return address
    84 0000001F E9D003                          jmp     memtest0        ; don't use the stack
    85                                  .0:
    86                                  ; BX was preserved by 'memtest0'
    87                                  
    88                                  %if SOFT_DEBUG
    89                                          jnc     cold_continue
    90                                          mov     dx,FRONT_PANEL_LED
    91                                          mov     al,0F1h         ; F1 to the LITES
    92                                          out     dx,al
    93                                  .1:
    94                                          hlt
    95                                          jmp     .1              ; solid halt on error
    96                                  %endif
    97                                  
    98                                  cold_continue:
    99 00000022 FC                              cld                     ; Clear the direction flag
   100 00000023 31C0                            xor     ax,ax
   101 00000025 8EC0                            mov     es,ax
   102                                          cnop
   103 00000027 89C7                            mov     di,ax
   104 00000029 B90003                          mov     cx,600h/2       ; clear segments 00h, 040h and 050h
   105 0000002C F3AB                       rep  stosw                   ; clear out BIOS DATA AREA
   106                                  
   107                                  %if 0
   108                                     ss	mov	word [warm_boot],bx	; save only warm boot flag
   109                                  %else
   110 0000002E 36881E1600                 ss	mov	byte [sbc188_rev],bl	; save board revision
   111 00000033 36891E7200                 ss	mov	word [warm_boot],bx	; save warm boot garbage
   112 00000038 08FF                       	or	bh,bh			; test for warm boot
   113 0000003A 7407                    	jz	.3
   114 0000003C 36C70672003412             ss	mov	word [warm_boot],1234h	; restore warm boot code
   115                                  .3:
   116                                  %endif
   117 00000043 E83E03                          call    get_ramsize
   118 00000046 C1E006                          shl     ax,6            ; convert to Segment address
   119                                  %if SOFT_DEBUG
   120                                  	mov	cx,_BSS		; paragraph of _BSS segment
   121                                  ; since the BSS is of length 0000, this is beyond all data
   122                                  
   123                                          mov     bx,cs           ; Code Segment
   124                                          sub     cx,bx           ; Code paragraphs
   125                                          push    cx
   126                                          mov     bx,ax           ; Save HMA in K
   127                                          sub     bx,cx           ; new Code segment
   128                                          mov     es,bx           ; Destination
   129                                          cnop
   130                                          mov     ax,bx           ; Paragraph address to AX
   131                                  
   132                                          push    cs
   133                                          popm     ds              ; Source
   134                                          xor     si,si
   135                                          xor     di,di
   136                                          pop     cx              ; Code length in Paragraphs
   137                                          shl     cx,3            ; Code length in words
   138                                     rep  movsw                   ; move all of it
   139                                          push    es              ; new Code segment
   140                                          push    word SOFT_continue   ; IP
   141                                          retf
   142                                  
   143                                          global  SOFT_continue
   144                                  SOFT_continue:                  ; Continue here in soft memory
   145                                  ;
   146                                  ;  Allocate the DEBUG static area
   147                                  ;
   148                                  	mov	cx,(NBREAK+1)*8 + 15
   149                                  	shr	cx,4		; CX=needed paragraphs
   150                                  	sub	ax,cx		; allocate space
   151                                    ss	mov	[debug_static_ptr+2],ax	 	; setup static area segment
   152                                    ss	mov	word [debug_static_ptr],0	; and offset
   153                                    	shl	cx,4		; word count
   154                                  	pushm	ax,ax		; save segment, twice
   155                                  	popm	es		; set segment to zap
   156                                  	xor	di,di		; start at offset 0
   157                                  	mov	ax,di		; AL=0
   158                                    rep	stosb	    		; Zap memory
   159                                  	popm	ax		; restore AX, EBDA paragraph segment
   160                                  %endif
   161                                  ;
   162                                  ; Save the memory pointers
   163                                  ;
   164 00000049 36A3F200                    ss  mov     [EBDA_paragraph],ax
   165 0000004D C1E806                          shr     ax,6
   166 00000050 36A31300                    ss  mov     [memory_size],ax
   167                                  
   168 00000054 68[ssss]                        push    DGROUP
   169 00000057 1F                              popm    ds              ; This is for the C-programs
   170                                  
   171 00000058 E8F601                          call    set_traps	; setup interrupt table
   172 0000005B E8F201                  	call	set_interrupt_priority ; set default interrupt priorities
   173                                  
   174 0000005E B80300                  	mov	ax,UART_RATE	; set the default rate
   175                                  	extern	@nvram_get_video
   176 00000061 E8(0000)                	call	@nvram_get_video
   177                                  				; get RAM_serial byte - UART speed
   178                                  				; returned in AL
   179                                  %if SOFT_DEBUG
   180                                  	PUSH	3
   181                                  	CALL	lites
   182                                  %endif
   183                                  	extern	video_init
   184 00000064 E8(0000)                	call	video_init
   185                                  
   186                                  %if SOFT_DEBUG
   187                                  	PUSH	4
   188                                  	CALL	lites
   189                                  %endif
   190                                  	extern	keyboard_init
   191 00000067 E8(0000)                	call	keyboard_init
   192                                  
   193                                  %if SOFT_DEBUG
   194                                  	PUSH	5
   195                                  	CALL	lites
   196                                  %endif
   197 0000006A FB                      	sti                     ; enable interrupts
   198                                  %if FPEM
   199 0000006B 9BDBE3                  	finit			; will allocate memory
   200                                  %endif
   201                                  %if SOFT_DEBUG
   202                                  	PUSH	1
   203                                  	CALL	lites
   204                                  %endif
   205                                  
   206 0000006E 6A42                    	push	VERSION_SEQUENCE
   207 00000070 0E                      	push	cs
   208 00000071 68[4A06]                	push	ident1
   209 00000074 E8(0000)                	call	_cprintf
   210 00000077 58                      	pop     ax
   211 00000078 68[0000]                	push	ident2
   212 0000007B E8(0000)                	call	_cprintf
   213 0000007E 58                      	pop     ax
   214 0000007F 68[F405]                	push	ident3
   215 00000082 E8(0000)                	call	_cprintf
   216 00000085 58                      	pop     ax
   217 00000086 58                      	pop     ax
   218 00000087 58                      	pop	ax
   219                                  
   220                                  %if SOFT_DEBUG
   221                                  %if SOFT_DEBUG>1
   222                                  	PUSH	2
   223                                  	CALL	lites
   224                                  %endif
   225                                          extern     redbug
   226                                  
   227                                          pushf           ; push the flags
   228                                          push    cs      ; simulate a far call
   229                                          call    redbug  ; call our weak debugger
   230                                     es   mov     cx,[bp+si+4]
   231                                  %if SOFT_DEBUG>1
   232                                  	PUSH	3
   233                                  	CALL	lites
   234                                  %endif
   235                                  
   236                                  %endif
   237                                  
   238                                  HAS_FLOPPY	equ	0000000000000001b
   239                                  HAS_FPU		equ	0000000000000010b
   240                                  HAS_MOUSE	equ	0000000000000100b
   241                                  VIDEO_EGA	equ	0000000000000000b
   242                                  VIDEO_COLOR_40	equ	0000000000010000b
   243                                  VIDEO_COLOR_80	equ	0000000000100000b
   244                                  VIDEO_MONO	equ	0000000000110000b
   245                                  FLOPPIES_1	equ	0000000000000000b
   246                                  FLOPPIES_2	equ	0000000001000000b
   247                                  FLOPPIES_3	equ	0000000010000000b
   248                                  FLOPPIES_4	equ	0000000011000000b
   249                                  SERIAL_0	equ	0000000000000000b
   250                                  SERIAL_1	equ	0000001000000000b
   251                                  SERIAL_2	equ	0000010000000000b
   252                                  SERIAL_3	equ	0000011000000000b
   253                                  SERIAL_4	equ	0000100000000000b
   254                                  SERIAL_5	equ	0000101000000000b
   255                                  SERIAL_6	equ	0000110000000000b
   256                                  SERIAL_7	equ	0000111000000000b
   257                                  PARALLEL_0	equ	0000000000000000b
   258                                  PARALLEL_1	equ	0100000000000000b
   259                                  PARALLEL_2	equ	1000000000000000b
   260                                  PARALLEL_3	equ	1100000000000000b
   261                                  
   262                                  
   263                                  ; setup BIOS data area
   264 00000088 6A40                    	push	bios_data_seg
   265 0000008A 1F                      	popm	ds
   266 0000008B C606AE0000              	mov	byte [lock_count],0	; zap the @enable/@disable lock count
   267                                  ; no serial interface -- it is used for the video driver
   268 00000090 B83100                  	mov	ax,PARALLEL_0|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   269                                  %if FPEM
   270 00000093 83C802                          or      ax,HAS_FPU              ; a bit of a lie
   271                                  %endif
   272 00000096 A31000                  	mov	word [equipment_flag],ax
   273                                  
   274                                  	extern	_cpu_speed
   275 00000099 E8(0000)                	call	_cpu_speed
   276 0000009C 055802                  	add	ax,600
   277 0000009F B9E204                  	mov	cx,1250
   278 000000A2 31D2                    	xor	dx,dx
   279 000000A4 F7F1                    	div	cx
   280 000000A6 A2FF00                  	mov	byte [cpu_xtal],al	; CPU oscillator frequency
   281                                  
   282 000000A9 FF361300                	push	word [memory_size]
   283                                  
   284 000000AD 68[ssss]                	push	DGROUP
   285 000000B0 1F                      	popm	ds			; This is for the C-programs
   286                                  
   287 000000B1 50                      	push	ax
   288                                  	extern	@timer_init
   289 000000B2 E8(0000)                	call	@timer_init
   290 000000B5 58                      	pop	ax
   291                                  
   292 000000B6 1E                      	push	ds
   293 000000B7 A90100                  	test	ax,1
   294 000000BA 7505                    	jnz	.cpu_clock_05
   295 000000BC 68[6D01]                	push	msg_cpu_clock_00
   296 000000BF EB03                    	jmp	.print_cpu_clock
   297                                  .cpu_clock_05:
   298 000000C1 68[6A01]                	push	msg_cpu_clock_05
   299                                  .print_cpu_clock:
   300 000000C4 D1E8                    	shr	ax,1
   301 000000C6 50                      	push	ax
   302 000000C7 1E                      	push	ds
   303 000000C8 68[3201]                	push	msg_cpu_memory
   304 000000CB E8(0000)                	call	_cprintf
   305 000000CE 83C40A                  	add	sp,12-2
   306                                  %if 1
   307 000000D1 58                              pop     ax                      ; memory size in K
   308 000000D2 E88903                          call    POST_memory             ; Power On Self Test
   309                                  
   310 000000D5 36C70672003412             ss	mov	word [warm_boot],1234h	; set warm boot code
   311                                  
   312                                  %endif
   313 000000DC E80F00                  	call	nvram_init
   314                                  
   315 000000DF 1E                      	push	ds		; DS = DGROUP (CONST)
   316 000000E0 68[B901]                	push	msg_floppy
   317 000000E3 E8(0000)                	call	_cprintf
   318 000000E6 83C404                  	add	sp,4
   319                                  
   320                                  	extern	@floppy_init
   321 000000E9 E8(0000)                	call	@floppy_init
   322                                  
   323 000000EC EB62                    	jmp	boot_the_OS
   324                                  
   325                                  
   326                                  ;========================================================================
   327                                  ; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   328                                  ;========================================================================
   329                                  nvram_init:
   330                                  	extern	@nvram_check
   331 000000EE E8(0000)                	call	@nvram_check
   332 000000F1 09C0                    	or	ax,ax
   333 000000F3 740C                    	jz	.ask_setup
   334                                  
   335 000000F5 1E                      	push	ds
   336 000000F6 68[8F01]                	push	msg_nvram_bad
   337 000000F9 E8(0000)                	call	_cprintf
   338 000000FC 83C404                  	add	sp,4
   339 000000FF EB2D                    	jmp	.run_setup
   340                                  
   341                                  .ask_setup:
   342 00000101 1E                      	push	ds
   343 00000102 68[6E01]                	push	msg_setup
   344 00000105 E8(0000)                	call	_cprintf
   345 00000108 83C404                  	add	sp,4
   346                                  
   347 0000010B B400                    	mov	ah,0
   348 0000010D CD1A                    	int	1Ah
   349 0000010F 89D3                    	mov	bx,dx
   350 00000111 83C324                  	add	bx,18*2		; wait 2 seconds
   351                                  .wait_setup:
   352 00000114 B401                    	mov	ah,1
   353 00000116 CD16                    	int	16h
   354 00000118 740A                    	jz	.wait_setup_1
   355 0000011A B400                    	mov	ah,0
   356 0000011C CD16                    	int	16h
   357 0000011E 0C20                    	or	al,'s'^'S'
   358 00000120 3C73                    	cmp	al,'s'
   359 00000122 740A                    	je	.run_setup
   360                                  
   361                                  .wait_setup_1:
   362 00000124 B400                    	mov	ah,0
   363 00000126 CD1A                    	int	1Ah
   364 00000128 39DA                    	cmp	dx,bx
   365 0000012A 72E8                    	jb	.wait_setup
   366 0000012C EB03                    	jmp	.skip_setup
   367                                  
   368                                  .run_setup:
   369                                  	extern	@nvram_setup
   370 0000012E E8(0000)                	call	@nvram_setup
   371                                  
   372                                  .skip_setup:
   373                                  	extern	@nvram_apply
   374 00000131 E8(0000)                	call	@nvram_apply
   375                                  
   376 00000134 E8DA01                          call    ticktime                ; set the tick clock
   377                                  
   378 00000137 C3                      	ret
   379                                  
   380                                  ;========================================================================
   381                                  ; BIOS_call_18h - Start ROM Basic
   382                                  ; Note:
   383                                  ;	In this BIOS it prints a "no Basic" message and tries to boot the OS
   384                                  ;	or it will run tests if tests are enabled
   385                                  ;========================================================================
   386                                  BIOS_call_18h:
   387 00000138 FB                      	sti
   388                                  %ifdef TESTS
   389                                  	extern	tests
   390                                  	call	tests
   391                                  %else	; TESTS
   392                                  
   393                                  %if TBASIC
   394                                  ;;;        extern  cbasic
   395                                  ;;;        extern  end_cbasic
   396                                  ;;;	jmp	seg cbasic:cbasic
   397 00000139 EA000000F0              	jmp	0F000h:0000h
   398                                  %else
   399                                  	mov	ax,bios_data_seg
   400                                  	mov	ss,ax			; Reset SS
   401                                  	mov	sp,7000h		; and SP
   402                                  	push	DGROUP			; just in case DS is not pointing
   403                                  	popm	ds			; were it should
   404                                  
   405                                  	push	ds
   406                                  	push	msg_no_basic
   407                                  	call	_cprintf
   408                                  	add	sp,4
   409                                  	mov	ah,0			; get any keystroke; jrc 2012/12/02
   410                                  	int	16h
   411                                  	int	19h			; reboot the OS
   412                                  %endif  ; TBASIC
   413                                  
   414                                  %endif	; TESTS
   415                                  .1:
   416 0000013E F4                      	hlt				; we should never get here
   417 0000013F EBFD                    	jmp	.1
   418                                  
   419                                  ;========================================================================
   420                                  ; BIOS_call_19h  - re-Boot the OS
   421                                  ;========================================================================
   422                                  BIOS_call_19h:
   423 00000141 6A40                    	push	bios_data_seg
   424 00000143 1F                      	popm	ds
   425 00000144 C70672003412            	mov	word [warm_boot],1234h	; set warm boot flag
   426 0000014A FA                      	cli				; disable interrupts
   427 0000014B EA0000FFFF              	jmp	0FFFFh:0000h		; go to STARTUP.BIN code
   428                                  
   429                                  
   430                                  
   431                                  
   432                                  ;========================================================================
   433                                  ;========================================================================
   434                                  boot_the_OS:
   435 00000150 B84000                  	mov	ax,bios_data_seg
   436 00000153 8ED0                    	mov	ss,ax			; Reset SS
   437 00000155 BC0070                  	mov	sp,7000h		; and SP
   438 00000158 68[ssss]                	push	DGROUP			; just in case DS is not pointing
   439 0000015B 1F                      	popm	ds			; were it should
   440 0000015C FB                      	sti
   441                                  
   442                                  ; Disable Drive A for the time being . . .    DDW 11-3-24
   443                                  ;	push	'A'
   444                                  ;	push	ds
   445                                  ;	push	msg_booting
   446                                  ;	call	_cprintf
   447                                  ;	add	sp,6
   448                                  ;
   449                                  ;	mov	dl,0
   450                                  ;	call	boot_drive
   451                                  
   452 0000015D 6A43                    	push	'C'
   453 0000015F 1E                      	push	ds
   454 00000160 68[D201]                	push	msg_booting
   455 00000163 E8(0000)                	call	_cprintf
   456 00000166 83C406                  	add	sp,6
   457                                  %if SOFT_DEBUG>1
   458                                  	int 0
   459                                  %endif
   460 00000169 B280                    	mov	dl,80h
   461 0000016B E80500                  	call	boot_drive
   462                                  
   463 0000016E CD18                    	int	18h			; failed to boot, start ROM Basic
   464                                  
   465                                  .1:
   466 00000170 F4                      	hlt				; we should never get here
   467 00000171 EBFD                    	jmp	.1
   468                                  
   469                                  ;========================================================================
   470                                  ; boot_drive - try to boot from the drive
   471                                  ; Input:
   472                                  ;	DL = drive number (00h = first floppy, 80h = first HDD)
   473                                  ;========================================================================
   474                                  boot_drive:
   475 00000173 BE0300                  	mov	si,3			; make 3 tries before giving up
   476                                  
   477                                  %if SOFT_DEBUG>1
   478                                  	nop
   479                                  	int 0
   480                                  %endif
   481                                  .1:					; loop comes back here
   482 00000176 B400                    	mov	ah,0			; reset the Disk Controller
   483 00000178 CD13                    	int	13h
   484                                  
   485 0000017A 52                      	push	dx
   486 0000017B B408                    	mov	ah,8			; get drive parameters
   487 0000017D CD13                    	int	13h
   488 0000017F 88D0                    	mov	al,dl			; number of drives
   489 00000181 5A                      	pop	dx
   490 00000182 7213                    	jc	.fn8_error
   491                                  
   492                                  
   493                                  %if SOFT_DEBUG > 2
   494                                  	nop
   495                                  	int	0
   496                                  
   497                                          mov     ax,0401h                ; verify sector
   498                                  	mov	cx,1			; track 0, sector 1
   499                                  	mov	dh,0			; head 0
   500                                          int     13h
   501                                  
   502                                          nop
   503                                          int     0
   504                                  %endif
   505                                  
   506 00000184 B80102                  	mov	ax,0201h		; read one sector
   507 00000187 B90100                  	mov	cx,1			; track 0, sector 1
   508 0000018A B600                    	mov	dh,0			; head 0
   509 0000018C 31DB                    	xor	bx,bx
   510 0000018E 8EC3                    	mov	es,bx			; ES = 0
   511 00000190 BB007C                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   512 00000193 CD13                    	int	13h
   513 00000195 730F                    	jnc	.read_ok
   514                                  
   515                                  .fn8_error:
   516 00000197 4E                      	dec	si			; go back and reset the controller
   517 00000198 75DC                    	jnz	.1			; make several tries
   518                                  
   519 0000019A 50                      	push	ax
   520 0000019B 1E                      	push	ds
   521 0000019C 68[F101]                	push	msg_boot_err
   522 0000019F E8(0000)                	call	_cprintf
   523 000001A2 83C406                  	add	sp,4+2
   524 000001A5 C3                      	ret
   525                                  
   526                                  .read_ok:
   527 000001A6 52                      	push	dx
   528                                  
   529 000001A7 B80480                          mov     ax,8004h                ; NVRAM bits
   530 000001AA E8D303                          call    rtc_get_loc
   531 000001AD A802                            test    al,2            ; RAM_bits_AA55 flag
   532 000001AF 7538                            jnz     .cpm_bootsec
   533 000001B1 26813EFE7D55AA              es	cmp	word [7C00h+1FEh],0AA55h
   534 000001B8 7415                    	je	.good_signature
   535 000001BA 26813EBC7D55AA              es	cmp	word [7C00h+1BCh],0AA55h
   536 000001C1 7420                        	je	.minix_bootsec
   537 000001C3 1E                      	push	ds
   538 000001C4 68[0C02]                	push	msg_no_boot
   539 000001C7 E8(0000)                	call	_cprintf
   540 000001CA 83C404                  	add	sp,4		; remove DX also
   541 000001CD 5A                      	pop	dx		; **
   542 000001CE C3                      	ret
   543                                  .good_signature:
   544 000001CF 26833E007C00                es	cmp	word [7C00h+000h],0
   545 000001D5 751C                    	jne	.good_bootsec
   546 000001D7 1E                      	push	ds
   547 000001D8 68[2602]                	push	msg_no_loader
   548 000001DB E8(0000)                	call	_cprintf
   549 000001DE 83C404                  	add	sp,4		; remove DX also
   550 000001E1 5A                      	pop	dx		; **
   551 000001E2 C3                      	ret
   552                                  
   553                                  .minix_bootsec:
   554 000001E3 1E                      	push	ds		; alternate boot signature
   555 000001E4 68[5C02]                	push	msg_alt_disk
   556 000001E7 EB04                    	jmp	short .cpmbs2
   557                                  .cpm_bootsec:
   558 000001E9 1E                              push    ds
   559 000001EA 68[4802]                        push    msg_cpm_disk
   560 000001ED E8(0000)                .cpmbs2:  call    _cprintf
   561 000001F0 83C404                  	add	sp,4
   562                                  .good_bootsec:
   563 000001F3 1E                      	push	ds
   564 000001F4 68[4402]                	push	msg_boot_ok
   565 000001F7 E8(0000)                	call	_cprintf
   566 000001FA 83C404                  	add	sp,4
   567                                  
   568 000001FD 5A                      	pop	dx
   569                                  
   570                                  %if SOFT_DEBUG>1
   571                                  	global	major_debug
   572                                  major_debug:
   573                                  	cmp	dl,0
   574                                  	jne	.999
   575                                  
   576                                  	xor	bx,bx
   577                                  	push	bx
   578                                  	popm	es			; ES = 0
   579                                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   580                                  	int	0
   581                                  
   582                                  	mov	ax,0201h
   583                                  	inc	cl
   584                                  	int	13h
   585                                  
   586                                  	mov	ax,0201h
   587                                  	mov	cl,10h
   588                                  	int	13h
   589                                  
   590                                  	mov	ax,0201h
   591                                  	mov	dh,1
   592                                  	int	13h
   593                                  
   594                                  	mov	ax,0201h
   595                                  	mov	ch,1		; cylinder 1
   596                                  	int	13h
   597                                  
   598                                  	mov	ax,0201h
   599                                  	mov	ch,23h
   600                                  	int	13h
   601                                  
   602                                  	mov	ax,0201h
   603                                  	mov	cx,1
   604                                  	mov	dh,0
   605                                  	int	13h
   606                                  
   607                                  .999:
   608                                  %endif
   609                                  %if SOFT_DEBUG
   610                                  	push	7
   611                                  	call	lites
   612                                  	int 0
   613                                  %endif
   614 000001FE EA007C0000              	jmp	0000:7C00h		; execute the boot sector
   615                                  
   616                                  
   617                                  
   618                                  %if 0		; now part of 2P1S from R. Cini (RAC)
   619                                  ;========================================================================
   620                                  ; BIOS_call_14h  - Serial port communication services
   621                                  ;========================================================================
   622                                  BIOS_call_14h:
   623                                  %if TRACE
   624                                  	call	int_trace
   625                                  %endif	; TRACE
   626                                  	xor	ax,ax
   627                                  	iret
   628                                  
   629                                  ;========================================================================
   630                                  ; BIOS_call_17h  - Print services
   631                                  ;========================================================================
   632                                  BIOS_call_17h:
   633                                  %if TRACE
   634                                  	call	int_trace
   635                                  %endif	; TRACE
   636                                  	mov	ah,0
   637                                  	iret
   638                                  
   639                                  %endif
   640                                  ;========================================================================
   641                                  
   642                                  interrupt_table:
   643                                  
   644                                  %if SOFT_DEBUG
   645                                  	db	0			; Int 0 - divide by zero
   646                                  	extern	zero_divide
   647                                  	dw	zero_divide
   648                                  
   649                                  	db	1			; Int 1 - single step
   650                                  	extern	single_step
   651                                  	dw	single_step
   652                                  
   653                                  	db	2			; Int 2 - NMI interrupt
   654                                  	extern	nmi_interrupt
   655                                  	dw	nmi_interrupt
   656                                  
   657                                  	db	3			; Int 3 - breakpoint
   658                                  	extern	breakpoint
   659                                  	dw	breakpoint
   660                                  
   661                                  	db	4			; Int 4 - interrupt on overflow (INTO instruction)
   662                                  	extern	INTO_trap
   663                                  	dw	INTO_trap
   664                                  
   665                                  	db	5			; Int 5 - bound check error
   666                                  	extern	bound_trap
   667                                  	dw	bound_trap
   668                                  
   669                                  	db	6			; Int 6 - invalid opcode
   670                                  	extern	undefined_op
   671                                  	dw	undefined_op
   672                                  %endif	; SOFT_DEBUG
   673                                  
   674                                  %if FPEM
   675                                  %if 0
   676                                  	db	7			; ESC opcode / Floating Point
   677                                  	extern	vector7
   678                                  	dw	vector7
   679                                  %endif
   680                                  %else
   681                                  %if SOFT_DEBUG
   682                                  	db	7			; Int 7 - math coprocessor not present
   683                                  	dw	undefined_op
   684                                  %endif	; SOFT_DEBUG
   685                                  %endif
   686                                  
   687 00000203 08                      	db	8			; Timer 0 interrupt
   688                                  	extern	timer0_interrupt
   689 00000204 [0000]                  	dw	timer0_interrupt
   690                                  
   691 00000206 0A                      	db	0Ah			; DMA 0 interrupt
   692                                  	extern	dma0_interrupt
   693 00000207 [0000]                  	dw	dma0_interrupt
   694                                  
   695 00000209 0B                      	db	0Bh			; DMA 1 interrupt
   696 0000020A [3C02]                  	dw	end_of_interrupt
   697                                  
   698 0000020C 0C                      	db	0Ch			; INT0 - UART
   699                                  ; eventually this will be PIC code here
   700                                  %if UART
   701                                  	extern	uart_int
   702 0000020D [0000]                  	dw	uart_int
   703                                  %else
   704                                  	dw	end_of_interrupt
   705                                  %endif
   706                                  
   707 0000020F 0D                      	db	0Dh			; INT1- external bus INT
   708 00000210 [3C02]                  	dw	end_of_interrupt
   709 00000212 0F                      	db	0Fh
   710                                  	extern	fdc_interrupt_level
   711 00000213 [0000]                  	dw	fdc_interrupt_level	; INT3 - FDC
   712                                  
   713 00000215 10                      	db	10h			; BIOS - Video display services
   714                                  	extern	BIOS_call_10h
   715 00000216 [0000]                  	dw	BIOS_call_10h
   716                                  
   717 00000218 11                      	db	11h			; BIOS - Return equipment list
   718 00000219 [CB03]                  	dw	BIOS_call_11h		; in memory.asm
   719                                  
   720 0000021B 12                      	db	12h			; BIOS - Return conventional memory size
   721 0000021C [D503]                  	dw	BIOS_call_12h		; (shared with Timer 1)
   722                                  ;;;	dw	timer1_interrupt	; non INT 12h passed to timer1
   723                                  
   724 0000021E 13                      	db	13h			; BIOS - Disk services
   725                                  %if PPIDE_driver
   726                                  	extern	FIXED_BIOS_call_13h
   727 0000021F [0000]                  	dw	FIXED_BIOS_call_13h     ; (shared with Timer 2, prescaler, NOT USED)
   728                                  
   729 00000221 40                              db      40h                     ; Floppy Driver
   730                                  %endif
   731                                  	extern	BIOS_call_13h
   732 00000222 [0000]                          dw      BIOS_call_13h
   733                                  
   734 00000224 14                      	db	14h			; BIOS - Serial port communication
   735                                  	extern	BIOS_call_14h
   736 00000225 [0000]                  	dw	BIOS_call_14h
   737                                  
   738 00000227 15                      	db	15h			; BIOS - Miscellaneous system services support routines
   739                                  	extern	BIOS_call_15h
   740 00000228 [0000]                  	dw	BIOS_call_15h
   741                                  
   742 0000022A 16                      	db	16h			; BIOS - Keyboard services
   743                                  	extern	BIOS_call_16h
   744 0000022B [0000]                  	dw	BIOS_call_16h
   745                                  
   746 0000022D 17                      	db	17h
   747                                  	extern	BIOS_call_17h
   748 0000022E [0000]                  	dw	BIOS_call_17h		; BIOS - Print services
   749                                  
   750                                  %if TBASIC==0
   751                                  	db	18h			; BIOS - Start ROM Basic
   752                                  	dw	BIOS_call_18h
   753                                  %endif
   754                                  
   755 00000230 19                      	db	19h			; BIOS - Boot the OS
   756 00000231 [4101]                  	dw	BIOS_call_19h
   757                                  
   758 00000233 1A                      	db	1Ah			; BIOS - RTC (real time clock) services
   759                                  	extern	BIOS_call_1Ah
   760 00000234 [0000]                  	dw	BIOS_call_1Ah
   761                                  
   762 00000236 1C                      	db	1Ch
   763                                  	extern	BIOS_call_1Ch
   764 00000237 [0000]                  	dw	BIOS_call_1Ch
   765                                  
   766 00000239 70                      	db	70h			; RTC timer tick on IRQ8
   767                                  	extern	rtc_interrupt
   768 0000023A [0000]                  	dw	rtc_interrupt		; 1024 Hz timer
   769                                  
   770                                  num_vectors	equ     (($-interrupt_table)/3)
   771                                  
   772                                  ;========================================================================
   773                                  ; end_of_interrupt - signal end of interrupt to the interrupt controller
   774                                  ;========================================================================
   775                                  end_of_interrupt:
   776 0000023C 5250                            pushm   ax,dx
   777 0000023E BA22FF                          mov     dx,PIC_EOI              ; EOI register
   778 00000241 B80080                          mov     ax,EOI_NSPEC            ; non-specific end of interrupt
   779 00000244 EF                              out     dx,ax                   ; signal it
   780 00000245 585A                            popm    ax,dx
   781 00000247 CF                      	iret
   782                                  
   783                                  skip_trap:
   784                                  %if TRACE
   785                                  	call	int_trace
   786                                  %endif	; TRACE
   787 00000248 CF                              iret            ; return from interrupt is a null trap
   788                                  
   789                                  
   790                                  ;========================================================================
   791                                  ;  Interrupt priority re-assignments
   792                                  ;========================================================================
   793                                  MASK		equ	08h	; mask interrupt
   794                                  LTM		equ	10h	; Level Trigger Mode
   795                                  interrupt_priority:
   796 00000249 0E                      	db	6 | MASK	; Timers -- timer_init clears the mask
   797 0000024A 02                      	db	2		; DMA0
   798 0000024B 0A                      	db	2 | MASK	; DMA1
   799 0000024C 0C                      	db	4 | MASK	; INT0 -- external /INT (keyboard)
   800 0000024D 04                      	db	4		; INT1 -- UART
   801 0000024E 0F                      	db	7 | MASK	; INT2
   802 0000024F 1B                      	db	3 | LTM+MASK	; INT3 -- floppy disk
   803                                  lth_int_priority   equ	$-interrupt_priority
   804                                  
   805                                  set_interrupt_priority:
   806                                  %if 0
   807                                  /* for now */
   808                                  	mov	dx,PIC_TCR
   809                                  	mov	si,interrupt_priority
   810                                  	xor	ax,ax		; zap AH
   811                                  	mov	cx,lth_int_priority
   812                                  sip_loop:
   813                                     cs	lodsb			; get priority level
   814                                     	out	dx,ax
   815                                  	add	dx,2		; PIC control regs are even
   816                                  	loop	sip_loop
   817                                  %endif
   818 00000250 C3                      	ret
   819                                  
   820                                  ;========================================================================
   821                                  ; set_traps - setup interrupt table
   822                                  ;========================================================================
   823                                  set_traps:
   824 00000251 1E                              push    ds
   825                                  
   826 00000252 8CCA                    	mov	dx,cs
   827 00000254 B90001                  	mov	cx,0100h	; number of interrupt vectors
   828 00000257 B300                    	mov	bl,0		; start with int 0
   829 00000259 B8[4802]                	mov	ax,skip_trap
   830                                  .set_default_loop:
   831 0000025C E83E00                  	call	set_vector
   832 0000025F FEC3                    	inc	bl
   833 00000261 E2F9                    	loop	.set_default_loop
   834                                  
   835 00000263 8EDA                            mov     ds,dx           ; for LODS  CS==DX==DS
   836                                          cnop
   837 00000265 BE[0302]                        mov     si,interrupt_table	; load address to start
   838 00000268 B91300                  	mov	cx,num_vectors
   839                                  				; note DX = CS
   840                                  .set_vectors_loop:
   841 0000026B AC                      	lodsb
   842 0000026C 88C3                    	mov	bl,al
   843 0000026E AD                      	lodsw
   844 0000026F E82B00                  	call	set_vector
   845 00000272 E2F7                    	loop	.set_vectors_loop
   846                                  
   847                                  %if TBASIC
   848 00000274 B318                    	mov	bl,18h		; int 18h is Tiny Basic
   849 00000276 31C0                    	xor	ax,ax
   850 00000278 BA00F0                  	mov	dx,0F000h	; absolute segment load @ 00K
   851 0000027B E81F00                  	call	set_vector
   852                                  %endif
   853                                  %if FPEM
   854 0000027E B307                    	mov	bl,07h		; vector 7 is FPU emulator
   855 00000280 31C0                    	xor	ax,ax
   856 00000282 BA80F4                  	mov	dx,0F480h	; absolute segment load @ 18K
   857 00000285 E81500                  	call	set_vector
   858                                  %endif
   859                                  
   860 00000288 1F                              popm     ds
   861 00000289 C3                              ret
   862                                  
   863                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   864                                  ;  get_vector
   865                                  ;       Get an interrupt vector
   866                                  ;
   867                                  ;       Enter with vector number in BL
   868                                  ;       Exit with vector in DX:AX
   869                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   870                                          global  get_vector
   871                                  get_vector:
   872 0000028A 1E53                            pushm   bx,ds		; register saves
   873                                  
   874 0000028C 31C0                            xor     ax,ax           ; zero BX
   875 0000028E 8ED8                            mov     ds,ax           ; set DS=0
   876                                          cnop
   877 00000290 B700                    	mov	bh,0
   878 00000292 C1E302                          shl     bx,2            ; index * 4
   879                                  
   880 00000295 8B07                            mov     ax,[bx]         ; load the vector
   881 00000297 8B5702                          mov     dx,[bx+2]       ;
   882                                  
   883 0000029A 5B1F                            popm    bx,ds		; register restores
   884 0000029C C3                              ret                     ; result in DX:AX
   885                                  
   886                                  
   887                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   888                                  ;  set_vector
   889                                  ;       Set an interrupt vector
   890                                  ;
   891                                  ;       Enter with vector number in BL
   892                                  ;               vector in DX:AX
   893                                  ;
   894                                  ;       All registers preserved
   895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   896                                          global  set_vector
   897                                  set_vector:
   898 0000029D 1E5351                          pushm   cx,bx,ds	; register saves
   899                                  
   900 000002A0 31C9                    	xor	cx,cx
   901 000002A2 8ED9                            mov     ds,cx           ; set DS=0
   902                                          cnop
   903 000002A4 B700                    	mov	bh,0
   904 000002A6 C1E302                          shl     bx,2            ; index * 4
   905                                  
   906 000002A9 8907                            mov     [bx],ax         ; set offset
   907 000002AB 895702                          mov     [bx+2],dx       ; set segment
   908                                  
   909 000002AE 595B1F                          popm    cx,bx,ds	; register restores
   910 000002B1 C3                              ret                     ; return
   911                                  
   912                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   913                                  ;  cpu_table_init
   914                                  ;
   915                                  ;       call    cpu_table_init
   916                                  ;       dw      <table>         ; table in the Code segment
   917                                  ;       <return here>
   918                                  ;               AX, CX, DX are trashed
   919                                  ;
   920                                  ;
   921                                  ; table:
   922                                  ;       db_lo   <cpu_register>
   923                                  ;       dw      <contents>
   924                                  ;       ...
   925                                  ;       db      0       ; ends table
   926                                  ;
   927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   928                                          global  cpu_table_init
   929                                  cpu_table_init:
   930                                  ; get the table address
   931 000002B2 89F1                            mov     cx,si           ; save SI
   932 000002B4 5E                              pop     si              ; get the return address
   933 000002B5 2EAD                        cs  lodsw                   ; get the table address
   934 000002B7 56                              push    si              ; save incremented return address
   935 000002B8 51                              push    cx              ; save former SI
   936                                  
   937 000002B9 89C6                            mov     si,ax           ; CS:SI is table pointer
   938 000002BB B6FF                            mov     dh,cpu_relocation>>8
   939                                  .1:
   940 000002BD 2EAC                        cs  lodsb                   ; get low device code
   941 000002BF 84C0                            test    al,al
   942 000002C1 7407                            jz      .9              ; done with table on zero low device code
   943 000002C3 88C2                            mov     dl,al
   944 000002C5 2EAD                        cs  lodsw                   ; get cpu register data
   945 000002C7 EF                              out     dx,ax           ; output a full word
   946 000002C8 EBF3                            jmp     .1
   947                                  .9:
   948 000002CA 5E                              pop     si              ; restore SI
   949 000002CB C3                              ret                     ;
   950                                  
   951                                  
   952                                  %if 1
   953                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   954                                  ;  C-callable:
   955                                  ;       dword __fastcall divLS(dword dividend, word divisor);
   956                                  ;
   957                                  ;       double word  divided by  word
   958                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   959                                          global  @divLS
   960                                  @divLS:
   961                                          ; DX:AX is dividend
   962                                          ; BX is divisor
   963 000002CC 09D2                            or      dx,dx
   964 000002CE 7505                            jnz     .3
   965 000002D0 F7F3                            div     bx
   966 000002D2 31D2                            xor     dx,dx
   967 000002D4 C3                              ret
   968                                  
   969 000002D5 89C1                    .3:     mov     cx,ax           ; save low dividend in CX
   970 000002D7 89D0                            mov     ax,dx
   971 000002D9 31D2                            xor     dx,dx           ; 0:DX div BX
   972 000002DB F7F3                            div     bx
   973 000002DD 91                              xchg    cx,ax           ; CX is high quotient
   974 000002DE F7F3                            div     bx
   975 000002E0 89CA                            mov     dx,cx
   976 000002E2 C3                              ret
   977                                  
   978                                  %ifndef HAS_FASTCALL
   979                                          global  _divLS
   980                                  _divLS: push    bp
   981                                          mov     bp,sp
   982                                          mov     ax,ARG(1)
   983                                          mov     dx,ARG(2)
   984                                          mov     bx,ARG(3)
   985                                          call    @divLS
   986                                          leave
   987                                          ret
   988                                  
   989                                          global  _remLS
   990                                  _remLS: push    bp
   991                                          mov     bp,sp
   992                                          mov     ax,ARG(1)
   993                                          mov     dx,ARG(2)
   994                                          mov     bx,ARG(3)
   995                                          call    @remLS
   996                                          leave
   997                                          ret
   998                                  %endif
   999                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1000                                  ;  C-callable:
  1001                                  ;       word __fastcall remLS(dword dividend, word divisor);
  1002                                  ;
  1003                                  ;       remainder of:
  1004                                  ;       double word  divided by  word
  1005                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1006                                          global  @remLS
  1007                                  @remLS:
  1008                                          ; DX:AX is dividend
  1009                                          ; BX is divisor
  1010 000002E3 09D2                            or      dx,dx
  1011 000002E5 740A                            jz      .5
  1012 000002E7 89C1                            mov     cx,ax           ; save low dividend in CX
  1013 000002E9 89D0                            mov     ax,dx
  1014 000002EB 31D2                            xor     dx,dx           ; 0:DX div BX
  1015 000002ED F7F3                            div     bx              ; discard quotient in AX
  1016 000002EF 89C8                            mov     ax,cx           ; restore low dividend
  1017 000002F1 F7F3                    .5:     div     bx
  1018 000002F3 89D0                            mov     ax,dx           ; remainder to AX
  1019 000002F5 C3                              ret
  1020                                  
  1021                                  
  1022                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1023                                  ;  C-callable:
  1024                                  ;       dword __fastcall mulLS(dword factor1, word factor2);
  1025                                  ;
  1026                                  ;       double word  multiplied by  word
  1027                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1028                                  	global	@mulLS
  1029                                  @mulLS:
  1030                                  	; DX:AX is factor1
  1031                                  	; BX is factor2
  1032 000002F6 09D2                            or      dx,dx
  1033 000002F8 7503                            jnz     .1		; dx != 0
  1034 000002FA F7E3                            mul     bx
  1035 000002FC C3                              ret
  1036 000002FD 89C1                    .1:     mov     cx,ax           ; save low part of factor1 in CX
  1037 000002FF 89D0                            mov     ax,dx
  1038 00000301 F7E3                            mul     bx
  1039 00000303 91                              xchg    cx,ax           ; CX is a product of high part of factor1 and factor2
  1040 00000304 F7E3                            mul	bx
  1041 00000306 01CA                            add     dx,cx
  1042 00000308 C3                              ret
  1043                                  %endif
  1044                                  
  1045                                  
  1046                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1047                                  ;  microsecond
  1048                                  ;       Enter with CX = delay time in microseconds
  1049                                  ;       Exit with CX = 0
  1050                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1051                                          global  @microsecond
  1052                                          global  microsecond
  1053                                  @microsecond:		; C-callable with __fastcall
  1054 00000309 89C1                    	mov	cx,ax
  1055                                  microsecond:
  1056 0000030B E303                            jcxz    .9
  1057 0000030D 90                      .1:     nop		; 4 clocks
  1058 0000030E E2FD                            loop    .1	; 15 clocks	loop is 19 clocks (approx.)
  1059 00000310 C3                      .9:     ret
  1060                                  
  1061                                  
  1062                                  %if 0
  1063                                  ;========================================================================
  1064                                  ; wout - nobody calls it, but unasm defines it as an extenal symbol
  1065                                  ; XXX: Need to recompile unasm and kill it
  1066                                  ;========================================================================
  1067                                  	global	wout
  1068                                  wout:
  1069                                  	ret
  1070                                  %endif
  1071                                  
  1072                                  
  1073                                  %macro  binary  1
  1074                                          mov     ah,%1
  1075                                          shr     ax,4
  1076                                          shr     al,4
  1077                                          aad
  1078                                          mov     %1,al
  1079                                  %endm
  1080                                  
  1081                                  
  1082                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1083                                  ;  ticktime -- set the tick count from the CMOS clock
  1084                                  ;
  1085                                  ;       Preserves all registers
  1086                                  ;
  1087                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1088                                          global  ticktime
  1089                                  ticktime:
  1090 00000311 60                              pushm   ALL
  1091                                  
  1092 00000312 B402                            mov     ah,2            ; get Time
  1093 00000314 CD1A                            int     1Ah
  1094                                  
  1095                                          binary  dh
  1074 00000316 88F4                <1>  mov ah,%1
  1075 00000318 C1E804              <1>  shr ax,4
  1076 0000031B C0E804              <1>  shr al,4
  1077 0000031E D50A                <1>  aad
  1078 00000320 88C6                <1>  mov %1,al
  1096                                          binary  cl
  1074 00000322 88CC                <1>  mov ah,%1
  1075 00000324 C1E804              <1>  shr ax,4
  1076 00000327 C0E804              <1>  shr al,4
  1077 0000032A D50A                <1>  aad
  1078 0000032C 88C1                <1>  mov %1,al
  1097                                          binary  ch
  1074 0000032E 88EC                <1>  mov ah,%1
  1075 00000330 C1E804              <1>  shr ax,4
  1076 00000333 C0E804              <1>  shr al,4
  1077 00000336 D50A                <1>  aad
  1078 00000338 88C5                <1>  mov %1,al
  1098                                  ;       mov     al,ch
  1099 0000033A 88E5                            mov     ch,ah           ; CH = 0
  1100 0000033C B23C                            mov     dl,60           ; 60 min / hr,  60 sec / min
  1101 0000033E F6E2                            mul     dl
  1102 00000340 01C8                            add     ax,cx           ; AX = hr*60 + min
  1103 00000342 88F1                            mov     cl,dh           ; CX = sec
  1104 00000344 88EE                            mov     dh,ch           ; DH = 0
  1105 00000346 F7E2                            mul     dx              ;
  1106 00000348 01C8                            add     ax,cx
  1107 0000034A 83D200                          adc     dx,0            ; DX:AX = time in seconds
  1108                                  
  1109 0000034D BBFA00                          mov     bx,250
  1110 00000350 89D1                            mov     cx,dx           ; CX:AX is time in seconds
  1111 00000352 F7E3                            mul     bx
  1112 00000354 91                              xchg    ax,cx           ; CX is low result
  1113 00000355 F6E3                            mul     bl
  1114 00000357 01D0                            add     ax,dx           ; AX:CX is 250*maxseconds
  1115                                  
  1116 00000359 C1E302                          shl     bx,2            ; BX = 1000
  1117 0000035C 91                              xchg    ax,cx           ; CX:AX is 250*maxseconds
  1118 0000035D F7E3                            mul     bx              ; DX:AX is partial product
  1119 0000035F 91                              xchg    ax,cx
  1120 00000360 87D3                            xchg    dx,bx           ; BX:CX is partial product
  1121 00000362 F7E2                            mul     dx
  1122 00000364 01D8                            add     ax,bx
  1123 00000366 83D200                          adc     dx,0            ; DX:AX:CX is product
  1124                                  
  1125 00000369 BBA335                          mov     bx,54924/4      ; = 13731       (divisor)
  1126 0000036C F7F3                            div     bx
  1127 0000036E 91                              xchg    ax,cx           ; CX is high quotient
  1128 0000036F F7F3                            div     bx              ; CX:AX is quotient, DX is remainder
  1129                                  ; round the result
  1130 00000371 29D3                            sub     bx,dx           ; if DX > BX/2
  1131 00000373 39D3                            cmp     bx,dx           ;
  1132 00000375 7706                            ja      .3
  1133 00000377 83C001                          add     ax,1
  1134 0000037A 83D100                          adc     cx,0
  1135                                  .3:
  1136 0000037D 92                              xchg    ax,dx           ; CX:DX is tick count to set
  1137 0000037E B401                            mov     ah,1
  1138 00000380 CD1A                            int     1Ah             ; set tick count
  1139                                  
  1140 00000382 61                              popm    ALL
  1141 00000383 C3                              ret
  1142                                  
  1143                                  
  1144                                  
  1145                                  
  1146                                  ;========================================================================
  1147                                  
  1148                                  %include        "memory.asm"
  1149                              <1> ;========================================================================
  1150                              <1> ; MEMORY.ASM -- Memory management routines
  1151                              <1> ;========================================================================
  1152                              <1> ;
  1153                              <1> ;   This version is for assembly by  NASM
  1154                              <1> ;
  1155                              <1> ; Copyright (C) 2011   John R. Coffman
  1156                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1157                              <1> ;
  1158                              <1> ; This program is free software: you can redistribute it and/or modify
  1159                              <1> ; it under the terms of the GNU General Public License as published by
  1160                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1161                              <1> ; (at your option) any later version.
  1162                              <1> ;
  1163                              <1> ; This program is distributed in the hope that it will be useful,
  1164                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1165                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1166                              <1> ; GNU General Public License for more details.
  1167                              <1> ;
  1168                              <1> ; You should have received a copy of the GNU General Public License
  1169                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1170                              <1> ;
  1171                              <1> ;========================================================================
  1172                              <1> 
  1173                              <1>         segment         _TEXT
  1174                              <1> 
  1175                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1176                              <1> ;  get_ramsize
  1177                              <1> ;
  1178                              <1> ;       Return the number of 1k blocks of RAM in AX
  1179                              <1> ;
  1180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1181                              <1> get_ramsize:
  1182 00000384 1E                  <1>         push    ds
  1183 00000385 53                  <1>         push    bx
  1184 00000386 51                  <1>         push    cx
  1185 00000387 31C0                <1>         xor     ax,ax           ; count of 1k intervals
  1186 00000389 89C3                <1>         mov     bx,ax           ; segment address
  1187                              <1> .1:
  1188 0000038B 8EDB                <1>         mov     ds,bx           ; set pointer
  1189                              <1>         cnop
  1190 0000038D 8B0E0000            <1>         mov     cx,word [0]     ; save contents
  1191 00000391 C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
  1192 00000397 89DB                <1>         mov     bx,bx
  1193 00000399 89C0                <1>         mov     ax,ax           ; waste time
  1194 0000039B 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
  1195 000003A1 7524                <1>         jne     .9
  1196 000003A3 890E0000            <1>         mov     word [0],cx     ; restore
  1197 000003A7 8B0EFC03            <1>         mov     cx,word [1020]
  1198 000003AB C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
  1199 000003B1 89C0                <1>         mov     ax,ax
  1200 000003B3 89DB                <1>         mov     bx,bx
  1201 000003B5 813EFC03325A        <1>         cmp     word [1020],05a32h
  1202 000003BB 750A                <1>         jne     .9
  1203 000003BD 890EFC03            <1>         mov     word [1020],cx  ; restore
  1204                              <1> 
  1205                              <1> ; Memory test succeeded at the address
  1206                              <1> 
  1207 000003C1 40                  <1>         inc     ax              ; count 1k
  1208 000003C2 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
  1209 000003C5 EBC4                <1>         jmp     .1
  1210                              <1> 
  1211                              <1> .9:
  1212 000003C7 59                  <1>         pop     cx
  1213 000003C8 5B                  <1>         pop     bx
  1214 000003C9 1F                  <1>         pop     ds
  1215 000003CA C3                  <1>         ret
  1216                              <1> 
  1217                              <1> 
  1218                              <1> 
  1219                              <1> 
  1220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1221                              <1> ;  BIOS_call_11h
  1222                              <1> ;
  1223                              <1> ;       Get Equipment Configuration
  1224                              <1> ;
  1225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1226                              <1> BIOS_call_11h:
  1227 000003CB FB                  <1>         sti
  1228 000003CC 1E                  <1>         push    ds
  1229 000003CD 6A40                <1>         push    bios_data_seg
  1230 000003CF 1F                  <1>         pop     ds
  1231 000003D0 A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
  1232 000003D3 1F                  <1>         pop     ds
  1233 000003D4 CF                  <1>         iret
  1234                              <1> 
  1235                              <1> 
  1236                              <1> 
  1237                              <1> 
  1238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1239                              <1> ;  BIOS_call_12h
  1240                              <1> ;
  1241                              <1> ;       Get Conventional Memory Size
  1242                              <1> ;
  1243                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
  1244                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
  1245                              <1> ;       we assume this was a Timer 1 interrupt.
  1246                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1247                              <1> ; stack
  1248                              <1> offset_SI	equ	0
  1249                              <1> offset_DS	equ	offset_SI+2
  1250                              <1> offset_IP       equ     offset_DS+2
  1251                              <1> offset_CS       equ     offset_IP+2
  1252                              <1> offset_FLAGS    equ     offset_CS+2
  1253                              <1> 
  1254                              <1> BIOS_call_12h:
  1255 000003D5 1E                  <1>         push    ds
  1256 000003D6 56                  <1>         push    si
  1257 000003D7 89E6                <1>         mov     si,sp           ; establish stack addressing
  1258 000003D9 36C57404            <1>    ss   lds     si,[offset_IP+si]
  1259                              <1>         cnop
  1260 000003DD 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
  1261 000003E2 5E                  <1>         pop     si
  1262 000003E3 7404                <1>         je      .4
  1263 000003E5 1F                  <1>         popm	ds
  1264                              <1> ; since the segment is already correct...
  1265                              <1> 	extern	timer1_interrupt
  1266 000003E6 E9(0000)            <1> 	jmp	timer1_interrupt
  1267                              <1> 
  1268 000003E9 6A40                <1> .4:     push    bios_data_seg
  1269 000003EB 1F                  <1>         pop     ds
  1270 000003EC A11300              <1>         mov     ax,[memory_size]
  1271 000003EF 1F                  <1>         pop     ds
  1272 000003F0 CF                  <1>         iret
  1273                              <1> 
  1274                              <1> 
  1275                              <1> 
  1276                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1277                              <1> ;  Memory Test
  1278                              <1> ;       Enter with segment to test in AX
  1279                              <1> ;
  1280                              <1> ;       Return: C=1 if error, (DI==loc)
  1281                              <1> ;               C=0 if no error
  1282                              <1> ;
  1283                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
  1284                              <1> ;       DS, BX & SI are preserved
  1285                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1286                              <1> memtest:
  1287 000003F1 5D                  <1>         pop     bp              ; save return address in BP
  1288                              <1> memtest0:                       ; entry to test page 0
  1289 000003F2 FC                  <1>         cld                     ; clear the direction flag
  1290 000003F3 8EC0                <1>         mov     es,ax           ; set segment
  1291 000003F5 31FF                <1>         xor     di,di
  1292 000003F7 B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
  1293 000003FA B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
  1294 000003FD F3AB                <1>         rep stosw               ;
  1295 000003FF B580                <1>         mov     ch,80h          ; 32K count of words
  1296 00000401 F3AF                <1>         repe scasw
  1297 00000403 754F                <1>         jne     .3
  1298                              <1> 
  1299 00000405 86C4                <1>         xchg    al,ah           ; second pattern
  1300 00000407 B580                <1>         mov     ch,80h          ; 32K count of words
  1301 00000409 F3AB                <1>         rep stosw
  1302 0000040B B580                <1>         mov     ch,80h          ; 32K count of words
  1303 0000040D F3AF                <1>         repe scasw
  1304 0000040F 7543                <1>         jne     .3
  1305                              <1> %if 1
  1306                              <1> seed1   equ     47F8h           ; NOT a random value
  1307                              <1>                                 ; Seed values are chosen to have a relatively
  1308                              <1>                                 ; prime cycle length, and to never produce a zero
  1309                              <1>                                 ; Most random values will produce a zero!!!!
  1310                              <1> 
  1311 00000411 B8F847              <1>         mov     ax,seed1        ; seed value (critical)
  1312                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
  1313 00000414 B580                <1>         mov     ch,80h          ; 32K words
  1314                              <1> .t1:
  1315 00000416 268905              <1>     es  mov     [di],ax         ; store the value
  1316 00000419 F7E0                <1>         mul     ax
  1317 0000041B 47                  <1>         inc     di
  1318 0000041C 88E0                <1>         mov     al,ah           ; generate the next bit pattern
  1319 0000041E 47                  <1>         inc     di
  1320 0000041F 88D4                <1>         mov     ah,dl
  1321                              <1> %if 0
  1322                              <1> .t102:  or      ax,ax           ; trap a bad seed value
  1323                              <1>         jz      .t102
  1324                              <1> %endif
  1325 00000421 E2F3                <1>         loop    .t1             ; fill memory with the pattern
  1326                              <1> 
  1327 00000423 B8F847              <1>         mov     ax,seed1
  1328 00000426 B580                <1>         mov     ch,80h          ; 32K words
  1329                              <1> .t11:
  1330 00000428 263B05              <1>     es  cmp     ax,[di]
  1331 0000042B 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
  1332 0000042E 7524                <1>         jne     .3
  1333 00000430 F7E0                <1>         mul     ax
  1334 00000432 88E0                <1>         mov     al,ah
  1335 00000434 88D4                <1>         mov     ah,dl
  1336 00000436 E2F0                <1>         loop    .t11
  1337                              <1> 
  1338                              <1> %endif
  1339 00000438 B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
  1340 0000043B B580                <1>         mov     ch,80h          ; 32K count of words
  1341 0000043D F3AB                <1>         rep stosw
  1342 0000043F B580                <1>         mov     ch,80h          ; 32K count of words
  1343 00000441 F3AF                <1>         repe scasw
  1344 00000443 750F                <1>         jne     .3
  1345                              <1> 
  1346 00000445 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
  1347 00000447 B580                <1>         mov     ch,80h          ; 32K count of words
  1348 00000449 F3AB                <1>         rep stosw
  1349 0000044B B580                <1>         mov     ch,80h          ; 32K count of words
  1350 0000044D F3AF                <1>         repe scasw
  1351 0000044F 7503                <1>         jne     .3
  1352                              <1> 
  1353 00000451 F8                  <1>         clc                     ; no error
  1354 00000452 FFE5                <1>         jmp     bp
  1355                              <1> 
  1356                              <1> .3: ; ERROR in scan string
  1357 00000454 4F                  <1>         dec     di
  1358 00000455 263A25              <1>    es   cmp     ah,[di]
  1359 00000458 7401                <1>         je      .4
  1360 0000045A 4F                  <1>         dec     di
  1361                              <1> .4:
  1362 0000045B F9                  <1>         stc
  1363 0000045C FFE5                <1>         jmp     bp
  1364                              <1> 
  1365                              <1> 
  1366                              <1> 
  1367                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1368                              <1> ; POST_memory -- Power On Self Test of Memory
  1369                              <1> ;
  1370                              <1> ;
  1371                              <1> ;  Enter with:
  1372                              <1> ;       AX = memory limit in kilobytes
  1373                              <1> ;	DS = DGROUP
  1374                              <1> ;	SS = bios_data_seg
  1375                              <1> ;
  1376                              <1> ;  Watch out, "memtest" clobbers segment registers
  1377                              <1> ;
  1378                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1379                              <1> POST_memory:
  1380 0000045E 0660                <1>         pushm   ALL,es	; ,ds
  1381 00000460 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
  1382 00000467 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
  1383 0000046E 7507                <1>     	jne	.001
  1384 00000470 1E                  <1> 	push	ds
  1385 00000471 68[5000]            <1> 	push	msg_mem_bypass
  1386 00000474 E99800              <1> 	jmp	.print
  1387                              <1> .001:
  1388 00000477 C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
  1389 0000047A 89C3                <1>         mov     bx,ax                   ; save in BX
  1390                              <1> .1:
  1391 0000047C BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
  1392 0000047F 29D3                <1>         sub     bx,dx
  1393 00000481 7432                <1>         jz      .8                      ; done if down to zero
  1394 00000483 39D3                <1>         cmp     bx,dx
  1395 00000485 7302                <1>         jae     .2
  1396 00000487 89D3                <1>         mov     bx,dx
  1397                              <1> .2:
  1398 00000489 53                  <1>         push    bx
  1399                              <1> 
  1400 0000048A 53                  <1>         push    bx
  1401 0000048B 1E                  <1>         push    ds		;DGROUP
  1402 0000048C 68[0000]            <1>         push    msg_mem_test
  1403 0000048F E8(0000)            <1>         call    _cprintf
  1404 00000492 83C406              <1>         add     sp,6
  1405                              <1> 
  1406 00000495 5B                  <1>         pop     bx
  1407 00000496 89D8                <1>         mov     ax,bx                   ; AX is segment tested
  1408 00000498 E856FF              <1>         call    memtest
  1409                              <1> 
  1410                              <1> %if 0
  1411                              <1> ;  induce an error to see printout
  1412                              <1>         mov     di,3465h
  1413                              <1>         stc
  1414                              <1> %endif
  1415 0000049B 73DF                <1>         jnc     .1
  1416                              <1> ; make an error report
  1417                              <1> 
  1418 0000049D 89FA                <1>         mov     dx,di           ; copy byte address
  1419 0000049F C1EF04              <1>         shr     di,4            ; convert to paragraphs
  1420 000004A2 01DF                <1>         add     di,bx           ; DI is total paragraphs
  1421 000004A4 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
  1422 000004A7 52                  <1>         push    dx
  1423 000004A8 57                  <1>         push    di
  1424 000004A9 1E                  <1>         push    ds		; DGROUP
  1425 000004AA 68[7400]            <1>         push    msg_mem_error
  1426 000004AD E8(0000)            <1>         call    _cprintf
  1427 000004B0 83C408              <1>         add     sp,8
  1428                              <1> 
  1429 000004B3 EBC7                <1>         jmp     .1
  1430                              <1> 
  1431                              <1> .8:
  1432                              <1> %if SOFT_DEBUG==0
  1433                              <1> ; tested down to 1000:0000
  1434                              <1> ; now do the test at loc. 0  (watch out for the stack)
  1435 000004B5 53                  <1>         push    bx                      ; BX is zero
  1436 000004B6 1E                  <1>         push    ds		; DGROUP
  1437 000004B7 68[0000]            <1>         push    msg_mem_test
  1438 000004BA E8(0000)            <1>         call    _cprintf
  1439 000004BD 83C406              <1>         add     sp,6
  1440                              <1> 
  1441 000004C0 1E9C                <1>         pushm   f,ds
  1442 000004C2 FA                  <1>         cli                             ; disable interrupts
  1443                              <1> 
  1444 000004C3 6A00                <1>         push    0
  1445 000004C5 1F                  <1>         pop     ds                      ; source is 0000:xxxx
  1446 000004C6 680010              <1>         push    1000h
  1447 000004C9 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
  1448 000004CA 31F6                <1>         xor     si,si
  1449 000004CC 31FF                <1>         xor     di,di
  1450 000004CE B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1451 000004D1 F3A5                <1>         rep movsw
  1452                              <1> 
  1453 000004D3 31C0                <1>         xor     ax,ax
  1454 000004D5 BD[DB04]            <1>         mov     bp,.85
  1455 000004D8 E917FF              <1>         jmp     memtest0
  1456                              <1> .85:
  1457                              <1> %if 0
  1458                              <1>         stc
  1459                              <1>         mov     di,8765h                ; force error reporting
  1460                              <1> %endif
  1461 000004DB 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
  1462 000004DD 89FB                <1>         mov     bx,di                   ; save error location
  1463                              <1> 
  1464 000004DF 680010              <1>         push    1000h                   ; source is 1000:xxxx
  1465 000004E2 1F                  <1>         pop     ds
  1466 000004E3 6A00                <1>         push    0
  1467 000004E5 07                  <1>         pop     es                      ; restore 0000:xxxx
  1468 000004E6 31F6                <1>         xor     si,si
  1469 000004E8 31FF                <1>         xor     di,di
  1470 000004EA B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1471 000004ED F3A5                <1>         rep movsw
  1472                              <1> 
  1473 000004EF 1E                  <1>         push    ds
  1474 000004F0 07                  <1>         pop     es
  1475 000004F1 31C0                <1>         xor     ax,ax
  1476 000004F3 B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
  1477 000004F5 F3AB                <1>         rep stosw
  1478                              <1> 
  1479 000004F7 9D1F                <1>         popm    f,ds
  1480                              <1> %endif
  1481 000004F9 D1EA                <1>         shr     dx,1                    ; set the carry
  1482 000004FB 730E                <1>         jnc     .89
  1483                              <1> 
  1484                              <1> ; make the page 0 error report
  1485 000004FD 53                  <1>         push    bx
  1486 000004FE 1E                  <1>         push    ds			; DGROUP
  1487 000004FF 68[9200]            <1>         push    msg_mem_error0
  1488 00000502 E8(0000)            <1>         call    _cprintf
  1489 00000505 83C406              <1>         add     sp,6
  1490                              <1> 
  1491 00000508 F4                  <1> .88:    hlt
  1492 00000509 EBFD                <1>         jmp     .88
  1493                              <1> 
  1494                              <1> .89:
  1495 0000050B 1E                  <1>         push    ds			; DGROUP
  1496 0000050C 68[2000]            <1>         push    msg_mem_done
  1497                              <1> .print:
  1498 0000050F E8(0000)            <1>         call    _cprintf
  1499 00000512 83C404              <1>         add     sp,4
  1500                              <1> .9:
  1501 00000515 6107                <1>         popm    ALL,es ; ,ds
  1502 00000517 C3                  <1>         ret
  1503                              <1> 
  1504                              <1> 
  1505                              <1>         segment CONST
  1506                              <1> msg_mem_test:
  1507 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
  1507 00000009 6E67206D656D6F7279- <1>
  1507 00000012 206174202537612530- <1>
  1507 0000001B 34783A3000          <1>
  1508                              <1> msg_mem_done:
  1509 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
  1509 00000029 2E542E206F66206D65- <1>
  1509 00000032 6D6F72792025313061- <1>
  1509 0000003B 535543434553534655- <1>
  1509 00000044 4C2020202020202020  <1>
  1510                              <1> msg_mem_double:
  1511 0000004D 0A0A00              <1>         db      NL,NL,NUL
  1512                              <1> msg_mem_bypass:
  1513 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
  1513 00000059 2E542E206F66206D65- <1>
  1513 00000062 6D6F72792042595041- <1>
  1513 0000006B 5353454420200A0A00  <1>
  1514                              <1> msg_mem_error:
  1515 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
  1515 0000007D 6F7279206572726F72- <1>
  1515 00000086 206174202530347825- <1>
  1515 0000008F 780A00              <1>
  1516                              <1> msg_mem_error0:
  1517 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
  1517 0000009B 6F7279206572726F72- <1>
  1517 000000A4 206174203025303478- <1>
  1517 000000AD 0A0A                <1>
  1518 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
  1518 000000B8 2A2A2A2A2A2A2A2A2A- <1>
  1518 000000C1 2A2A2A2A2A2A2A2A0A  <1>
  1519 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
  1519 000000D3 415354524F50484521- <1>
  1519 000000DC 212120202020202A0A  <1>
  1520 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
  1520 000000EE 2A2A2A2A2A2A2A2A2A- <1>
  1520 000000F7 2A2A2A2A2A2A2A2A0A- <1>
  1520 00000100 0A                  <1>
  1521 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
  1521 0000010A 756520746F20657272- <1>
  1521 00000113 6F7220696E20736567- <1>
  1521 0000011C 6D656E742030303030- <1>
  1521 00000125 3A78787878070A      <1>
  1522 0000012C 00                  <1>         db      NUL
  1523 0000012D 00                  <1> 	db	0
  1149                                  %include        "ds1302.asm"
  1150                              <1> 	;========================================================================
  1151                              <1> 	; DS1302.ASM - - support on the SBC - 188 for the DS1302 chip
  1152                              <1> 	;========================================================================
  1153                              <1> 	;
  1154                              <1> 	; This version is for assembly by NASM 2.08
  1155                              <1> 	;
  1156                              <1> 	; Copyright (C) 2010 John R. Coffman
  1157                              <1> 	; Provided for hobbyist use on the N8VEM SBC - 188 board
  1158                              <1> 	;
  1159                              <1> 	; This program is free software: you can redistribute it and / or modify
  1160                              <1> 	; it under the terms of the GNU General Public License as published by
  1161                              <1> 	; the Free Software Foundation, either version 3 of the License, or
  1162                              <1> 	; (at your option) any later version.
  1163                              <1> 	;
  1164                              <1> 	; This program is distributed in the hope that it will be useful,
  1165                              <1> 	; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1166                              <1> 	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  1167                              <1> 	; GNU General Public License for more details.
  1168                              <1> 	;
  1169                              <1> 	; You should have received a copy of the GNU General Public License
  1170                              <1> 	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
  1171                              <1> 	;
  1172                              <1> 	; Updated for the Duodyne 80c188 SBC
  1173                              <1> 	;========================================================================
  1174                              <1> 
  1175                              <1> 	segment _TEXT
  1176                              <1> 
  1177                              <1> 	rtc_data equ 80H             ; Data mask bit
  1178                              <1> 	rtc_wren equ 20H             ; Write enable bit
  1179                              <1> 	rtc_clk equ 40H              ; Clock signal
  1180                              <1> 	rtc_ce equ 10H               ; ce bit
  1181                              <1> 
  1182                              <1> 
  1183                              <1> 	; global _rtc_reset
  1184                              <1> rtc_reset:
  1185 00000518 BA9404              <1> 	mov dx, RTC                  ; set the device code
  1186 0000051B B010                <1> 	mov al, rtc_ce               ;
  1187 0000051D EB05                <1> 	jmp rtc_out
  1188                              <1> 
  1189                              <1> 
  1190                              <1> 	global _rtc_reset_off
  1191                              <1> rtc_reset_off:
  1192 0000051F BA9404              <1> 	mov dx, RTC
  1193 00000522 B000                <1> 	mov al, 0                    ;
  1194                              <1> rtc_out:
  1195 00000524 EE                  <1> 	out dx, al
  1196 00000525 B91000              <1> 	mov cx, 16
  1197 00000528 E9E0FD              <1> 	jmp microsecond              ; delay 16 us
  1198                              <1> 
  1199                              <1> rtc_outs:
  1200 0000052B EE                  <1> 	out dx, al
  1201 0000052C B90100              <1> 	mov cx, 1
  1202 0000052F E9D9FD              <1> 	jmp microsecond              ; delay 16 us
  1203                              <1> 
  1204                              <1> 	; global @rtc_write
  1205                              <1> @rtc_write:
  1206                              <1> rtc_write:
  1207 00000532 53                  <1> 	push bx
  1208                              <1> 
  1209 00000533 BA9404              <1> 	mov dx, RTC
  1210 00000536 88C3                <1> 	mov bl, al                   ; save data in BL
  1211 00000538 B408                <1> 	mov ah, 8                    ; set loop count
  1212                              <1> .1:
  1213 0000053A D0EB                <1> 	shr bl, 1                    ; data bit to Carry
  1214 0000053C 7311                <1> 	jnc .2
  1215 0000053E B090                <1> 	mov al,  rtc_ce | rtc_data   ; send '1'
  1216 00000540 E8E8FF              <1> 	call rtc_outs                ; put out the data
  1217 00000543 B0D0                <1> 	mov al, rtc_clk | rtc_ce | rtc_data     ; send '1'
  1218 00000545 E8DCFF              <1> 	call rtc_out                 ; put out the data
  1219 00000548 B090                <1>        	mov al, rtc_ce | rtc_data     ; send '1'
  1220 0000054A E8D7FF              <1> 	call rtc_out                 ; put out the data
  1221                              <1> 
  1222 0000054D EB0F                <1> 	jmp .3
  1223                              <1> .2:
  1224 0000054F B010                <1> 	mov al, rtc_ce               ; send '0'
  1225 00000551 E8D7FF              <1> 	call rtc_outs                ; put out the data
  1226 00000554 B050                <1> 	mov al, rtc_clk |rtc_ce      ; send '0'
  1227 00000556 E8CBFF              <1> 	call rtc_out                 ; put out the data
  1228 00000559 B010                <1>       	mov al, rtc_ce               ; send '0'
  1229 0000055B E8C6FF              <1> 	call rtc_out                 ; put out the data
  1230                              <1> 
  1231                              <1> .3:
  1232 0000055E FECC                <1> 	dec ah                       ; count a bit
  1233 00000560 75D8                <1> 	jnz .1
  1234                              <1> 
  1235                              <1> 	; rtc_write ends with the clock high
  1236 00000562 5B                  <1> 	pop bx
  1237 00000563 C3                  <1> 	ret
  1238                              <1> 
  1239                              <1> 
  1240                              <1> 
  1241                              <1> 
  1242                              <1> rtc_read:
  1243 00000564 53                  <1> 	push bx
  1244                              <1> 
  1245 00000565 BA9404              <1> 	mov dx, RTC
  1246 00000568 B308                <1> 	mov bl, 8                    ; bit count
  1247                              <1> .1:
  1248 0000056A B030                <1> 	mov al, rtc_ce | rtc_wren
  1249 0000056C E8B5FF              <1> 	call rtc_out
  1250                              <1> 	; delay was included in the above output call
  1251 0000056F EC                  <1> 	in al, dx                    ; read a bit
  1252 00000570 D1C8                <1> 	ror ax, 1                    ; rotate data into AH
  1253 00000572 B070                <1> 	mov al, rtc_clk | rtc_ce | rtc_wren     ; set to clock next data bit
  1254 00000574 E8ADFF              <1> 	call rtc_out
  1255 00000577 FECB                <1> 	dec bl
  1256 00000579 75EF                <1> 	jnz .1
  1257                              <1> 
  1258 0000057B C1E808              <1> 	shr ax, 8                    ; return data in AL, AH=0
  1259                              <1> 
  1260 0000057E 5B                  <1> 	pop bx
  1261 0000057F C3                  <1> 	ret
  1262                              <1> 
  1263                              <1> 
  1264                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1265                              <1> 	; rtc_get_loc RTC get location as addressed
  1266                              <1> 	; Enter with AL = address of the location to get
  1267                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1268                              <1> 	; Exit with data in AL
  1269                              <1> 	; All other registers are preserved
  1270                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1271                              <1> 	global @rtc_get_loc
  1272                              <1> 	global rtc_get_loc
  1273                              <1> @rtc_get_loc:
  1274                              <1> rtc_get_loc:
  1275 00000580 52                  <1> 	push dx
  1276 00000581 51                  <1> 	push cx                      ; 3 register saves
  1277 00000582 53                  <1> 	push bx
  1278                              <1> 
  1279 00000583 08E4                <1> 	or ah, ah                    ; test flag
  1280 00000585 7402                <1> 	jz .1
  1281 00000587 B440                <1> 	mov ah, 040h                 ; RAM flag
  1282 00000589 88E7                <1> .1:     mov bh, ah                   ; save flag in BH
  1283 0000058B 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1284 0000058D 00C0                <1> 	add al, al                   ; shift left
  1285 0000058F 08C7                <1> 	or bh, al                    ; form command
  1286 00000591 80CF81              <1> 	or bh, 81h                   ; Clock Command / READ bit = 01h
  1287                              <1> 
  1288 00000594 BA9404              <1> 	mov dx, RTC
  1289 00000597 E885FF              <1> 	call rtc_reset_off
  1290 0000059A E87BFF              <1> 	call rtc_reset               ; signal that a command is coming
  1291 0000059D 88F8                <1> 	mov al, bh
  1292 0000059F E890FF              <1> 	call rtc_write               ; write out the command
  1293 000005A2 E8BFFF              <1> 	call rtc_read                ; read the data location
  1294 000005A5 50                  <1> 	push ax                      ; save the result
  1295 000005A6 E86FFF              <1> 	call rtc_reset
  1296 000005A9 E873FF              <1> 	call rtc_reset_off           ; and finish up
  1297                              <1> 
  1298 000005AC 58                  <1> 	pop ax                       ; return value
  1299                              <1> 
  1300 000005AD 5B                  <1> 	pop bx
  1301 000005AE 59                  <1> 	pop cx                       ; plus 3 register restores
  1302 000005AF 5A                  <1> 	pop dx
  1303 000005B0 C3                  <1> 	ret
  1304                              <1> 
  1305                              <1> 
  1306                              <1> 
  1307                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1308                              <1> 	; rtc_set_loc RTC set location as addressed
  1309                              <1> 	; Enter with AL = address of the location to set
  1310                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1311                              <1> 	; DL = data to write to location
  1312                              <1> 	; AX is undefined on return
  1313                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1314                              <1> 	global @rtc_set_loc
  1315                              <1> 	global rtc_set_loc
  1316                              <1> @rtc_set_loc:
  1317                              <1> rtc_set_loc:
  1318 000005B1 52                  <1> 	push dx
  1319 000005B2 51                  <1> 	push cx                      ; 3 register saves
  1320 000005B3 53                  <1> 	push bx
  1321                              <1> 
  1322 000005B4 52                  <1> 	push dx                      ; save data
  1323                              <1> 
  1324 000005B5 08E4                <1> 	or ah, ah                    ; test flag
  1325 000005B7 7402                <1> 	jz .1
  1326 000005B9 B440                <1> 	mov ah, 040h                 ; RAM flag
  1327 000005BB 88E7                <1> .1: mov bh, ah                ; save flag in BH
  1328 000005BD 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1329 000005BF 00C0                <1> 	add al, al                   ; shift left
  1330 000005C1 08C7                <1> 	or bh, al                    ; form command
  1331 000005C3 80CF80              <1> 	or bh, 80h                   ; Clock Command / WRITE bit = 00h
  1332                              <1> 
  1333 000005C6 BA9404              <1> 	mov dx, RTC
  1334 000005C9 E853FF              <1> 	call rtc_reset_off
  1335 000005CC E849FF              <1> 	call rtc_reset               ; signal that a command is coming
  1336 000005CF 88F8                <1> 	mov al, bh                   ; command to AL
  1337 000005D1 E85EFF              <1> 	call rtc_write               ; write out the command
  1338 000005D4 58                  <1> 	pop ax                       ; get the data value
  1339 000005D5 E85AFF              <1> 	call rtc_write               ; write the data
  1340 000005D8 E83DFF              <1> 	call rtc_reset               ; end of command
  1341 000005DB E841FF              <1> 	call rtc_reset_off
  1342                              <1> 
  1343 000005DE 5B                  <1> 	pop bx
  1344 000005DF 59                  <1> 	pop cx                       ; plus 3 register restores
  1345 000005E0 5A                  <1> 	pop dx
  1346 000005E1 C3                  <1> 	ret
  1150                                  
  1151                                  %if SOFT_DEBUG+1
  1152                                          global  lites
  1153                                  ; call with:
  1154                                  ;       push    code    ; code in AL
  1155                                  ;       call    lites
  1156                                  ;
  1157 000005E2 55                      lites:  push    bp
  1158 000005E3 89E5                            mov     bp,sp           ; establish stack frame
  1159 000005E5 5250                            pushm   ax,dx
  1160 000005E7 8A4604                          mov     al,[bp+4]
  1161 000005EA BA3006                          mov     dx,FRONT_PANEL_LED
  1162 000005ED EE                              out     dx,al
  1163 000005EE 585A                            popm    ax,dx
  1164 000005F0 5D                              pop     bp
  1165 000005F1 C20200                          ret     2               ; remove argument
  1166                                  %endif
  1167                                  
  1168                                  %if 0
  1169                                  ; _FPSIGNAL:
  1170                                  ;   Enter with AL = condensed error code
  1171                                  ;
  1172                                  	global	_FPSIGNAL
  1173                                  _FPSIGNAL:
  1174                                  	xor	ah,ah
  1175                                  	push	ax
  1176                                  	push	DGROUP
  1177                                  	push	msg_fpu_err
  1178                                  	call	_cprintf
  1179                                  	add	sp,6
  1180                                  	ret
  1181                                  %endif
  1182                                  
  1183                                  
  1184                                  
  1185                                  
  1186                                  ident3:
  1187                                  %if SOFT_DEBUG
  1188                                          db      NL
  1189                                  	db	"%7a"
  1190                                          db      "             ***** SOFT BIOS *****"
  1191                                          db      NL
  1192                                  %endif
  1193                                  %ifdef __DATE__
  1194                                  %ifdef __TIME__
  1195 000005F4 0A                              db      NL
  1196 000005F5 25313461                	db	"%14a"
  1197 000005F9 546869732042494F53-             db      "This BIOS copy was built at ",__TIME__," ",TIMEZONE
  1197 00000602 20636F707920776173-
  1197 0000060B 206275696C74206174-
  1197 00000614 2031363A31383A3336-
  1197 0000061D 20435354           
  1198 00000621 206F6E20323032342D-             db      " on ", __DATE__
  1198 0000062A 31312D3033         
  1199                                  %endif
  1200                                  %endif
  1201 0000062F 2E2020202020202020-             db      ".                    [%d]",NL
  1201 00000638 202020202020202020-
  1201 00000641 2020205B25645D0A   
  1202 00000649 00                              db      0
  1203                                  
  1204                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1205                                  ;  This is the banner which prints out first.
  1206                                  ;  The letters are variable width; B is wide; -, and 1 are kerned.
  1207                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1208                                  ident1:
  1209 0000064A 0A253961                        db      NL,"%9a"
  1210 0000064E 20205F5F5F5F5F2020-             DB      "  _____                  _ ",	NL
  1210 00000657 202020202020202020-
  1210 00000660 202020202020205F20-
  1210 00000669 0A                 
  1211 0000066A 207C20205F5F205C20-             DB      " |  __ \                | |",	NL
  1211 00000673 202020202020202020-
  1211 0000067C 2020202020207C207C-
  1211 00000685 0A                 
  1212 00000686 207C207C20207C207C-             DB      " | |  | |_   _  ___   __| |_   _ _ __   ___ ",	NL
  1212 0000068F 5F2020205F20205F5F-
  1212 00000698 5F2020205F5F7C207C-
  1212 000006A1 5F2020205F205F205F-
  1212 000006AA 5F2020205F5F5F200A 
  1213 000006B3 207C207C20207C207C-             DB      " | |  | | | | |/ _ \ / _` | | | | '_ \ / _ \ ",	NL
  1213 000006BC 207C207C207C2F205F-
  1213 000006C5 205C202F205F60207C-
  1213 000006CE 207C207C207C20275F-
  1213 000006D7 205C202F205F205C20-
  1213 000006E0 0A                 
  1214 000006E1 207C207C5F5F7C207C-             DB      " | |__| | |_| | (_) | (_| | |_| | | | |  __/",	NL
  1214 000006EA 207C5F7C207C20285F-
  1214 000006F3 29207C20285F7C207C-
  1214 000006FC 207C5F7C207C207C20-
  1214 00000705 7C207C20205F5F2F0A 
  1215 0000070E 207C5F5F5F5F5F2F20-             DB      " |_____/ \__,_|\___/ \__,_|\__, |_| |_|\___|",	NL
  1215 00000717 5C5F5F2C5F7C5C5F5F-
  1215 00000720 5F2F205C5F5F2C5F7C-
  1215 00000729 5C5F5F2C207C5F7C20-
  1215 00000732 7C5F7C5C5F5F5F7C0A 
  1216 0000073B 202020203830633138-             DB      "    80c188 pcb              __/ |  rev. ", VERSION, NL
  1216 00000744 382070636220202020-
  1216 0000074D 202020202020202020-
  1216 00000756 205F5F2F207C202072-
  1216 0000075F 65762E20332E352D44-
  1216 00000768 0A                 
  1217 00000769 202020202020202020-             DB      "                           |___/   of   ", DATE, NL
  1217 00000772 202020202020202020-
  1217 0000077B 202020202020202020-
  1217 00000784 7C5F5F5F2F2020206F-
  1217 0000078D 6620202032372D4F63-
  1217 00000796 742D323032340A     
  1218 0000079D 202020202020202020-             db      "                                   ("
  1218 000007A6 202020202020202020-
  1218 000007AF 202020202020202020-
  1218 000007B8 202020202020202028 
  1219                                  %if ANSI
  1220 000007C1 414E5349                        db      "ANSI"
  1221                                  %elif DUMB
  1222                                          db      "dumb"
  1223                                  %elif TTY
  1224                                          db      "tty"
  1225                                  %else
  1226                                          db      "???"
  1227                                  %endif
  1228 000007C5 290A                            db      ")",NL
  1229                                  
  1230 000007C7 00                      	db      0
  1231                                  
  1232                                  
  1233 000007C8 90<rep 8h>              	align	16
  1234                                  
  1235                                  bulk_of_code_end        equ     $
  1236                                  
  1237                                  
  1238                                  
  1239                                          segment CONST
  1240                                  
  1241                                          global  _bios_data_area_ptr
  1242                                  _bios_data_area_ptr:
  1243 0000012E 00004000                        dw      0000h,bios_data_seg     ; pointer 40:0
  1244                                  
  1245                                  
  1246                                  msg_cpu_memory:
  1247 00000132 253135612564257320-     	db	"%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1247 0000013B 2532614D687A204350-
  1247 00000144 5520636C6F636B2C20-
  1247 0000014D 253135612575253261-
  1247 00000156 4B206D656D6F727920-
  1247 0000015F 696E7374616C6C6564 
  1248 00000168 0A00                    	db	NL, 0
  1249                                  msg_cpu_clock_05:
  1250 0000016A 2E3500                  	db	".5", 0
  1251                                  msg_cpu_clock_00:
  1252 0000016D 00                      	db	0
  1253                                  msg_setup:
  1254 0000016E 507265737320277327-     	db	"Press 's' to run NVRAM setup...", NL, 0
  1254 00000177 20746F2072756E204E-
  1254 00000180 5652414D2073657475-
  1254 00000189 702E2E2E0A00       
  1255                                  msg_nvram_bad:
  1256 0000018F 4E5652414D20636865-     	db	"NVRAM checksum is invalid, running setup", NL, 0
  1256 00000198 636B73756D20697320-
  1256 000001A1 696E76616C69642C20-
  1256 000001AA 72756E6E696E672073-
  1256 000001B3 657475700A00       
  1257                                  msg_floppy:
  1258 000001B9 4E6F7720696E697469-     	db	"Now initializing floppy", NL, 0
  1258 000001C2 616C697A696E672066-
  1258 000001CB 6C6F7070790A00     
  1259                                  %if 0
  1260                                  msg_fpu_err:
  1261                                  	db	NL, "EM187 has signalled error 0x%02x.", NL, 0
  1262                                  %endif
  1263                                  msg_booting:
  1264 000001D2 547279696E6720746F-     	db	"Trying to boot from drive %c: ", 0
  1264 000001DB 20626F6F742066726F-
  1264 000001E4 6D2064726976652025-
  1264 000001ED 633A2000           
  1265                                  msg_boot_err:
  1266 000001F1 4469736B2072656164-     	db	"Disk read failed  AX=%04x", NL, 0
  1266 000001FA 206661696C65642020-
  1266 00000203 41583D253034780A00 
  1267                                  msg_no_boot:
  1268 0000020C 426F6F74207369676E-     	db	"Boot signature not found", NL, 0
  1268 00000215 6174757265206E6F74-
  1268 0000021E 20666F756E640A00   
  1269                                  msg_no_loader:
  1270 00000226 4D617374657220626F-     	db	"Master boot loader not found", NL, 0
  1270 0000022F 6F74206C6F61646572-
  1270 00000238 206E6F7420666F756E-
  1270 00000241 640A00             
  1271                                  msg_boot_ok:
  1272 00000244 4F4B0A00                	db	"OK", NL, 0
  1273                                  msg_cpm_disk:
  1274 00000248 6E6F207369676E6174-             db      "no signature check ", 0
  1274 00000251 75726520636865636B-
  1274 0000025A 2000               
  1275                                  msg_alt_disk:
  1276 0000025C 4D494E495820626F6F-     	db	"MINIX boot signature ",0
  1276 00000265 74207369676E617475-
  1276 0000026E 72652000           
  1277                                  
  1278                                  
  1279                                  
  1280                                  %if TBASIC
  1281                                  %else
  1282                                  msg_no_basic:
  1283                                  	db	"No ROM Basic. Please implement one :-)", NL
  1284                                  	db	"Press any key to try again...", NL, 0
  1285                                  %endif
  1286                                  
  1287                                  
  1288                                  %if SOFT_DEBUG
  1289                                  	global	cout,bout,wout,boutsp,crlf
  1290                                  ; NewLine
  1291                                  crlf:
  1292                                  	mov	al,0Dh
  1293                                  	call	cout
  1294                                  	mov	al,0Ah
  1295                                  	call	cout
  1296                                  	ret
  1297                                  
  1298                                  
  1299                                  ; output byte from AL, then a space
  1300                                  boutsp:
  1301                                  	call	bout
  1302                                  	mov	al,20h
  1303                                  	call	cout
  1304                                  	ret
  1305                                  ; word output from AX
  1306                                  wout:
  1307                                  	xchg	al,ah
  1308                                  	call	bout
  1309                                  	xchg	al,ah
  1310                                  ; byte output from AL
  1311                                  bout:
  1312                                  	rol	al,4
  1313                                  	call	nout
  1314                                  	rol	al,4
  1315                                  ; nibble output from low nibble in AL
  1316                                  nout:
  1317                                  	push	ax
  1318                                  	and	al,0Fh		; mask nibble
  1319                                  	daa			; convert to decimal
  1320                                  	add	al,0F0h		; overflow to Carry
  1321                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1322                                  	call	cout
  1323                                  	pop	ax
  1324                                  	ret
  1325                                  
  1326                                  ; character output from AL
  1327                                  cout:
  1328                                  %if 0
  1329                                  	pushm	ax,bx
  1330                                  	mov	ah,0Eh		; write character in AL
  1331                                  	mov	bx,0007h
  1332                                  	int	10h
  1333                                  	popm	ax,bx
  1334                                  %else
  1335                                  THRE	EQU	1<<5		; Transmit holding register empty
  1336                                  	pushm	ax,dx
  1337                                  .1:	mov	dx,uart_lsr
  1338                                  	in	al,dx
  1339                                  	test	al,THRE
  1340                                  	jz	.1
  1341                                  	mov	dx,uart_thr
  1342                                  	popm	ax
  1343                                  	out	dx,al
  1344                                  	popm	dx
  1345                                  %endif
  1346                                  	ret
  1347                                  %endif
