                   ; PAULMON2, a user-friendly 8051 monitor, by Paul Stoffregen
                   ; Please email comments, suggestions, bugs to paul@pjrc.com
                   
                   ; Version 2.1, flash rom changed from 28F256 (obsolete) to
                   ;   the standard 39F512 algorithm (4 cycle write, 6 cycle er
                   ;   Some code size improvements, contributed by Alexander B.
                   ;   Download can now start from main menu prompt
                   
                   ; It's free.  PAULMON2 is in the public domain.  You may cop
                   ; sections of code from PAULMON2 into your own programs, eve
                   ; for commercial purposes.  PAULMON2 should only be distribu
                   ; free of charge, but may be bundled as 'value-added' with o
                   ; products, such as development boards, CDROMs, etc.  Please
                   ; distribute the PAULMON2.DOC file and other files, not just
                   ; the object code!
                   
                   ; The PAULMON2.EQU and PAULMON2.HDR files contain valuable
                   ; information that could help you to write programs for use
                   ; with PAULMON2.
                   
                   ; PAULMON2 is in the public domain. PAULMON2 is distributed 
                   ; the hope that it will be useful, but without any warranty;
                   ; without even the implied warranty of merchantability or fi
                   ; for a particular purpose. 
                   
                   
                   ; You are probably reading this code to see what it looks li
                   ; and possibly learn something, or to modify it for some rea
                   ; Either is ok, but please remember that this code uses a nu
                   ; of tricks to cram all the functionality into just 4k.  As 
                   ; result, the code can be difficult to read, and adding new
                   ; features can be very difficult without growing beyond 4k. 
                   ; add or modify commands in PAULMON2, please consider using 
                   ; "external command" functionality.  It is easier to develop
                   ; new commands this way, and you can distribute them to othe
                   ; users.  Email paul@pjrc.com if you have new PAULMON2
                   ; commands to contribute to others.  Details about adding ne
                   ; commands to PAULMON2 (with examples) can be found at:
                   
                   ; http://www.pjrc.com/tech/8051/pm2_docs/addons.html
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;            PAULMON2's default configuration              ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   ; PAULMON2 should be assembled using the modified AS31 assem
                   ; originally written by Ken Stauffer, many small changes by 
                   ; Stoffregen.  This free assembler is available on the web a
                   ; http://www.pjrc.com/tech/8051/index.html
                   ; As well, these web pages have a fill-out form which makes 
                   ; very easy to custom configure PAULMON2.  Using this form w
                   ; edit the code for you, run the AS31 assmebler, and send yo
                   ; object code to program into your chip.
                   
                   
                   ; These two parameters control where PAULMON2 will be assemb
                   ; and where it will attempt to LJMP at the interrupt vector 
                   
0000:              .equ     base, 0x0000            ;location for PAULMON2
0000:              .equ     vector, 0x2000          ;location to LJMP interrupt
                   
                   ; These three parameters tell PAULMON2 where the user's memo
                   ; installed.  "bmem" and "emem" define the space that will b
                   ; for program headers, user installed commands, start-up pro
                   ; "bmem" and "emem" should be use so they exclude memory are
                   ; perphreal devices may be mapped, as reading memory from an
                   ; may reconfigure it unexpectedly.  If flash rom is used, "b
                   ; should also include the space where the flash rom is mappe
                   
0000:              .equ     pgm, 0x2000             ;default location for the u
0000:              .equ     bmem, 0x1000            ;where is the beginning of 
                   ;.equ    emem, 0xFFFF            ;end of the memory
0000:              .equ     emem, 0x7FFF            ;end of the memory (32KB pa
                   
                   ; To set the baud rate, use this formula or set to 0 for aut
                   ; baud_const = 256 - (crystal / (12 * 16 * baud))
                   
                   ;.equ    baud_const, 0           ;automatic baud rate detect
                   ;.equ    baud_const, 255                 ;57600 baud w/ 11.0
                   ;.equ    baud_const, 253                 ;19200 baud w/ 11.0
                   ;.equ    baud_const, 250                 ;9600 baud w/ 11.05
                   ;.equ    baud_const, 244                 ;4800 baud w/ 11.05
0000:              .equ     baud_const, 208                 ;1200 baud w/ 11.05
                   ;.equ    baud_const, 252                 ;19200 baud w/ 14.7
                   ;.equ    baud_const, 243                 ;4808 baud w/ 12 MH
                   ;.equ    baud_const, 230                 ;1200 baud w/ 6.000
                   
0000:              .equ     line_delay, 6           ;num of char times to pause
                   
                   ; About download speed: when writing to ram, PAULMON2 can ac
                   ; at the maximum baud rate (baud_const=255 or 57600 baud w/ 
                   ; Most terminal emulation programs introduce intentional del
                   ; sending ascii data, which you would want to turn off for d
                   ; larger programs into ram.  For Flash ROM, the maximum spee
                   ; the time it takes to program each location... 9600 baud se
                   ; nicely for the AMD 28F256 chip.  The "character pacing" de
                   ; terminal emulation program should be sufficient to downloa
                   ; rom and any baud rate.  Some flash rom chips can write ver
                   ; allowing high speed baud rates, but other chips can not.  
                   ; will vary...
                   
                   
                   ; Flash ROM parameters.   If "has_flash" is set to zero, all
                   ; features are turned off, otherwise "bflash" and "eflash" s
                   ; the memory range which is flash rom.   Though AMD doesn't 
                   ; you may be able to map only a part of the flash rom with y
                   ; decoder logic (and not use the rest), but you should be ca
                   ; "bflash" and "eflash" don't include and memory which is NO
                   ; so that the erase algorithm won't keep applying erase puls
                   ; finally gives up (which will stress the thin oxide and deg
                   ; flash rom's life and reliability).  "erase_pin" allows you
                   ; the bit address for a pin which (if held low) will tell PA
                   ; erase the flash rom chip when it starts up.  This is usefu
                   ; download programs with the "start-up" headers on them and 
                   ; put in the flash rom crashes!
                   
0000:              .equ     has_flash, 0            ;set to non-zero value if f
0000:              .equ     bflash, 0x8000          ;first memory location of F
0000:              .equ     eflash, 0xFFFF          ;last memory location of Fl
0000:              .equ     erase_pin, 0            ;00 = disable erase pin fea
                   ;.equ    erase_pin, 0xB5                 ;B5 = pin 15, P3.5 
                   
                   ; Development Board Wiring, http://www.pjrc.com/tech/8051/
                   ; wiring is not a simple A0 to A0... works fine, but require
                   ; special Flash ROM programming addresses to be encoded.
                   ;Flash: A15 A14 A13 A12 A11 A10  A9  A8  A7  A6  A5  A4  A3 
                   ;8051:   -  A14 A13  A1  A9  A8 A10 A11  A0  A3  A2  A4  A5 
                   ;
                   ;0x5555  0   1   0   1   0   1   0   1   0   1   0   1   0  
                   ;0x595A  0   1   0   1   1   0   0   1   0   1   0   1   1  
                   ;
                   ;0x2AAA  0   0   1   0   1   0   1   0   1   0   1   0   1  
                   ;0x26A5  0   0   1   0   0   1   1   0   1   0   1   0   0  
                   
                   ;sets the base address to add to the flash memory register a
0000:              .equ    flash_base, bflash
                   
0000:              .equ   flash_en1_addr, 0x5555 + flash_base
                   ;.equ    flash_en1_addr, 0x595A + flash_base
0000:              .equ    flash_en1_data, 0xAA
                   
0000:              .equ   flash_en2_addr, 0x2AAA + flash_base
                   ;.equ    flash_en2_addr, 0x26A5 + flash_base
0000:              .equ    flash_en2_data, 0x55
                   
0000:              .equ   flash_wr_addr, 0x5555 + flash_base
                   ;.equ    flash_wr_addr, 0x595A + flash_base
0000:              .equ    flash_wr_data, 0xA0
                   
0000:              .equ   flash_er1_addr, 0x5555 + flash_base
                   ;.equ    flash_er1_addr, 0x595A + flash_base
0000:              .equ    flash_er1_data, 0x80
                   
0000:              .equ   flash_er2_addr, 0x5555 + flash_base
                   ;.equ    flash_er2_addr, 0x595A + flash_base
0000:              .equ    flash_er2_data, 0x10
                   
                   
                   ; Please note... much of the memory management code only loo
                   ; upper 8 bits of an address, so it's not a good idea to som
                   ; your memory chips (with complex address decoding logic) in
                   ; less than 256 bytes.   In other words, only using a piece 
                   ; rom chip and mapping it between C43A to F91B would confuse
                   ; (as well as require quit a bit of address decoding logic c
                   
                   ; Several people didn't like the key definations in PAULMON1
                   ; Actually, I didn't like 'em either, but I never took the t
                   ; to change it.   Eventually I got used to them, but now it'
                   ; really easy to change which keys do what in PAULMON2.   Yo
                   ; can guess what to do below, but don't use lowercase.
                   
0000:              .equ     help_key, '?'           ;help screen
0000:              .equ     dir_key,  'M'           ;directory
0000:              .equ     run_key,  'R'           ;run program
0000:              .equ     dnld_key, 'D'           ;download
0000:              .equ     upld_key, 'U'           ;upload
0000:              .equ     nloc_key, 'N'           ;new memory location
0000:              .equ     jump_key, 'J'           ;jump to memory location
0000:              .equ     dump_key, 'H'           ;hex dump memory
0000:              .equ     intm_key, 'I'           ;hex dump internal memory
0000:              .equ     edit_key, 'E'           ;edit memory
0000:              .equ     clrm_key, 'C'           ;clear memory
0000:              .equ     erfr_key, 'Z'           ;erase flash rom
                   
                   ; timing parameters for AMD Flash ROM 28F256.  These paramet
                   ; and pretty conservative and they seem to work with crystal
                   ; between 6 MHz to 24 MHz... (tested with AMD 28F256 chips o
                   ; unless you know this is a problem, it is probably not a go
                   ; idea to fiddle with these.
                   
                   ;.equ    pgmwait, 10             ;22.1184 MHz crystal assume
0000:              .equ     pgmwait, 19             ;11.0592 MHz
0000:              .equ     verwait, 5
                   ;.equ    erwait1, 40             ;fourty delays @22.1184
0000:              .equ     erwait1, 20             ;twenty delays for 11.0592 
0000:              .equ     erwait2, 229            ;each delay .5 ms @22.1184M
                   
                   
                   
                   ; These symbols configure paulmon2's internal memory usage.
                   ; It is usually not a good idea to change these unless you
                   ; know that you really have to.
                   
0000:              .equ     psw_init, 0             ;value for psw (which reg b
0000:              .equ     dnld_parm, 0x10                 ;block of 16 bytes 
0000:              .equ     stack, 0x30             ;location of the stack
0000:              .equ     baud_save, 0x78                 ;save baud for warm
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;                     Interrupt Vectors                    ;
                   ;  (and little bits of code crammed in the empty spaces)  ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
0000:                       .org    base
0000: 02 08 60              ljmp    poweron                 ;reset vector
                   
0003:                       .org    base+3
0003: 02 20 03              ljmp    vector+3        ;ext int0 vector
                   
                   r6r7todptr:
0006: 8E 82                 mov     dpl, r6
0008: 8F 83                 mov     dph, r7
000A: 22                    ret
                   
000B:                       .org    base+11
000B: 02 20 0B              ljmp    vector+11       ;timer0 vector
                   
                   dptrtor6r7:
000E: AE 82                 mov     r6, dpl
0010: AF 83                 mov     r7, dph
0012: 22                    ret
                   
0013:                       .org    base+19
0013: 02 20 13              ljmp    vector+19       ;ext int1 vector
                   
0016: 74 2D        dash:    mov     a, #'-'                 ;seems kinda trivia
0018: 01 76                 ajmp    cout            ;this appears in code, it t
001A: 00                    nop                     ;bytes, but an acall takes 
                   
001B:                       .org    base+27
001B: 02 20 1B              ljmp    vector+27       ;timer1 vector
                   
001E: 11 76        cout_sp:acall    cout
0020: 01 74                 ajmp    space
0022: 00                    nop
                   
0023:                       .org    base+35
0023: 02 20 23              ljmp    vector+35       ;uart vector
                   
0026: 11 16        dash_sp:acall    dash
0028: 01 74                 ajmp    space
002A: 00                    nop
                   
002B:                       .org    base+43
002B: 02 20 2B              ljmp    vector+43       ;timer2 vector (8052)
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;        The jump table for user programs to call          ;
                   ;              subroutines within PAULMON                  ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
002E:              .org     base+46                 ;never change this line!!  
                                            ;programs depend on these locations
                                            ;to access paulmon2 functions
                   
002E: 21 6A                 ajmp    phex1           ;2E
0030: 01 76                 ajmp    cout            ;30
0032: 01 6A                 ajmp    cin             ;32
0034: 21 67                 ajmp    phex            ;34
0036: 21 79                 ajmp    phex16          ;36
0038: 21 86                 ajmp    pstr            ;38
003A: 01 8D                 ajmp    ghex            ;3A
003C: 01 D1                 ajmp    ghex16          ;3C
003E: 21 BA                 ajmp    esc             ;4E
0040: 21 9A                 ajmp    upper           ;40
0042: 02 08 F6              ljmp    autobaud        ;42
0045: 02 0B 15     pcstr_h:ljmp     pcstr           ;45
0048: 01 80                 ajmp    newline                 ;48
004A: 02 01 A7              ljmp    lenstr          ;4A
004D: 02 0A 5E              ljmp    pint8u          ;4D
0050: 02 0A 64              ljmp    pint8           ;50
0053: 02 0A A2              ljmp    pint16u                 ;53
0056: 02 08 22              ljmp    smart_wr        ;56
0059: 02 07 9F              ljmp    prgm            ;59
005C: 02 07 C1              ljmp    erall           ;5C
005F: 02 07 F8              ljmp    find            ;5F
                   cin_filter_h:
0062: 02 09 DD              ljmp    cin_filter      ;62
0065: 21 4D                 ajmp    asc2hex                 ;65
0067: 02 07 DF              ljmp    erblock                 ;67
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;               Subroutines for serial I/O                 ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   
006A: 30 98 FD     cin:     jnb     ri, cin
006D: C2 98                 clr     ri
006F: E5 99                 mov     a, sbuf
0071: 22                    ret
                   
0072: 11 74        dspace: acall    space
0074: 74 20        space:   mov     a, #' '
0076: 30 99 FD     cout:    jnb     ti, cout
0079: C2 99                 clr     ti              ;clr ti before the mov to s
007B: F5 99                 mov     sbuf, a
007D: 22                    ret
                   
                   ;clearing ti before reading sbuf takes care of the case wher
                   ;interrupts may be enabled... if an interrupt were to happen
                   ;between those two instructions, the serial port will just
                   ;wait a while, but in the other order and the character coul
                   ;finish transmitting (during the interrupt routine) and then
                   ;ti would be cleared and never set again by the hardware, ca
                   ;the next call to cout to hang forever!
                   
                   newline2:                        ;print two newlines
007E: 11 80                 acall   newline
0080: C0 E0        newline:push     acc             ;print one newline
0082: 74 0D                 mov     a, #13
0084: 11 76                 acall   cout
0086: 74 0A                 mov     a, #10
0088: 11 76                 acall   cout
008A: D0 E0                 pop     acc
008C: 22                    ret
                   
                            ;get 2 digit hex number from serial port
                            ; c = set if ESC pressed, clear otherwise
                            ; psw.5 = set if return w/ no input, clear otherwis
                   ghex:
008D: C2 D5        ghex8:   clr     psw.5
                   ghex8c:
008F: 11 62                 acall   cin_filter_h    ;get first digit
0091: 31 9A                 acall   upper
0093: B4 1B 03              cjne    a, #27, ghex8f
0096: D3           ghex8d: setb     c
0097: E4                    clr     a
0098: 22                    ret
0099: B4 0D 05     ghex8f: cjne     a, #13, ghex8h
009C: D2 D5                 setb    psw.5
009E: C3                    clr     c
009F: E4                    clr     a
00A0: 22                    ret
00A1: FA           ghex8h: mov      r2, a
00A2: 31 4D                 acall   asc2hex
00A4: 40 E9                 jc      ghex8c
00A6: CA                    xch     a, r2           ;r2 will hold hex value of 
00A7: 11 76                 acall   cout
                   ghex8j:
00A9: 11 62                 acall   cin_filter_h    ;get second digit
00AB: 31 9A                 acall   upper
00AD: B4 1B 02              cjne    a, #27, ghex8k
00B0: 80 E4                 sjmp    ghex8d
00B2: B4 0D 03     ghex8k: cjne     a, #13, ghex8m
00B5: EA                    mov     a, r2
00B6: C3                    clr     c
00B7: 22                    ret
00B8: B4 08 04     ghex8m: cjne     a, #8, ghex8p
00BB: 11 76        ghex8n: acall    cout
00BD: 80 D0                 sjmp    ghex8c
00BF: B4 15 02     ghex8p: cjne     a, #21, ghex8q
00C2: 80 F7                 sjmp    ghex8n
00C4: FB           ghex8q: mov      r3, a
00C5: 31 4D                 acall   asc2hex
00C7: 40 E0                 jc      ghex8j
00C9: CB                    xch     a, r3
00CA: 11 76                 acall   cout
00CC: EA                    mov     a, r2
00CD: C4                    swap    a
00CE: 4B                    orl     a, r3
00CF: C3                    clr     c
00D0: 22                    ret
                   
                   
                   
                   
                            ;carry set if esc pressed
                            ;psw.5 set if return pressed w/ no input
                   ghex16:
00D1: 7A 00                 mov     r2, #0          ;start out with 0
00D3: 7B 00                 mov     r3, #0
00D5: 7C 04                 mov     r4, #4          ;number of digits left
00D7: C2 D5                 clr     psw.5
                   
                   ghex16c:
00D9: 11 62                 acall   cin_filter_h
00DB: 31 9A                 acall   upper
00DD: B4 1B 07              cjne    a, #27, ghex16d
00E0: D3                    setb    c               ;handle esc key
00E1: E4                    clr     a
00E2: F5 83                 mov     dph, a
00E4: F5 82                 mov     dpl, a
00E6: 22                    ret
00E7: B4 08 02     ghex16d:cjne     a, #8, ghex16f
00EA: 80 03                 sjmp    ghex16k
00EC: B4 7F 0C     ghex16f:cjne     a, #127, ghex16g  ;handle backspace
00EF: BC 04 02     ghex16k:cjne     r4, #4, ghex16e           ;have they entere
00F2: 80 E5                 sjmp    ghex16c
00F4: 11 76        ghex16e:acall    cout
00F6: 31 3C                 acall   ghex16y
00F8: 0C                    inc     r4
00F9: 80 DE                 sjmp    ghex16c
00FB: B4 0D 10     ghex16g:cjne     a, #13, ghex16i           ;return key
00FE: 8B 83                 mov     dph, r3
0100: 8A 82                 mov     dpl, r2
0102: BC 04 07              cjne    r4, #4, ghex16h
0105: E4                    clr     a
0106: F5 83                 mov     dph, a
0108: F5 82                 mov     dpl, a
010A: D2 D5                 setb    psw.5
010C: C3           ghex16h:clr      c
010D: 22                    ret
010E: FD           ghex16i:mov      r5, a             ;keep copy of original ke
010F: 31 4D                 acall   asc2hex
0111: 40 C6                 jc      ghex16c
0113: CD                    xch     a, r5
0114: 12 00 76              lcall   cout
0117: ED                    mov     a, r5
0118: C0 E0                 push    acc
011A: 31 2B                 acall   ghex16x
011C: D0 E0                 pop     acc
011E: 2A                    add     a, r2
011F: FA                    mov     r2, a
0120: E4                    clr     a
0121: 3B                    addc    a, r3
0122: FB                    mov     r3, a
0123: DC B4                 djnz    r4, ghex16c
0125: C3                    clr     c
0126: 8A 82                 mov     dpl, r2
0128: 8B 83                 mov     dph, r3
012A: 22                    ret
                   
                   ghex16x:  ;multiply r3-r2 by 16 (shift left by 4)
012B: EB                    mov     a, r3
012C: C4                    swap    a
012D: 54 F0                 anl     a, #11110000b
012F: FB                    mov     r3, a
0130: EA                    mov     a, r2
0131: C4                    swap    a
0132: 54 0F                 anl     a, #00001111b
0134: 4B                    orl     a, r3
0135: FB                    mov     r3, a
0136: EA                    mov     a, r2
0137: C4                    swap    a
0138: 54 F0                 anl     a, #11110000b
013A: FA                    mov     r2, a
013B: 22                    ret
                   
                   ghex16y:  ;divide r3-r2 by 16 (shift right by 4)
013C: EA                    mov     a, r2
013D: C4                    swap    a
013E: 54 0F                 anl     a, #00001111b
0140: FA                    mov     r2, a
0141: EB                    mov     a, r3
0142: C4                    swap    a
0143: 54 F0                 anl     a, #11110000b
0145: 4A                    orl     a, r2
0146: FA                    mov     r2, a
0147: EB                    mov     a, r3
0148: C4                    swap    a
0149: 54 0F                 anl     a, #00001111b
014B: FB                    mov     r3, a
014C: 22                    ret
                   
                   
                            ;carry set if invalid input
                   asc2hex:
014D: 24 D0                 add     a, #208
014F: 50 14                 jnc     hex_not
0151: 24 F6                 add     a, #246
0153: 40 04                 jc      hex_maybe
0155: 24 0A                 add     a, #10
0157: C3                    clr     c
0158: 22                    ret
                   hex_maybe:
0159: 24 F9                 add     a, #249
015B: 50 08                 jnc     hex_not
015D: 24 FA                 add     a, #250
015F: 40 04                 jc      hex_not
0161: 24 10                 add     a, #16
0163: C3                    clr     c
0164: 22                    ret
0165: D3           hex_not:setb     c
0166: 22                    ret
                   
                   
                   ; Highly code efficient resursive call phex contributed
                   ; by Alexander B. Alexandrov <abalex@cbr.spb.ru>
                   
                   phex:
                   phex8:
0167: 31 69                 acall   phex_b
0169: C4           phex_b:  swap    a               ;SWAP A will be twice => A 
016A: C0 E0        phex1:   push    acc
016C: 54 0F                 anl     a, #15
016E: 24 90                 add     a, #0x90        ; acc is 0x9X, where X is h
0170: D4                    da      a               ; if A to F, C=1 and lower 
0171: 34 40                 addc    a, #0x40
0173: D4                    da      a
0174: 11 76                 acall   cout
0176: D0 E0                 pop     acc
0178: 22                    ret
                   
                   ; the old code... easier to understand
                   ;        push    acc
                   ;        swap    a
                   ;        anl     a, #15
                   ;        add     a, #246
                   ;        jnc     phex_b
                   ;        add     a, #7
                   ;phex_b:add      a, #58
                   ;        acall   cout
                   ;        pop     acc
                   ;phex1:  push    acc
                   ;        anl     a, #15
                   ;        add     a, #246
                   ;        jnc     phex_c
                   ;        add     a, #7
                   ;phex_c:add      a, #58
                   ;        acall   cout
                   ;        pop     acc
                   ;        ret
                   
                   
                   phex16:
0179: C0 E0                 push    acc
017B: E5 83                 mov     a, dph
017D: 31 67                 acall   phex
017F: E5 82                 mov     a, dpl
0181: 31 67                 acall   phex
0183: D0 E0                 pop     acc
0185: 22                    ret
                   
                   
                   ;a not so well documented feature of pstr is that you can pr
                   ;multiple consecutive strings without needing to reload dptr
                   ;(which takes 3 bytes of code!)... this is useful for insert
                   ;numbers or spaces between strings.
                   
0186: C0 E0        pstr:    push    acc
0188: E4           pstr1:   clr     a
0189: 93                    movc    a, @a+dptr
018A: A3                    inc     dptr
018B: 60 0A                 jz      pstr2
018D: A2 E7                 mov     c, acc.7
018F: 54 7F                 anl     a, #0x7F
0191: 11 76                 acall   cout
0193: 40 02                 jc      pstr2
0195: 80 F1                 sjmp    pstr1
0197: D0 E0        pstr2:   pop     acc
0199: 22                    ret
                   
                   ;converts the ascii code in Acc to uppercase, if it is lower
                   
                   ; Code efficient (saves 6 byes) upper contributed
                   ; by Alexander B. Alexandrov <abalex@cbr.spb.ru>
                   
                   upper:
019A: B4 61 00              cjne    a, #97, upper2
019D: 40 07        upper2:  jc      upper4          ;end if acc < 97
019F: B4 7B 00              cjne    a, #123, upper3
01A2: 50 02        upper3:  jnc     upper4          ;end if acc >= 123
01A4: 24 E0                 add     a, #224                 ;convert to upperca
01A6: 22           upper4:  ret
                   
                   
                   
01A7: 78 00        lenstr: mov      r0, #0    ;returns length of a string in r0
01A9: C0 E0                 push    acc
01AB: E4           lenstr1:clr      a
01AC: 93                    movc    a,@a+dptr
01AD: 60 08                 jz      lenstr2
01AF: A2 E7                 mov     c,acc.7
01B1: 08                    inc     r0
01B2: 40 03                 Jc      lenstr2
01B4: A3                    inc     dptr
01B5: 80 F4                 sjmp    lenstr1
01B7: D0 E0        lenstr2:pop      acc
01B9: 22                    ret
                   
                   
                   esc:  ;checks to see if <ESC> is waiting on serial port
                         ;C=clear if no <ESC>, C=set if <ESC> pressed
                         ;buffer is flushed
01BA: C0 E0                 push    acc
01BC: C3                    clr     c
01BD: 30 98 08              jnb     ri,esc2
01C0: E5 99                 mov     a,sbuf
01C2: B4 1B 01              cjne    a,#27,esc1
01C5: D3                    setb    c
01C6: C2 98        esc1:    clr     ri
01C8: D0 E0        esc2:    pop     acc
01CA: 22                    ret
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;    The 'high-level' stuff to interact with the user      ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   
                   menu: ;first we print out the prompt, which isn't as simple
                         ;as it may seem, since external code can add to the
                         ;prompt, so we've got to find and execute all of 'em.
01CB: 90 0D B6              mov     dptr, #prompt1    ;give 'em the first part 
01CE: 11 45                 acall   pcstr_h
01D0: EF                    mov     a, r7
01D1: 31 67                 acall   phex
01D3: EE                    mov     a, r6
01D4: 31 67                 acall   phex
                            ;mov     dptr, #prompt2
01D6: 31 86                 acall   pstr
                   
                   ;now we're finally past the prompt, so let's get some input
01D8: 11 62                 acall   cin_filter_h    ;get the input, finally
01DA: B4 3A 04              cjne    a, #':', menu0
01DD: 51 B8                 acall   dnld_now
01DF: 80 EA                 sjmp    menu
01E1: 31 9A        menu0:   acall   upper
                   
                   ;push return address onto stack so we can just jump to the p
01E3: 75 F0 CB              mov     b, #(menu & 255)  ;we push the return addre
01E6: C0 F0                 push    b                 ;to save code later...
01E8: 75 F0 01              mov     b, #(menu >> 8)           ;if bogus input, 
01EB: C0 F0                 push    b                 ;another prompt.
                   
                   
                   
                   ;first we'll look through memory for a program header that s
                   ;it's a user installed command which matches what the user p
                   
                   ;user installed commands need to avoid changing R6/R7, which
                   ;the memory pointer.  The stack pointer can't be changed obv
                   ;all the other general purpose registers should be available
                   ;user commands to alter as they wish.
                   
01ED: F5 F0        menux:   mov     b, a            ;now search for external co
01EF: 90 10 00              mov     dptr, #bmem
01F2: F1 F8        menux1: acall    find
01F4: 50 24                 jnc     menuxend           ;searched all the comman
01F6: 75 82 04              mov     dpl, #4
01F9: E4                    clr     a
01FA: 93                    movc    a,@a+dptr
01FB: B4 FE 15              cjne    a, #254, menux2          ;only FE is an ext
01FE: 05 82                 inc     dpl
0200: E4                    clr     a
0201: 93                    movc    a,@a+dptr
0202: B5 F0 0E              cjne    a, b, menux2      ;only run if they want it
0205: 11 74                 acall   space
0207: 75 82 20              mov     dpl, #32
020A: 31 86                 acall   pstr               ;print command name
020C: 11 80                 acall   newline
020E: 75 82 40              mov     dpl, #64
0211: E4                    clr     a
0212: 73                    jmp     @a+dptr                 ;take a leap of fai
0213: 05 83        menux2: inc      dph
0215: E5 83                 mov     a, dph
0217: B4 80 D8              cjne    a, #((emem+1) >> 8) & 255, menux1
                   menuxend:
021A: E5 F0                 mov     a, b
                   
                   
                   ;since we didn't find a user installed command, use the buil
                   
                   menu1a:
021C: B4 3F 07     menu1b:  cjne    a, #help_key, menu1c
021F: 90 0F 1E              mov     dptr, #help_cmd2
0222: 11 45                 acall   pcstr_h
0224: A1 C7                 ajmp    help
0226: B4 4D 07     menu1c: cjne     a, #dir_key, menu1d
0229: 90 0F 26              mov     dptr, #dir_cmd
022C: 11 45                 acall   pcstr_h
022E: 81 B8                 ajmp    dir
0230: B4 52 07     menu1d: cjne     a, #run_key, menu1e
0233: 90 0F 2B              mov     dptr, #run_cmd
0236: 11 45                 acall   pcstr_h
0238: A1 2F                 ajmp    run
023A: B4 44 07     menu1e: cjne     a, #dnld_key, menu1f
023D: 90 0F 2F              mov     dptr, #dnld_cmd
0240: 11 45                 acall   pcstr_h
0242: 41 9B                 ajmp    dnld
0244: B4 55 07     menu1f: cjne     a, #upld_key, menu1g
0247: 90 0F 32              mov     dptr, #upld_cmd
024A: 11 45                 acall   pcstr_h
024C: C1 3C                 ajmp    upld
024E: B4 4E 07     menu1g: cjne     a, #nloc_key, menu1h
0251: 90 0F 35              mov     dptr, #nloc_cmd
0254: 11 45                 acall   pcstr_h
0256: E1 2E                 ajmp    nloc
0258: B4 4A 07     menu1h: cjne     a, #jump_key, menu1i
025B: 90 0F 39              mov     dptr, #jump_cmd
025E: 11 45                 acall   pcstr_h
0260: 81 0D                 ajmp    jump
0262: B4 48 07     menu1i: cjne     a, #dump_key, menu1j
0265: 90 0F 3F              mov     dptr, #dump_cmd
0268: 11 45                 acall   pcstr_h
026A: 81 41                 ajmp    dump
026C: B4 45 07     menu1j: cjne     a, #edit_key, menu1k
026F: 90 0F 4B              mov     dptr, #edit_cmd
0272: 11 45                 acall   pcstr_h
0274: 81 82                 ajmp    edit
0276: B4 43 07     menu1k: cjne     a, #clrm_key, menu1l
0279: 90 0F 50              mov     dptr, #clrm_cmd
027C: 11 45                 acall   pcstr_h
027E: E1 0A                 ajmp    clrm
0280: B4 5A 0B     menu1l: cjne     a, #erfr_key, menu1m
0283: 74 00                 mov     a, #has_flash
0285: 60 12                 jz      menu_end
0287: 90 0F 54              mov     dptr, #erfr_cmd
028A: 11 45                 acall   pcstr_h
028C: E1 3E                 ajmp    erfr
028E: B4 49 08     menu1m: cjne     a, #intm_key, menu1n
0291: 90 0F 45              mov     dptr, #intm_cmd
0294: 11 45                 acall   pcstr_h
0296: 02 07 64              ljmp    intm
                   menu1n:
                   
                       ;invalid input, no commands to run...
                   menu_end:                        ;at this point, we have not
0299: 01 80                 ajmp    newline                 ;anything to run, s
                                                    ;remember, we pushed menu, 
                                                    ;will just return to menu.
                   
                   ;..........................................................
                   
                   ;---------------------------------------------------------;
                   
                   ;dnlds1 = "Begin sending Intel HEX format file <ESC> to abor
                   ;dnlds2 = "Download aborted"
                   ;dnlds3 = "Download completed"
                   
                   
                   ;16 byte parameter table: (eight 16 bit values)
                   ;  *   0 = lines received
                   ;  *   1 = bytes received
                   ;  *   2 = bytes written
                   ;  *   3 = bytes unable to write
                   ;  *   4 = incorrect checksums
                   ;  *   5 = unexpected begin of line
                   ;  *   6 = unexpected hex digits (while waiting for bol)
                   ;  *   7 = unexpected non-hex digits (in middle of a line)
                   
                   
                   
                   dnld:
029B: 90 0E 50              mov     dptr, #dnlds1            
029E: 11 45                 acall   pcstr_h                    ;"begin sending 
02A0: 91 04                 acall   dnld_init
                   
                              ;look for begining of line marker ':'
02A2: 11 6A        dnld1:   acall   cin
02A4: B4 1B 02              cjne    a, #27, dnld2   ;Test for escape
02A7: 80 78                 sjmp    dnld_esc
                   
02A9: B4 3A 02     dnld2:   cjne    a, #':', dnld2b
02AC: 80 10                 sjmp    dnld2d
                   dnld2b:    ;check to see if it's a hex digit, error if it is
02AE: 31 4D                 acall   asc2hex
02B0: 40 F0                 jc      dnld1
02B2: 79 06                 mov     r1, #6
02B4: 71 33                 acall   dnld_inc
02B6: 80 EA                 sjmp    dnld1
                   
                   dnld_now: ;entry point for main menu detecting ":" character
02B8: 74 5E                 mov     a, #'^'
02BA: 11 76                 acall   cout
02BC: 91 04                 acall   dnld_init
                   
02BE: 79 00        dnld2d:  mov     r1, #0
02C0: 71 33                 acall   dnld_inc
                   
                              ;begin taking in the line of data
                   dnld3:   ;mov    a, #'.'
                            ;acall  cout
02C2: 7C 00                 mov     r4, #0          ;r4 will count up checksum
02C4: 71 52                 acall   dnld_ghex
02C6: F8                    mov     r0, a           ;R0 = # of data bytes
02C7: 74 2E                 mov     a, #'.'
02C9: 11 76                 acall   cout
02CB: 71 52                 acall   dnld_ghex
02CD: F5 83                 mov     dph, a          ;High byte of load address
02CF: 71 52                 acall   dnld_ghex
02D1: F5 82                 mov     dpl, a          ;Low byte of load address
02D3: 71 52                 acall   dnld_ghex       ;Record type
02D5: B4 01 02              cjne    a, #1, dnld4    ;End record?
02D8: 80 2D                 sjmp    dnld_end
02DA: 70 22        dnld4:   jnz     dnld_unknown    ;is it a unknown record typ
02DC: E8           dnld5:   mov     a, r0
02DD: 60 14                 jz      dnld_get_cksum
02DF: 71 52                 acall   dnld_ghex       ;Get data byte
02E1: FA                    mov     r2, a
02E2: 79 01                 mov     r1, #1
02E4: 71 33                 acall   dnld_inc        ;count total data bytes rec
02E6: EA                    mov     a, r2
02E7: 12 08 22              lcall   smart_wr        ;c=1 if an error writing
02EA: E4                    clr     a
02EB: 34 02                 addc    a, #2
02ED: F9                    mov     r1, a
                   ;     2 = bytes written
                   ;     3 = bytes unable to write
02EE: 71 33                 acall   dnld_inc
02F0: A3                    inc     dptr
02F1: D8 E9                 djnz    r0, dnld5
                   dnld_get_cksum:
02F3: 71 52                 acall   dnld_ghex       ;get checksum
02F5: EC                    mov     a, r4
02F6: 60 AA                 jz      dnld1           ;should always add to zero
                   dnld_sumerr:
02F8: 79 04                 mov     r1, #4
02FA: 71 33                 acall   dnld_inc        ;all we can do it count # o
02FC: 80 A4                 sjmp    dnld1
                   
                   dnld_unknown:    ;handle unknown line type
02FE: E8                    mov     a, r0
02FF: 60 F2                 jz      dnld_get_cksum  ;skip data if size is zero
                   dnld_ukn2:
0301: 71 52                 acall   dnld_ghex       ;consume all of unknown dat
0303: D8 FC                 djnz    r0, dnld_ukn2
0305: 80 EC                 sjmp    dnld_get_cksum
                   
                   dnld_end:   ;handles the proper end-of-download marker
0307: E8                    mov     a, r0
0308: 60 04                 jz      dnld_end_3      ;should usually be zero
                   dnld_end_2:
030A: 71 52                 acall   dnld_ghex       ;consume all of useless dat
030C: D8 F3                 djnz    r0, dnld_ukn2
                   dnld_end_3:
030E: 71 52                 acall   dnld_ghex       ;get the last checksum
0310: EC                    mov     a, r4
0311: 70 E5                 jnz     dnld_sumerr
0313: 71 2A                 acall   dnld_dly
0315: 90 0E 6F              mov     dptr, #dnlds3
0318: 11 45                 acall   pcstr_h                    ;"download went 
                            ;consume any cr or lf character that may have been
                            ;on the end of the last line
031A: 30 98 7A              jnb     ri, dnld_sum
031D: 11 6A                 acall   cin
031F: 80 76                 sjmp    dnld_sum
                   
                   
                   
                   dnld_esc:   ;handle esc received in the download stream
0321: 71 2A                 acall   dnld_dly
0323: 90 0E 67              mov     dptr, #dnlds2    
0326: 11 45                 acall   pcstr_h                    ;"download abort
0328: 80 6D                 sjmp    dnld_sum
                   
                   dnld_dly:   ;a short delay since most terminal emulation pro
                                ;won't be ready to receive anything immediately
                                ;they've transmitted a file... even on a fast P
                                ;machine with 16550 uarts!
032A: 78 00                 mov     r0, #0
032C: 79 00        dnlddly2:mov     r1, #0
032E: D9 FE                 djnz    r1, *           ;roughly 128k cycles, appox
0330: D8 FA                 djnz    r0, dnlddly2
0332: 22                    ret
                   
                   dnld_inc:     ;increment parameter specified by R1
                                  ;note, values in Acc and R1 are destroyed
0333: E9                    mov     a, r1
0334: 54 07                 anl     a, #00000111b   ;just in case
0336: 23                    rl      a
0337: 24 10                 add     a, #dnld_parm
0339: F9                    mov     r1, a           ;now r1 points to lsb
033A: 07                    inc     @r1
033B: E7                    mov     a, @r1
033C: 70 02                 jnz     dnldin2
033E: 09                    inc     r1
033F: 07                    inc     @r1
0340: 22           dnldin2:ret
                   
                   dnld_gp:     ;get parameter, and inc to next one (@r1)
                                 ;carry clear if parameter is zero.
                                 ;16 bit value returned in dptr
0341: D3                    setb    c
0342: 87 82                 mov     dpl, @r1
0344: 09                    inc     r1
0345: 87 83                 mov     dph, @r1
0347: 09                    inc     r1
0348: E5 82                 mov     a, dpl
034A: 70 05                 jnz     dnldgp2
034C: E5 83                 mov     a, dph
034E: 70 01                 jnz     dnldgp2
0350: C3                    clr     c
0351: 22           dnldgp2:ret
                   
                   
                   
                   ;a spacial version of ghex just for the download.  Does not
                   ;look for carriage return or backspace.   Handles ESC key by
                   ;poping the return address (I know, nasty, but it saves many
                   ;bytes of code in this 4k ROM) and then jumps to the esc
                   ;key handling.   This ghex doesn't echo characters, and if i
                   ;sees ':', it pops the return and jumps to an error handler
                   ;for ':' in the middle of a line.  Non-hex digits also jump
                   ;to error handlers, depending on which digit.
                              
                   dnld_ghex:
0352: 11 6A        dnldgh1:acall    cin
0354: 31 9A                 acall   upper
0356: B4 1B 06              cjne    a, #27, dnldgh3
0359: D0 E0        dnldgh2:pop      acc
035B: D0 E0                 pop     acc
035D: 80 C2                 sjmp    dnld_esc
035F: B4 3A 0A     dnldgh3:cjne     a, #':', dnldgh5
0362: 79 05        dnldgh4:mov      r1, #5          ;handle unexpected beginnin
0364: 71 33                 acall   dnld_inc
0366: D0 E0                 pop     acc
0368: D0 E0                 pop     acc
036A: 41 C2                 ajmp    dnld3           ;and now we're on a new lin
036C: 31 4D        dnldgh5:acall    asc2hex
036E: 50 06                 jnc     dnldgh6
0370: 79 07                 mov     r1, #7
0372: 71 33                 acall   dnld_inc
0374: 80 DC                 sjmp    dnldgh1
0376: FA           dnldgh6:mov      r2, a           ;keep first digit in r2
0377: 11 6A        dnldgh7:acall    cin
0379: 31 9A                 acall   upper
037B: B4 1B 02              cjne    a, #27, dnldgh8
037E: 80 D9                 sjmp    dnldgh2
0380: B4 3A 02     dnldgh8:cjne     a, #':', dnldgh9
0383: 80 DD                 sjmp    dnldgh4
0385: 31 4D        dnldgh9:acall    asc2hex
0387: 50 06                 jnc     dnldghA
0389: 79 07                 mov     r1, #7
038B: 71 33                 acall   dnld_inc
038D: 80 E8                 sjmp    dnldgh7
038F: CA           dnldghA:xch      a, r2
0390: C4                    swap    a
0391: 4A                    orl     a, r2
0392: FA                    mov     r2, a
0393: 2C                    add     a, r4           ;add into checksum
0394: FC                    mov     r4, a
0395: EA                    mov     a, r2           ;return value in acc
0396: 22                    ret
                   
                   ;dnlds4 =  "Summary:"
                   ;dnlds5 =  " lines received"
                   ;dnlds6a = " bytes received"
                   ;dnlds6b = " bytes written"
                   
                   dnld_sum:    ;print out download summary
0397: EE                    mov     a, r6
0398: C0 E0                 push    acc
039A: EF                    mov     a, r7
039B: C0 E0                 push    acc
039D: 90 0E 76              mov     dptr, #dnlds4
03A0: 11 45                 acall   pcstr_h
03A2: 79 10                 mov     r1, #dnld_parm
03A4: 7E 7F                 mov     r6, #dnlds5 & 255
03A6: 7F 0E                 mov     r7, #dnlds5 >> 8
03A8: 91 00                 acall   dnld_i0
03AA: 7E 85                 mov     r6, #dnlds6a & 255
03AC: 7F 0E                 mov     r7, #dnlds6a >> 8
03AE: 91 00                 acall   dnld_i0
03B0: 7E 8A                 mov     r6, #dnlds6b & 255
03B2: 7F 0E                 mov     r7, #dnlds6b >> 8
03B4: 91 00                 acall   dnld_i0
                   
                   dnld_err:    ;now print out error summary
03B6: 7A 05                 mov     r2, #5
03B8: 71 41        dnlder2:acall    dnld_gp
03BA: 40 09                 jc      dnlder3                 ;any errors?
03BC: DA FA                 djnz    r2, dnlder2
                             ;no errors, so we print the nice message
03BE: 90 0E C6              mov     dptr, #dnlds13
03C1: 11 45                 acall   pcstr_h
03C3: 80 25                 sjmp    dlnd_sum_done
                   
                   dnlder3:  ;there were errors, so now we print 'em
03C5: 90 0E 95              mov     dptr, #dnlds7
03C8: 11 45                 acall   pcstr_h
                              ;but let's not be nasty... only print if necessar
03CA: 79 16                 mov     r1, #(dnld_parm+6)
03CC: 7E 99                 mov     r6, #dnlds8 & 255
03CE: 7F 0E                 mov     r7, #dnlds8 >> 8
03D0: 71 F2                 acall   dnld_item
03D2: 7E AA                 mov     r6, #dnlds9 & 255
03D4: 7F 0E                 mov     r7, #dnlds9 >> 8
03D6: 71 F2                 acall   dnld_item
03D8: 7E B2                 mov     r6, #dnlds10 & 255
03DA: 7F 0E                 mov     r7, #dnlds10 >> 8
03DC: 71 F2                 acall   dnld_item
03DE: 7E B8                 mov     r6, #dnlds11 & 255
03E0: 7F 0E                 mov     r7, #dnlds11 >> 8
03E2: 71 F2                 acall   dnld_item
03E4: 7E BD                 mov     r6, #dnlds12 & 255
03E6: 7F 0E                 mov     r7, #dnlds12 >> 8
03E8: 71 F2                 acall   dnld_item
                   dlnd_sum_done:
03EA: D0 E0                 pop     acc
03EC: FF                    mov     r7, a
03ED: D0 E0                 pop     acc
03EF: FE                    mov     r6, a
03F0: 01 80                 ajmp    newline
                   
                   dnld_item:
03F2: 71 41                 acall   dnld_gp                 ;error conditions
03F4: 50 09                 jnc     dnld_i3
03F6: 11 74        dnld_i2:acall    space
03F8: 12 0A A2              lcall   pint16u
03FB: 11 06                 acall   r6r7todptr
03FD: 11 45                 acall   pcstr_h
03FF: 22           dnld_i3:ret
                   
0400: 71 41        dnld_i0:acall    dnld_gp                 ;non-error conditio
0402: 80 F2                 sjmp    dnld_i2
                   
                   
                   dnld_init:
                            ;init all dnld parms to zero.
0404: 78 10                 mov     r0, #dnld_parm
0406: 76 00        dnld0:   mov     @r0, #0
0408: 08                    inc     r0
0409: B8 20 FA              cjne    r0, #dnld_parm + 16, dnld0
040C: 22                    ret
                   
                   
                   ;dnlds7:  = "Errors:"
                   ;dnlds8:  = " bytes unable to write"
                   ;dnlds9:  = " incorrect checksums"
                   ;dnlds10: = " unexpected begin of line"
                   ;dnlds11: = " unexpected hex digits"
                   ;dnlds12: = " unexpected non-hex digits"
                   ;dnlds13: = "No errors detected"
                   
                   
                   
                   ;---------------------------------------------------------;
                   
                   
                   jump:
040D: 90 0D F8              mov     dptr, #prompt8
0410: 11 45                 acall   pcstr_h
0412: 11 06                 acall   r6r7todptr
0414: 31 79                 acall   phex16
0416: 90 0D C6              mov     dptr, #prompt4
0419: 11 45                 acall   pcstr_h
041B: 11 D1                 acall   ghex16
041D: 20 D5 06              jb      psw.5, jump3
0420: 50 02                 jnc     jump2
0422: E1 05                 ajmp    abort2
                   jump2:
0424: 11 0E                 acall   dptrtor6r7
0426: 11 80        jump3:   acall   newline
0428: 90 0E D4              mov     dptr, #runs1
042B: 11 45                 acall   pcstr_h
042D: 11 06                 acall   r6r7todptr
                   
                   jump_doit:  ;jump to user code @dptr (this used by run comma
042F: E4                    clr     a
0430: F5 D0                 mov     psw, a
0432: F5 F0                 mov     b, a
0434: 78 07                 mov     r0, #7
0436: F6           jditclr:mov      @r0, a          ;clear r7 to r1
0437: D8 FD                 djnz    r0, jditclr     ;clear r0
0439: 75 81 08              mov     sp, #8          ;start w/ sp=7, like a real
043C: C0 E0                 push    acc             ;unlike a real reset, push 
043E: C0 E0                 push    acc             ;in case they end with a RE
0440: 73                    jmp     @a+dptr
                   
                   
                   ;---------------------------------------------------------;
                   
                   dump:    
0441: 7A 10                 mov     r2, #16                 ;number of lines to
0443: 11 7E                 acall   newline2
0445: 11 06        dump1:   acall   r6r7todptr
0447: 31 79                 acall   phex16          ;tell 'em the memory locati
0449: 74 3A                 mov     a,#':'
044B: 11 1E                 acall   cout_sp
044D: 7B 10                 mov     r3, #16                 ;r3 counts # of byt
044F: 11 06                 acall   r6r7todptr
0451: E4           dump2:   clr     a
0452: 93                    movc    a, @a+dptr
0453: A3                    inc     dptr
0454: 31 67                 acall   phex            ;print each byte in hex
0456: 11 74                 acall   space
0458: DB F7                 djnz    r3, dump2
045A: 11 72                 acall   dspace          ;print a couple extra space
045C: 7B 10                 mov     r3, #16
045E: 11 06                 acall   r6r7todptr
0460: E4           dump3:   clr     a
0461: 93                    movc    a, @a+dptr
0462: A3                    inc     dptr
0463: 54 7F                 anl     a, #01111111b   ;avoid unprintable characte
0465: B4 7F 01              cjne    a, #127, dump3b
0468: E4                    clr     a               ;avoid 127/255 (delete/rubo
0469: 24 E0        dump3b: add      a, #224
046B: 40 01                 jc      dump4
046D: E4                    clr     a               ;avoid control characters
046E: 24 20        dump4:   add     a, #32
0470: 11 76                 acall   cout
0472: DB EC                 djnz    r3, dump3
0474: 11 80                 acall   newline
0476: D1 C1                 acall   line_dly
0478: 11 0E                 acall   dptrtor6r7
047A: 31 BA                 acall   esc
047C: 40 02                 jc      dump5
047E: DA C5                 djnz    r2, dump1       ;loop back up to print next
0480: 01 80        dump5:   ajmp    newline
                   
                   ;---------------------------------------------------------;
                   
                   edit:       ;edit external ram...
0482: 90 0E 3A              mov     dptr, #edits1
0485: 11 45                 acall   pcstr_h
0487: 11 06                 acall   r6r7todptr
0489: 31 79        edit1:   acall   phex16
048B: 74 3A                 mov     a,#':'
048D: 11 1E                 acall   cout_sp
048F: 74 28                 mov     a,#'('
0491: 11 76                 acall   cout
0493: 11 0E                 acall   dptrtor6r7
0495: E4                    clr     a
0496: 93                    movc    a, @a+dptr
0497: 31 67                 acall   phex
0499: 90 0E 13              mov     dptr,#prompt10
049C: 11 45                 acall   pcstr_h
049E: 11 8D                 acall   ghex
04A0: 20 D5 10              jb      psw.5,edit2
04A3: 40 0E                 jc      edit2
04A5: 11 06                 acall   r6r7todptr
04A7: 12 08 22              lcall   smart_wr
04AA: 11 80                 acall   newline
04AC: 11 06                 acall   r6r7todptr
04AE: A3                    inc     dptr
04AF: 11 0E                 acall   dptrtor6r7
04B1: 81 89                 ajmp    edit1
04B3: 90 0E 45     edit2:   mov     dptr,#edits2
04B6: 01 45                 ajmp    pcstr_h
                   
                   ;---------------------------------------------------------;
                   
                   dir:
04B8: 90 0E 02              mov     dptr, #prompt9
04BB: 11 45                 acall   pcstr_h
04BD: 78 15                 mov     r0, #21
04BF: 11 74        dir0a:   acall   space
04C1: D8 FC                 djnz    r0, dir0a
                            ;mov    dptr, #prompt9b
04C3: 11 45                 acall   pcstr_h
                   
04C5: 75 83 10              mov     dph, #(bmem >> 8)
04C8: F1 F8        dir1:    acall   find            ;find the next program in m
04CA: 40 02                 jc      dir2
04CC: 01 80        dir_end:ajmp     newline                 ;we're done if no m
                   dir2:
04CE: 11 72                 acall   dspace
04D0: 75 82 20              mov     dpl, #32        ;print its name
04D3: 31 86                 acall   pstr
04D5: 75 82 20              mov     dpl, #32        ;how long is the name
04D8: 31 A7                 acall   lenstr
04DA: 74 21                 mov     a, #33
04DC: C3                    clr     c
04DD: 98                    subb    a, r0
04DE: F8                    mov     r0, a
04DF: 74 20                 mov     a, #' '                 ;print the right # 
04E1: 11 76        dir3:    acall   cout
04E3: D8 FC                 djnz    r0, dir3
04E5: 75 82 00              mov     dpl, #0
04E8: 31 79                 acall   phex16          ;print the memory location
04EA: 78 06                 mov     r0, #6
04EC: 74 20                 mov     a, #' '
04EE: 11 76        dir4:    acall   cout
04F0: D8 FC                 djnz    r0, dir4
04F2: 75 82 04              mov     dpl, #4                 ;now figure out wha
04F5: E4                    clr     a
04F6: 93                    movc    a, @a+dptr
04F7: AA 83                 mov     r2, dph                 ;save this, we're i
                   
04F9: B4 FE 05     dir5:    cjne    a, #254, dir5b
04FC: 90 0F 0C              mov     dptr, #type1    ;it's an external command
04FF: 80 18                 sjmp    dir7
0501: B4 FD 05     dir5b:   cjne    a, #253, dir5c
0504: 90 0F 13     dir5bb: mov      dptr, #type4    ;it's a startup routine
0507: 80 10                 sjmp    dir7
0509: B4 23 05     dir5c:   cjne    a, #35, dir5d
050C: 90 0F 10              mov     dptr, #type2    ;it's an ordinary program
050F: 80 08                 sjmp    dir7
0511: B4 F9 02     dir5d:   cjne    a, #249, dir5e
0514: 80 EE                 sjmp    dir5bb
                   dir5e:
0516: 90 0F 1A     dir6:    mov     dptr, #type5    ;who knows what the hell it
                   
0519: 11 45        dir7:    acall   pcstr_h                    ;print out the t
051B: 8A 83                 mov     dph, r2                 ;go back and find t
051D: 11 80                 acall   newline
051F: 74 7F                 mov     a, #(emem >> 8)
0521: B5 83 02              cjne    a, dph, dir8    ;did we just print the last
0524: 81 CC                 ajmp    dir_end
0526: 05 83        dir8:    inc     dph
0528: E5 83                 mov     a, dph
052A: B4 80 9B              cjne    a, #((emem+1) >> 8) & 255, dir1
052D: 81 CC                 ajmp    dir_end
                   
                   
                   ;type1=Ext Command
                   ;type4=Startup
                   ;type2=Program
                   ;type5=???
                   
                   ;---------------------------------------------------------;
                   
                   
                   run:   
052F: 11 7E                 acall   newline2
0531: 7A FF                 mov     r2, #255        ;first print the menu, coun
0533: 90 10 00              mov     dptr, #bmem
0536: 15 83                 dec     dph
0538: 05 83        run2:    inc     dph
053A: E5 83                 mov     a, dph
053C: B4 80 02              cjne    a, #((emem+1) >> 8) & 255, run2b
053F: 80 21                 sjmp    run3
0541: F1 F8        run2b:   acall   find
0543: 50 1D                 jnc     run3            ;have we found 'em all??
0545: 75 82 04              mov     dpl, #4
0548: E4                    clr     a
0549: 93                    movc    a, @a+dptr
054A: 44 03                 orl     a, #00000011b
054C: F4                    cpl     a
054D: 60 E9                 jz      run2            ;this one doesn't run... fi
054F: 11 72                 acall   dspace
0551: 0A                    inc     r2
0552: 74 41                 mov     a, #'A'                 ;print the key to p
0554: 2A                    add     a, r2
0555: 11 1E                 acall   cout_sp
0557: 11 26                 acall   dash_sp
0559: 75 82 20              mov     dpl, #32
055C: 31 86                 acall   pstr            ;and the command name
055E: 11 80                 acall   newline
0560: A1 38                 ajmp    run2            ;and continue doing this
0562: BA FF 05     run3:    cjne    r2, #255, run4  ;are there any to run??
0565: 90 0D CF              mov     dptr, #prompt5
0568: 01 45                 ajmp    pcstr_h
056A: 90 0D C1     run4:    mov     dptr, #prompt3  ;ask the big question!
056D: 11 45                 acall   pcstr_h
056F: 74 41                 mov     a, #'A'
0571: 11 76                 acall   cout
0573: 11 16                 acall   dash
0575: 74 41                 mov     a, #'A'                 ;such user friendli
0577: 2A                    add     a, r2           ;even tell 'em the choices
0578: 11 76                 acall   cout
057A: 90 0D C6              mov     dptr, #prompt4
057D: 11 45                 acall   pcstr_h
057F: 11 62                 acall   cin_filter_h
0581: B4 1B 02              cjne    a, #27, run4aa  ;they they hit <ESC>
0584: 01 80                 ajmp    newline
0586: FB           run4aa: mov      r3, a
0587: 74 1F                 mov     a, #31
0589: C3                    clr     c
058A: 9A                    subb    a, r2
058B: EB                    mov     a, r3
058C: 40 02                 jc      run4a
058E: 31 9A                 acall   upper
0590: 11 76        run4a:   acall   cout
0592: FB                    mov     r3, a
0593: 11 80                 acall   newline
                            ;check to see if it's under 32, if so convert to up
0595: EB                    mov     a, r3
0596: 24 BF                 add     a, #(256 - 'A')
0598: 50 D0                 jnc     run4            ;if they typed less than 'A
059A: FB                    mov     r3, a           ;R3 has the number they typ
059B: EA                    mov     a, r2           ;A=R2 has the maximum numbe
059C: C3                    clr     c
059D: 9B                    subb    a, r3
059E: 40 CA                 jc      run4            ;if they typed over the max
05A0: 0B                    inc     r3
05A1: 90 10 00              mov     dptr, #bmem
05A4: 15 83                 dec     dph
05A6: 05 83        run5:    inc     dph
05A8: E5 83                 mov     a, dph
05AA: B4 80 02              cjne    a, #((emem+1) >> 8) & 255, run5b
05AD: 80 17                 sjmp    run8
05AF: F1 F8        run5b:   acall   find
05B1: 50 13                 jnc     run8            ;Shouldn't ever do this jum
05B3: 75 82 04              mov     dpl, #4
05B6: E4                    clr     a
05B7: 93                    movc    a, @a+dptr
05B8: 44 03                 orl     a, #00000011b
05BA: F4                    cpl     a
05BB: 60 E9                 jz      run5            ;this one doesn't run... fi
05BD: DB E7                 djnz    r3, run5        ;count til we find the one 
05BF: 11 80                 acall   newline
05C1: 75 82 40              mov     dpl, #64
05C4: 81 2F                 ajmp    jump_doit
05C6: 22           run8:    ret
                   
                   ;---------------------------------------------------------;
                   
                   help:
05C7: 90 0E F4              mov     dptr, #help1txt
05CA: 11 45                 acall   pcstr_h
05CC: 7C 3F                 mov     r4, #help_key
05CE: 90 0F 21              mov     dptr, #help_cmd
05D1: D1 31                 acall   help2
05D3: 7C 4D                 mov     r4, #dir_key
                            ;mov     dptr, #dir_cmd
05D5: D1 31                 acall   help2
05D7: 7C 52                 mov     r4, #run_key
                            ;mov     dptr, #run_cmd
05D9: D1 31                 acall   help2
05DB: 7C 44                 mov     r4, #dnld_key
                            ;mov     dptr, #dnld_cmd
05DD: D1 31                 acall   help2
05DF: 7C 55                 mov     r4, #upld_key
                            ;mov     dptr, #upld_cmd
05E1: D1 31                 acall   help2
05E3: 7C 4E                 mov     r4, #nloc_key
                            ;mov     dptr, #nloc_cmd
05E5: D1 31                 acall   help2
05E7: 7C 4A                 mov     r4, #jump_key
                            ;mov     dptr, #jump_cmd
05E9: D1 31                 acall   help2
05EB: 7C 48                 mov     r4, #dump_key
                            ;mov     dptr, #dump_cmd
05ED: D1 31                 acall   help2
05EF: 7C 49                 mov     r4, #intm_key
                            ;mov    dptr, #intm_cmd
05F1: D1 31                 acall   help2
05F3: 7C 45                 mov     r4, #edit_key
                            ;mov     dptr, #edit_cmd
05F5: D1 31                 acall   help2
05F7: 7C 43                 mov     r4, #clrm_key
                            ;mov     dptr, #clrm_cmd
05F9: D1 31                 acall   help2
05FB: 74 00                 mov     a, #has_flash
05FD: 60 04                 jz      help_skerfm
05FF: 7C 5A                 mov     r4, #erfr_key
                            ;mov     dptr, #erfr_cmd
0601: D1 31                 acall   help2
                   help_skerfm:
0603: 90 0F 02              mov     dptr, #help2txt
0606: 11 45                 acall   pcstr_h
0608: 90 10 00              mov     dptr, #bmem
060B: F1 F8        help3:   acall   find
060D: 50 20                 jnc     help4
060F: 75 82 04              mov     dpl, #4
0612: E4                    clr     a
0613: 93                    movc    a,@a+dptr
0614: B4 FE 11              cjne    a, #254, help3a            ;only FE is an e
0617: 11 72                 acall   dspace
0619: 05 82                 inc     dpl
061B: E4                    clr     a
061C: 93                    movc    a,@a+dptr
061D: 11 76                 acall   cout
061F: 11 26                 acall   dash_sp
0621: 75 82 20              mov     dpl, #32
0624: 31 86                 acall   pstr
0626: 11 80                 acall   newline
0628: 05 83        help3a: inc      dph
062A: E5 83                 mov     a, dph
062C: B4 80 DC              cjne    a, #((emem+1) >> 8) & 255, help3
                   help4:   
062F: 01 80                 ajmp    newline
                   
                   help2:                           ;print 11 standard lines
0631: 11 72                 acall   dspace          ;given key in R4 and name i
0633: EC                    mov     a, r4
0634: 11 76                 acall   cout
0636: 11 26                 acall   dash_sp
0638: 11 45                 acall   pcstr_h
063A: 01 80                 ajmp    newline
                   
                   ;---------------------------------------------------------;
                   
                   upld:
                   
063C: D1 D3                 acall   get_mem
                            ;assume we've got the beginning address in r3/r2
                            ;and the final address in r5/r4 (r4=lsb)...
                   
                            ;print out what we'll be doing
063E: 90 0E DE              mov     dptr, #uplds3
0641: 11 45                 acall   pcstr_h
0643: EB                    mov     a, r3
0644: 31 67                 acall   phex
0646: EA                    mov     a, r2
0647: 31 67                 acall   phex
                            ;mov     dptr, #uplds4
0649: 11 45                 acall   pcstr_h
064B: ED                    mov     a, r5
064C: 31 67                 acall   phex
064E: EC                    mov     a, r4
064F: 31 67                 acall   phex
0651: 11 80                 acall   newline
                   
                            ;need to adjust end location by 1...
0653: 8D 83                 mov     dph, r5
0655: 8C 82                 mov     dpl, r4
0657: A3                    inc     dptr
0658: AC 82                 mov     r4, dpl
065A: AD 83                 mov     r5, dph
                   
065C: 90 0D EE              mov     dptr, #prompt7
065F: 11 45                 acall   pcstr_h
0661: 11 6A                 acall   cin
0663: B4 1B 02              cjne    a, #27, upld2e
0666: E1 03                 ajmp    abort_it
0668: 11 80        upld2e: acall    newline
066A: 8A 82                 mov     dpl, r2
066C: 8B 83                 mov     dph, r3
                   
066E: EC           upld3:   mov     a, r4           ;how many more bytes to out
066F: C3                    clr     c
0670: 95 82                 subb    a, dpl
0672: FA                    mov     r2, a
0673: ED                    mov     a, r5
0674: 95 83                 subb    a, dph
0676: 70 09                 jnz     upld4           ;if >256 left, then do next
0678: EA                    mov     a, r2
0679: 60 32                 jz      upld7           ;if we're all done
067B: 54 F0                 anl     a, #11110000b
067D: 70 02                 jnz     upld4           ;if >= 16 left, then do nex
067F: 80 02                 sjmp    upld5           ;otherwise just finish it o
0681: 7A 10        upld4:   mov     r2, #16
0683: 74 3A        upld5:   mov     a, #':'                 ;begin the line
0685: 11 76                 acall   cout
0687: EA                    mov     a, r2
0688: 31 67                 acall   phex            ;output # of data bytes
068A: 31 79                 acall   phex16          ;output memory location
068C: E5 83                 mov     a, dph
068E: 25 82                 add     a, dpl
0690: 2A                    add     a, r2
0691: FB                    mov     r3, a           ;r3 will become checksum
0692: E4                    clr     a
0693: 31 67                 acall   phex            ;output 00 code for data
0695: E4           upld6:   clr     a
0696: 93                    movc    a, @a+dptr
0697: 31 67                 acall   phex            ;output each byte
0699: 2B                    add     a, r3
069A: FB                    mov     r3, a
069B: A3                    inc     dptr
069C: DA F7                 djnz    r2, upld6       ;do however many bytes we n
069E: EB                    mov     a, r3
069F: F4                    cpl     a
06A0: 04                    inc     a
06A1: 31 67                 acall   phex            ;and finally the checksum
06A3: 11 80                 acall   newline
06A5: D1 C1                 acall   line_dly
06A7: 31 BA                 acall   esc
06A9: 50 C3                 jnc     upld3           ;keep working if no esc pre
06AB: 80 56                 sjmp    abort_it
06AD: 74 3A        upld7:   mov     a, #':'
06AF: 11 76                 acall   cout
06B1: E4                    clr     a
06B2: 31 67                 acall   phex
06B4: 31 67                 acall   phex
06B6: 31 67                 acall   phex
06B8: 04                    inc     a
06B9: 31 67                 acall   phex
06BB: 74 FF                 mov     a, #255
06BD: 31 67                 acall   phex
06BF: 01 7E        upld8:   ajmp    newline2
                   
                   
                   line_dly: ;a brief delay between line while uploading, so th
                            ;receiving host can be slow (i.e. most windows soft
06C1: E8                    mov     a, r0
06C2: C0 E0                 push    acc
06C4: 78 0C                 mov     r0, #line_delay*2
06C6: E5 8C        line_d2:mov      a, th0          ;get baud rate const
06C8: 04           line_d3:inc      a
06C9: 00                    nop
06CA: 00                    nop
06CB: 70 FB                 jnz     line_d3
06CD: D8 F7                 djnz    r0, line_d2
06CF: D0 E0                 pop     acc
06D1: F8                    mov     r0, a
06D2: 22                    ret
                   
                   ;---------------------------------------------------------;
                   
                   get_mem:     ;this thing gets the begin and end locations fo
                                 ;a few commands.  If an esc or enter w/ no inp
                                 ;it pops it's own return and returns to the me
                                 ;(nasty programming, but we need tight code fo
06D3: 11 7E                 acall   newline2
06D5: 90 0E 1C              mov     dptr, #beg_str
06D8: 11 45                 acall   pcstr_h
06DA: 11 D1                 acall   ghex16
06DC: 40 21                 jc      pop_it
06DE: 20 D5 1E              jb      psw.5, pop_it
06E1: C0 83                 push    dph
06E3: C0 82                 push    dpl
06E5: 11 80                 acall   newline
06E7: 90 0E 26              mov     dptr, #end_str
06EA: 11 45                 acall   pcstr_h
06EC: 11 D1                 acall   ghex16
06EE: AD 83                 mov     r5, dph
06F0: AC 82                 mov     r4, dpl
06F2: D0 E0                 pop     acc
06F4: FA                    mov     r2, a
06F5: D0 E0                 pop     acc
06F7: FB                    mov     r3, a
06F8: 40 05                 jc      pop_it
06FA: 20 D5 02              jb      psw.5, pop_it
06FD: 01 80                 ajmp    newline
                   
06FF: D0 E0        pop_it: pop      acc
0701: D0 E0                 pop     acc
                   abort_it:
0703: 11 80                 acall   newline
0705: 90 0D AE     abort2: mov      dptr, #abort
0708: 01 45                 ajmp    pcstr_h
                   
                   
                   clrm:
070A: D1 D3                 acall   get_mem
070C: 90 0E 30              mov     dptr, #sure
070F: 11 45                 acall   pcstr_h
0711: 11 62                 acall   cin_filter_h
0713: 31 9A                 acall   upper
0715: B4 59 EB              cjne    a, #'Y', abort_it
0718: 11 7E                 acall   newline2
                        ;now we actually do it
                   
071A: 8B 83        clrm2:   mov     dph, r3
071C: 8A 82                 mov     dpl, r2
071E: E4           clrm3:   clr     a
071F: 12 08 22              lcall   smart_wr
0722: ED                    mov     a, r5
0723: B5 83 05              cjne    a, dph, clrm4
0726: EC                    mov     a, r4
0727: B5 82 01              cjne    a, dpl, clrm4
072A: 22                    ret
072B: A3           clrm4:   inc     dptr
072C: 80 F0                 sjmp    clrm3
                   
                   ;---------------------------------------------------------;
                   
                   nloc:
072E: 90 0D E5              mov     dptr, #prompt6
0731: 11 45                 acall   pcstr_h
0733: 11 D1                 acall   ghex16
0735: 40 CE                 jc      abort2
0737: 20 D5 CB              jb      psw.5, abort2
073A: 11 0E                 acall   dptrtor6r7
073C: 01 7E                 ajmp    newline2
                   
                   ;---------------------------------------------------------;
                   
                   erfr:
073E: 11 7E                 acall   newline2
0740: 90 0F 54              mov     dptr, #erfr_cmd
0743: 11 45                 acall   pcstr_h
0745: 74 2C                 mov     a, #','
0747: 11 1E                 acall   cout_sp
0749: 90 0E 30              mov     dptr, #sure
074C: 11 45                 acall   pcstr_h
074E: 11 62                 acall   cin_filter_h
0750: 31 9A                 acall   upper
0752: B4 59 AE              cjne    a, #'Y', abort_it
0755: 11 7E                 acall   newline2
0757: 12 07 C1              lcall   erall
075A: 90 0F 59              mov     dptr, #erfr_ok
075D: 50 03                 jnc     erfr_end
075F: 90 0F 60              mov     dptr, #erfr_err
                   erfr_end:
0762: 01 45                 ajmp    pcstr_h
                   
                   
                   
                   ;---------------------------------------------------------;
                   
0764: 11 80        intm:    acall   newline
0766: 78 00                 mov     r0, #0
0768: 11 80        intm2:   acall   newline
076A: B8 80 02              cjne    r0, #0x80, intm3 
076D: 01 80                 ajmp    newline
076F: E8           intm3:   mov     a, r0
0770: 31 67                 acall   phex
0772: 74 3A                 mov     a, #':'
0774: 11 76                 acall   cout
0776: 11 74        intm4:   acall   space
0778: E6                    mov     a, @r0
0779: 31 67                 acall   phex
077B: 08                    inc     r0
077C: E8                    mov     a, r0
077D: 54 0F                 anl     a, #00001111b
077F: 70 F5                 jnz     intm4
0781: 80 E5                 sjmp    intm2
                   
                   
                   
                   
                   
                   ;***********************************************************
                   ;***********************************************************
                   ;*****                                                     *
                   ;*****        2k page boundry is somewhere near here       *
                   ;*****          (no ajmp or acall past this point)         *
                   ;*****                                                     *
                   ;***********************************************************
                   ;***********************************************************
                   
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;   Subroutines for memory managment and non-serial I/O    ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   
                   
                   
                            ; poll the flash rom using it's toggle bit feature
                            ; on D6... and wait until the flash rom is not busy
                            ; dptr must be initialized with the address to read
                   flash_wait:
0783: C0 F0                 push    b
0785: E4                    clr     a
0786: 93                    movc    a, @a+dptr
0787: F5 F0        flwt2:   mov     b, a
0789: 0D                    inc     r5
078A: E4                    clr     a
078B: 93                    movc    a, @a+dptr
078C: B5 F0 F8              cjne    a, b, flwt2
078F: D0 F0                 pop     b
0791: 22                    ret
                   
                            ;send the flash enable codes
                   flash_en:
0792: 90 D5 55              mov     dptr, #flash_en1_addr
0795: 74 AA                 mov     a, #flash_en1_data
0797: F0                    movx    @dptr, a
0798: 90 AA AA              mov     dptr, #flash_en2_addr
079B: 74 55                 mov     a, #flash_en2_data
079D: F0                    movx    @dptr, a
079E: 22                    ret
                   
                   
                   ;a routine that writes ACC to into flash memory at DPTR
                   ; C is set if error occurs, C is clear if it worked
                   
079F: C8           prgm:    xch     a, r0
07A0: C0 E0                 push    acc
07A2: C0 82                 push    dpl
07A4: C0 83                 push    dph
07A6: F1 92                 acall   flash_en                ;do first step, ena
07A8: 90 D5 55              mov     dptr, #flash_wr_addr
07AB: 74 A0                 mov     a, #flash_wr_data
07AD: F0                    movx    @dptr, a                ;send flash write c
07AE: D0 83                 pop     dph
07B0: D0 82                 pop     dpl
07B2: E8                    mov     a, r0
07B3: F0                    movx    @dptr, a                ;write the data
07B4: F1 83                 acall   flash_wait              ;wait until it's do
07B6: E4                    clr     a
07B7: 93                    movc    a, @a+dptr              ;read it back
07B8: C3                    clr     c
07B9: 68                    xrl     a, r0
07BA: 60 01                 jz      prgmend                         ;check if d
07BC: D3                    setb    c
07BD: D0 E0        prgmend:pop      acc
07BF: C8                    xch     a, r0
07C0: 22                    ret
                   
                   ; erase the entire flash rom
                   ; C=1 if failure, C=0 if ok
                   
                   erall:
07C1: 90 D5 55              mov     dptr, #flash_er2_addr
07C4: 74 10                 mov     a, #flash_er2_data
07C6: F1 DF                 acall   erblock                         ;use erbloc
07C8: 90 80 00              mov     dptr, #bflash
07CB: E4           erall2:  clr     a
07CC: 93                    movc    a, @a+dptr              ;read back flash me
07CD: F4                    cpl     a
07CE: 70 0D                 jnz     erall_err               ;check if it's real
07D0: A3                    inc     dptr
07D1: 74 00                 mov     a, #((eflash+1) & 255)
07D3: B5 82 F5              cjne    a, dpl, erall2
07D6: 74 00                 mov     a, #(((eflash+1) >> 8) & 255)
07D8: B5 83 F0              cjne    a, dph, erall2
07DB: C3                    clr     c
07DC: 22                    ret
                   erall_err:
07DD: D3                    setb    c
07DE: 22                    ret
                   
                   
                            ;send a custom erase command.  This is used by eral
                            ;and it's intended to be callable from the flash me
                            ;so that custom block erase code can be implemented
                   erblock:
07DF: C0 E0                 push    acc
07E1: C0 82                 push    dpl
07E3: C0 83                 push    dph
07E5: F1 92                 acall   flash_en                ;send flash enable 
07E7: 90 D5 55              mov     dptr, #flash_er1_addr
07EA: 74 80                 mov     a, #flash_er1_data
07EC: F0                    movx    @dptr, a                ;send erase enable
07ED: F1 92                 acall   flash_en                ;send flash enable 
07EF: D0 83                 pop     dph
07F1: D0 82                 pop     dpl
07F3: D0 E0                 pop     acc
07F5: F0                    movx    @dptr, a                ;send erase command
07F6: E1 83                 ajmp    flash_wait
                   
                   
                   
                   
                   ;finds the next header in the external memory.
                   ;  Input DPTR=point to start search (only MSB used)
                   ;  Output DPTR=location of next module
                   ;    C=set if a header found, C=clear if no more headers
07F8: 75 82 00     find:    mov     dpl, #0
07FB: E4                    clr     a
07FC: 93                    movc    a, @a+dptr
07FD: B4 A5 17              cjne    a, #0xA5, find3
0800: A3                    inc     dptr
0801: E4                    clr     a
0802: 93                    movc    a, @a+dptr
0803: B4 E5 11              cjne    a, #0xE5, find3
0806: A3                    inc     dptr
0807: E4                    clr     a
0808: 93                    movc    a, @a+dptr
0809: B4 E0 0B              cjne    a, #0xE0, find3
080C: A3                    inc     dptr
080D: E4                    clr     a
080E: 93                    movc    a, @a+dptr
080F: B4 A5 05              cjne    a, #0xA5, find3
0812: 75 82 00              mov     dpl, #0                         ;found one 
0815: D3                    setb    c
0816: 22                    ret
0817: 74 7F        find3:   mov     a, #(emem >> 8)
0819: B5 83 02              cjne    a, dph, find4           ;did we just check 
081C: C3                    clr     c
081D: 22                    ret
081E: 05 83        find4:   inc     dph                     ;keep on searching
0820: 80 D6                 sjmp    find
                   
                   
                   
                   
                   ;************************************
                   ;To make PAULMON2 able to write to other
                   ;types of memory than RAM and flash rom,
                   ;modify this "smart_wr" routine.  This
                   ;code doesn't accept any inputs other
                   ;that the address (dptr) and value (acc),
                   ;so this routine must know which types
                   ;of memory are in what address ranges
                   ;************************************
                   
                   
                   ;Write to Flash ROM or ordinary RAM.  Carry bit will indicat
                   ;if the value was successfully written, C=1 if not written.
                   
                   
                   smart_wr:
0822: C0 E0                 push    acc
0824: C0 F0                 push    b
0826: F5 F0                 mov     b, a
                            ;do we even have a flash rom?
0828: 74 00                 mov     a, #has_flash
082A: 60 10                 jz      wr_ram
                            ;there is a flash rom, but is this address in it?
082C: E5 83                 mov     a, dph
082E: B4 FF 02              cjne    a, #(eflash >> 8), isfl3
0831: 80 22                 sjmp    wr_flash
0833: 50 07        isfl3:   jnc     wr_ram
0835: B4 80 02              cjne    a, #(bflash >> 8), isfl4
0838: 80 1B                 sjmp    wr_flash
083A: 50 19        isfl4:   jnc     wr_flash
                            ;sjmp   wr_ram
                   
083C: E5 F0        wr_ram: mov      a, b
083E: F0                    movx    @dptr, a        ;write the value to memory
083F: E4                    clr     a
0840: 93                    movc    a, @a+dptr      ;read it back from code mem
0841: C3                    clr     c
0842: 95 F0                 subb    a, b
0844: 60 09                 jz      smwrok
0846: E0                    movx    a, @dptr        ;read it back from data mem
0847: C3                    clr     c
0848: 95 F0                 subb    a, b
084A: 60 03                 jz      smwrok
084C: D3           smwrbad:setb     c
084D: 80 01                 sjmp    smwrxit
084F: C3           smwrok: clr      c
0850: D0 F0        smwrxit:pop      b
0852: D0 E0                 pop     acc
0854: 22                    ret
                   
                   wr_flash:
0855: E5 F0                 mov     a, b
0857: 12 07 9F              lcall   prgm
085A: D0 F0                 pop     b
085C: D0 E0                 pop     acc
085E: 22                    ret
                   
                   
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;        Power-On initialization code and such...          ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   ;first the hardware has to get initialized.
                   
                   intr_return:
085F: 32                    reti
                   
                   poweron:
0860: E4                    clr     a
0861: F5 A8                 mov     ie, a           ;all interrupts off
0863: F5 B8                 mov     ip, a
0865: 75 D0 00              mov     psw, #psw_init
                            ;clear any interrupt status, just in case the user 
                            ;"ljmp 0" inside their interrupt service code.
0868: 11 5F                 acall   intr_return
086A: 11 5F                 acall   intr_return
086C: F4                    cpl     a
086D: F5 80                 mov     p0, a
086F: F5 90                 mov     p1, a
0871: F5 A0                 mov     p2, a
0873: F5 B0                 mov     p3, a
0875: 75 81 30              mov     sp, #stack
                   
                   ;Before we start doing any I/O, a short delay is required so
                   ;that any external hardware which may be in "reset mode" can
                   ;initialize.  This is typically a problem when a 82C55 chip
                   ;is used and its reset line is driven from the R-C reset
                   ;circuit used for the 8051.  Because the 82C55 reset pin
                   ;switches from zero to one at a higher voltage than the 8051
                   ;any 82C55 chips would still be in reset mode right now...
                   
                   rst_dly:
0878: 79 C8                 mov     r1, #200        ;approx 100000 cycles
087A: 7A F9        rdly2:   mov     r2, #249        ;500 cycles
087C: DA FE                 djnz    r2, *
087E: D9 FA                 djnz    r1, rdly2
                   
                   ;Check for the Erase-on-startup signal and erase Flash ROM 
                   ;if it's there.
                   
0880: 74 00                 mov     a, #has_flash
0882: 60 13                 jz      skip_erase
0884: 74 00                 mov     a, #erase_pin
0886: 60 0F                 jz      skip_erase
0888: 78 FA                 mov     r0, #250        ;check it 250 times, just t
                   chk_erase:
088A: A2 00                 mov     c, erase_pin
088C: 79 C8                 mov     r1, #200
088E: D9 FE                 djnz    r1, *           ;short delay
0890: 40 05                 jc      skip_erase      ;skip erase if this bit is 
0892: D8 F6                 djnz    r0, chk_erase
0894: 12 07 C1              lcall   erall           ;and this'll delete the fla
                   skip_erase:
                   
                   ;run any user initialization programs in external memory
0897: 75 F0 F9              mov     b, #249
089A: 11 C9                 acall   stcode
                   
                   ;initialize the serial port, auto baud detect if necessary
089C: 11 F6                 acall   autobaud        ;set up the serial port
                            ;mov    a, th1
                            ;lcall  phex
                   
                   ;run the start-up programs in external memory.
089E: 75 F0 FD              mov     b, #253
08A1: 11 C9                 acall   stcode
                   
                   ;now print out the nice welcome message
                   
                   welcome:
08A3: 78 18                 mov     r0, #24
08A5: 12 00 80     welcm2: lcall    newline
08A8: D8 FB                 djnz    r0, welcm2
08AA: 78 0F                 mov     r0, #15
08AC: 74 20                 mov     a, #' '
08AE: 12 00 76     welcm4: lcall    cout
08B1: D8 FB                 djnz    r0, welcm4
08B3: 90 0D 77              mov     dptr, #logon1
08B6: 12 0B 15              lcall   pcstr
08B9: 90 0D 90              mov     dptr, #logon2
08BC: 12 0B 15              lcall   pcstr
08BF: 12 04 B8              lcall   dir
08C2: 7E 00                 mov     r6, #(pgm & 255)
08C4: 7F 20                 mov     r7, #(pgm >> 8)
08C6: 02 01 CB              ljmp    menu
                   
                   
08C9: 90 10 00     stcode: mov      dptr, #bmem      ;search for startup routin
08CC: 12 07 F8     stcode2:lcall    find
08CF: 50 24                 jnc     stcode5
08D1: 75 82 04              mov     dpl, #4
08D4: E4                    clr     a
08D5: 93                    movc    a, @a+dptr
08D6: B5 F0 15              cjne    a, b, stcode4   ;only startup code if match
08D9: C0 F0                 push    b
08DB: C0 83                 push    dph
08DD: 74 EA                 mov     a, #(stcode3 & 255)
08DF: C0 E0                 push    acc
08E1: 74 08                 mov     a, #(stcode3 >> 8)
08E3: C0 E0                 push    acc
08E5: 75 82 40              mov     dpl, #64
08E8: E4                    clr     a
08E9: 73                    jmp     @a+dptr                 ;jump to the startu
08EA: D0 83        stcode3:pop      dph             ;hopefully it'll return to 
08EC: D0 F0                 pop     b
08EE: 05 83        stcode4:inc      dph
08F0: E5 83                 mov     a, dph
08F2: B4 80 D7              cjne    a, #((emem+1) >> 8) & 255, stcode2
08F5: 22           stcode5:ret                      ;now we've executed all of 
                   
                   
                   ;to do automatic baud rate detection, we assume the user wil
                   ;press the carriage return, which will cause this bit patter
                   ;to appear on port 3 pin 0 (CR = ascii code 13, assume 8N1 f
                   ;
                   ;               0 1 0 1 1 0 0 0 0 1
                   ;               | |             | |
                   ; start bit----+ +--lsb    msb--+ +----stop bit
                   ;
                   ;we'll start timer #1 in 16 bit mode at the transition betwe
                   ;start bit and the LSB and stop it between the MBS and stop 
                   ;That will give approx the number of cpu cycles for 8 bits. 
                   ;by 8 for one bit and by 16 since the built-in UART takes 16
                   ;overflows for each bit.  We need to be careful about roundo
                   ;division and the result has to be inverted since timer #1 c
                   ;course, timer #1 gets used in 8-bit auto reload mode for ge
                   ;built-in UART's baud rate once we know what the reload valu
                   
                   
                   autobaud:
08F6: 74 D0                 mov     a, #baud_const  ;skip if user supplied baud
08F8: 70 14                 jnz     autoend_jmp
08FA: E5 7B                 mov     a, baud_save+3  ;is there a value from a pr
08FC: 63 7A 55              xrl     baud_save+2, #01010101b
08FF: 63 79 CC              xrl     baud_save+1, #11001100b
0902: 63 78 1D              xrl     baud_save+0, #00011101b
0905: B5 7A 08              cjne    a, baud_save+2, autob1
0908: B5 79 05              cjne    a, baud_save+1, autob1
090B: B5 78 02              cjne    a, baud_save+0, autob1
                   autoend_jmp:
090E: 21 BC                 ajmp    autoend
                   
                   autob1: ;wait for inactivity
                   
0910: 75 87 80              mov     pcon, #0x80     ;configure uart, fast baud
0913: 75 98 42              mov     scon, #0x42     ;configure uart, but receiv
0916: 75 89 11              mov     tmod, #0x11     ;get timers ready for actio
0919: E4                    clr     a
091A: F5 88                 mov     tcon, a
091C: F5 8A                 mov     tl0, a
091E: F5 8C                 mov     th0, a
0920: F5 8B                 mov     tl1, a
0922: F5 8D                 mov     th1, a
                   
                            ;make sure there is no activity on the line
                            ;before we actually begin looking for the carriage 
0924: 78 C8                 mov     r0, #200
0926: 79 1E        autob1b:mov      r1, #30
0928: 30 B0 E5     autob1c:jnb      p3.0, autob1
092B: D9 FB                 djnz    r1, autob1c
092D: D8 F7                 djnz    r0, autob1b
                   
                   autob2: ;look for the bits of the carriage return
092F: 20 B0 FD              jb      p3.0, autob2    ;wait for start bit
0932: 20 B0 FA              jb      p3.0, autob2
0935: 20 B0 F7              jb      p3.0, autob2    ;  check it a few more time
0938: 20 B0 F4              jb      p3.0, autob2    ;  sure we don't trigger on
093B: 20 B0 F1              jb      p3.0, autob2
093E: 30 B0 FD     autob2b:jnb      p3.0, autob2b   ;wait for bit #0 to begin
0941: D2 8E                 setb    tr1             ;and now we're timing it
0943: 20 8F CA     autob2c:jb       tf1, autob1     ;check for timeout while wa
0946: 20 B0 FA              jb      p3.0, autob2c   ;wait for bit #1 to begin
0949: 20 8F C4     autob2d:jb       tf1, autob1     ;check for timeout while wa
094C: 30 B0 FA              jnb     p3.0, autob2d   ;wait for bit #2 to begin
094F: 20 8F BE     autob2e:jb       tf1, autob1     ;check for timeout while wa
0952: 20 B0 FA              jb      p3.0, autob2e   ;wait for bit #4 to begin
0955: D2 8C                 setb    tr0             ;start timing last 4 bits
0957: 20 8F B6     autob2f:jb       tf1, autob1     ;check for timeout while wa
095A: 30 B0 FA              jnb     p3.0, autob2f   ;wait for stop bit to begin
095D: C2 8E                 clr     tr1             ;stop timing (both timers)
095F: C2 8C                 clr     tr0
                   
0961: 20 8F AC              jb      tf1, autob1     ;check for timeout one last
                   
                            ;compute the baud rate based on timer1
0964: E5 8B                 mov     a, tl1
0966: 33                    rlc     a
0967: F5 F0                 mov     b, a
0969: E5 8D                 mov     a, th1
096B: 33                    rlc     a
096C: 40 A2                 jc      autob1          ;error if timer0 > 32767
096E: A2 F7                 mov     c, b.7
0970: 34 00                 addc    a, #0
0972: F4                    cpl     a
0973: 04                    inc     a               ;now a has the value to loa
0974: 60 9A                 jz      autob1          ;error if baud rate too fas
                   
                            ;after we get the carriage return, we need to make 
                            ;isn't any "crap" on the serial line, as there is i
                            ;were we get the letter E (and conclude the wrong b
                            ;unfortunately the simple approach of just looking 
                            ;for silence doesn't work, because we have to accep
                            ;where the user's terminal emulation is configured 
                            ;line feed after the carriage return.  The best thi
                            ;use the uart and look see if it receives anything
                   
0976: F5 8D        autob3: mov      th1, a          ;config timer1
0978: 75 8B FF              mov     tl1, #255       ;start asap!
097B: 75 89 21              mov     tmod, #0x21     ;autoreload mode
097E: D2 9C                 setb    ren             ;turn on the uart
0980: D2 8E                 setb    tr1             ;turn on timer1 for its clo
                   
0982: E5 8D                 mov     a, th1
0984: F4                    cpl     a
0985: 04                    inc     a
0986: F9                    mov     r1, a
0987: 78 FF        autob3b:mov      r0, #255
0989: D8 FE        autob3c:djnz     r0, autob3c
098B: D9 FA                 djnz    r1, autob3b
                   
098D: 30 98 11              jnb     ri, autob4
                            ;if we got here, there was some stuff after the car
                            ;return, so we'll read it and see if it was the lin
0990: C2 98                 clr     ri
0992: E5 99                 mov     a, sbuf
0994: 54 7F                 anl     a, #01111111b
0996: 24 F6                 add     a, #246
0998: 60 07                 jz      autob4          ;ok if 0A, the line feed ch
099A: 24 05                 add     a, #5
099C: 60 03                 jz      autob4          ;of if 05, since we may hav
                   autob1_jmp:
099E: 02 09 10              ljmp    autob1
                   autob4:
                            ;compute the baud rate based on timer0, check again
09A1: E5 8A                 mov     a, tl0
09A3: 33                    rlc     a
09A4: F8                    mov     r0, a
09A5: E5 8C                 mov     a, th0
09A7: 33                    rlc     a
09A8: F9                    mov     r1, a
09A9: 40 F3                 jc      autob1_jmp      ;error if timer0 > 32767
09AB: E8                    mov     a, r0
09AC: 33                    rlc     a
09AD: F5 F0                 mov     b, a
09AF: E9                    mov     a, r1
09B0: 33                    rlc     a
09B1: A2 F7                 mov     c, b.7
09B3: 34 00                 addc    a, #0
09B5: 60 E7                 jz      autob1_jmp      ;error if baud too fast!
09B7: F4                    cpl     a
09B8: 04                    inc     a
09B9: B5 8D E2              cjne    a, th1, autob1_jmp
                            ;acc has th1 value at this point
                   
09BC: F5 7B        autoend:mov      baud_save+3, a
09BE: F5 7A                 mov     baud_save+2, a  ;store the baud rate for ne
09C0: F5 79                 mov     baud_save+1, a
09C2: F5 78                 mov     baud_save+0, a
09C4: 63 7A 55              xrl     baud_save+2, #01010101b
09C7: 63 79 CC              xrl     baud_save+1, #11001100b 
09CA: 63 78 1D              xrl     baud_save+0, #00011101b 
09CD: F5 8D                 mov     th1, a
09CF: F5 8B                 mov     tl1, a
09D1: 75 89 21              mov     tmod, #0x21     ;set timer #1 for 8 bit aut
09D4: 75 87 80              mov     pcon, #0x80     ;configure built-in uart
09D7: 75 98 52              mov     scon, #0x52
09DA: D2 8E                 setb    tr1             ;start the baud rate timer
09DC: 22                    ret
                   
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;     More subroutines, but less frequent used, so         ;
                   ;     they're down here in the second 2k page.             ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   
                   
                   ;this twisted bit of code looks for escape sequences for
                   ;up, down, left, right, pageup, and pagedown, as well
                   ;as ordinary escape and ordinary characters.  Escape
                   ;sequences are required to arrive with each character
                   ;nearly back-to-back to the others, otherwise the characters
                   ;are treated as ordinary user keystroaks.  cin_filter
                   ;returns a single byte when it sees the multi-byte escape
                   ;sequence, as shown here.
                   
                   ; return value    key          escape sequence
                   ;   11 (^K)       up           1B 5B 41
                   ;   10 (^J)       down         1B 5B 42
                   ;   21 (^U)       right        1B 5B 43
                   ;    8 (^H)       left         1B 5B 44
                   ;   25 (^Y)       page up      1B 5B 35 7E
                   ;   26 (^Z)       page down    1B 5B 36 7E
                   
09DD:              .equ     esc_char, 27
                   
                   cin_filter:
09DD: 30 98 06              jnb     ri, cinf1
09E0: 12 00 6A              lcall   cin
09E3: B4 1B 51              cjne    a, #esc_char, cinf_end
                            ;if esc was already in sbuf, just ignore it
09E6: 12 00 6A     cinf1:   lcall   cin
09E9: B4 1B 4B              cjne    a, #esc_char, cinf_end
09EC: 51 4B        cinf2:   acall   cinf_wait
09EE: 20 98 03              jb      ri, cinf4
09F1: 74 1B                 mov     a, #esc_char
09F3: 22                    ret                     ;an ordinary ESC
                   
                   cinf4:   ;if we get here, it's a control code, since a chara
                            ;was received shortly after receiving an ESC charac
09F4: 12 00 6A              lcall   cin
09F7: B4 5B 44              cjne    a, #'[', cinf_consume
09FA: 51 4B                 acall   cinf_wait
09FC: 30 98 DE              jnb     ri, cin_filter
09FF: 12 00 6A              lcall   cin
0A02: B4 41 03     cinf5a: cjne     a, #'A', cinf5b
0A05: 74 0B                 mov     a, #11
0A07: 22                    ret
0A08: B4 42 03     cinf5b: cjne     a, #'B', cinf5c
0A0B: 74 0A                 mov     a, #10
0A0D: 22                    ret
0A0E: B4 43 03     cinf5c: cjne     a, #'C', cinf5d
0A11: 74 15                 mov     a, #21
0A13: 22                    ret
0A14: B4 44 03     cinf5d: cjne     a, #'D', cinf5e
0A17: 74 08                 mov     a, #8
0A19: 22                    ret
0A1A: B4 35 02     cinf5e: cjne     a, #0x35, cinf5f
0A1D: 80 07                 sjmp    cinf8
0A1F: B4 36 02     cinf5f: cjne     a, #0x36, cinf5g
0A22: 80 02                 sjmp    cinf8
0A24: 80 18        cinf5g: sjmp     cinf_consume            ;unknown escape seq
                   
                   cinf8:   ;when we get here, we've got the sequence for pageu
                            ;but there's one more incoming byte to check...
0A26: C0 E0                 push    acc
0A28: 51 4B                 acall   cinf_wait
0A2A: 30 98 0B              jnb     ri, cinf_restart
0A2D: 12 00 6A              lcall   cin
0A30: B4 7E 09              cjne    a, #0x7E, cinf_notpg
0A33: D0 E0                 pop     acc
0A35: 24 E4                 add     a, #228
0A37: 22           cinf_end: ret
                   cinf_restart:
0A38: D0 E0                 pop     acc
0A3A: 80 A1                 sjmp    cin_filter
                   cinf_notpg:
0A3C: D0 E0                 pop     acc
                   ;unrecognized escape... eat up everything that's left coming
                   ;quickly, then begin looking again
                   cinf_consume:
0A3E: 51 4B                 acall   cinf_wait
0A40: 30 98 9A              jnb     ri, cin_filter
0A43: 12 00 6A              lcall   cin
0A46: B4 1B F5              cjne    a, #esc_char, cinf_consume
0A49: 80 A1                 sjmp    cinf2
                   
                   ;this thing waits for a character to be received for approx
                   ;4 character transmit time periods.  It returns immedately
                   ;or after the entire wait time.   It does not remove the cha
                   ;from the buffer, so ri should be checked to see if somethin
                   ;actually did show up while it was waiting
0A4B:                       .equ    char_delay, 4           ;number of char xmi
                   cinf_wait:
0A4B: EA                    mov     a, r2
0A4C: C0 E0                 push    acc
0A4E: 7A 14                 mov     r2, #char_delay*5
0A50: E5 8C        cinfw2: mov      a, th0
0A52: 20 98 05     cinfw3: jb       ri, cinfw4
0A55: 04                    inc     a
0A56: 70 FA                 jnz     cinfw3
0A58: DA F6                 djnz    r2, cinfw2
0A5A: D0 E0        cinfw4: pop      acc
0A5C: FA                    mov     r2, a
0A5D: 22                    ret
                   
                   
                   
                   
                   pint8u: ;prints the unsigned 8 bit value in Acc in base 10
0A5E: C0 F0                 push    b
0A60: C0 E0                 push    acc
0A62: 80 13                 sjmp    pint8b
                   
                   pint8:   ;prints the signed 8 bit value in Acc in base 10
0A64: C0 F0                 push    b
0A66: C0 E0                 push    acc
0A68: 30 E7 0C              jnb     acc.7, pint8b
0A6B: 74 2D                 mov     a, #'-'
0A6D: 12 00 76              lcall   cout
0A70: D0 E0                 pop     acc
0A72: C0 E0                 push    acc
0A74: F4                    cpl     a
0A75: 24 01                 add     a, #1
0A77: 75 F0 64     pint8b: mov      b, #100
0A7A: 84                    div     ab
0A7B: D2 D5                 setb    f0
0A7D: 60 07                 jz      pint8c
0A7F: C2 D5                 clr     f0
0A81: 24 30                 add     a, #'0'
0A83: 12 00 76              lcall   cout
0A86: E5 F0        pint8c: mov      a, b
0A88: 75 F0 0A              mov     b, #10
0A8B: 84                    div     ab
0A8C: 30 D5 02              jnb     f0, pint8d
0A8F: 60 05                 jz      pint8e
0A91: 24 30        pint8d: add      a, #'0'
0A93: 12 00 76              lcall   cout
0A96: E5 F0        pint8e: mov      a, b
0A98: 24 30                 add     a, #'0'
0A9A: 12 00 76              lcall   cout
0A9D: D0 E0                 pop     acc
0A9F: D0 F0                 pop     b
0AA1: 22                    ret
                   
                   
                   
                            ;print 16 bit unsigned integer in DPTR, using base 
                   pint16u:         ;warning, destroys r2, r3, r4, r5, psw.5
0AA2: C0 E0                 push    acc
0AA4: E8                    mov     a, r0
0AA5: C0 E0                 push    acc
0AA7: C2 D5                 clr     psw.5
0AA9: AA 82                 mov     r2, dpl
0AAB: AB 83                 mov     r3, dph
                   
0AAD: 7C 10        pint16a:mov      r4, #16                 ;ten-thousands digi
0AAF: 7D 27                 mov     r5, #39
0AB1: 71 00                 acall   pint16x
0AB3: 60 07                 jz      pint16b
0AB5: 24 30                 add     a, #'0'
0AB7: 12 00 76              lcall   cout
0ABA: D2 D5                 setb    psw.5
                   
0ABC: 7C E8        pint16b:mov      r4, #232        ;thousands digit
0ABE: 7D 03                 mov     r5, #3
0AC0: 71 00                 acall   pint16x
0AC2: 70 03                 jnz     pint16c
0AC4: 30 D5 07              jnb     psw.5, pint16d
0AC7: 24 30        pint16c:add      a, #'0'
0AC9: 12 00 76              lcall   cout
0ACC: D2 D5                 setb    psw.5
                   
0ACE: 7C 64        pint16d:mov      r4, #100        ;hundreds digit
0AD0: 7D 00                 mov     r5, #0
0AD2: 71 00                 acall   pint16x
0AD4: 70 03                 jnz     pint16e
0AD6: 30 D5 07              jnb     psw.5, pint16f
0AD9: 24 30        pint16e:add      a, #'0'
0ADB: 12 00 76              lcall   cout
0ADE: D2 D5                 setb    psw.5
                   
0AE0: EA           pint16f:mov      a, r2           ;tens digit
0AE1: AB F0                 mov     r3, b
0AE3: 75 F0 0A              mov     b, #10
0AE6: 84                    div     ab
0AE7: 70 03                 jnz     pint16g
0AE9: 30 D5 05              jnb     psw.5, pint16h
0AEC: 24 30        pint16g:add      a, #'0'
0AEE: 12 00 76              lcall   cout
                   
0AF1: E5 F0        pint16h:mov      a, b            ;and finally the ones digit
0AF3: 8B F0                 mov     b, r3
0AF5: 24 30                 add     a, #'0'
0AF7: 12 00 76              lcall   cout
                   
0AFA: D0 E0                 pop     acc
0AFC: F8                    mov     r0, a
0AFD: D0 E0                 pop     acc
0AFF: 22                    ret
                   
                   ;ok, it's a cpu hog and a nasty way to divide, but this code
                   ;requires only 21 bytes!  Divides r2-r3 by r4-r5 and leaves
                   ;quotient in r2-r3 and returns remainder in acc.  If Intel
                   ;had made a proper divide, then this would be much easier.
                   
0B00: 78 00        pint16x:mov      r0, #0
0B02: 08           pint16y:inc      r0
0B03: C3                    clr     c
0B04: EA                    mov     a, r2
0B05: 9C                    subb    a, r4
0B06: FA                    mov     r2, a
0B07: EB                    mov     a, r3
0B08: 9D                    subb    a, r5
0B09: FB                    mov     r3, a
0B0A: 50 F6                 jnc     pint16y
0B0C: 18                    dec     r0
0B0D: EA                    mov     a, r2
0B0E: 2C                    add     a, r4
0B0F: FA                    mov     r2, a
0B10: EB                    mov     a, r3
0B11: 3D                    addc    a, r5
0B12: FB                    mov     r3, a
0B13: E8                    mov     a, r0
0B14: 22                    ret
                   
                   
                   
                   ;pcstr prints the compressed strings.  A dictionary of 128 w
                   ;stored in 4 bit packed binary format.   When pcstr finds a 
                   ;a string with the high bit set, it prints the word from the
                   ;A few bytes have special functions and everything else prin
                   ;it were an ordinary string.
                   
                   ; special codes for pcstr:
                   ;    0 = end of string
                   ;   13 = CR/LF
                   ;   14 = CR/LF and end of string
                   ;   31 = next word code should be capitalized
                   
0B15: C0 E0        pcstr:   push    acc
0B17: E8                    mov     a, r0
0B18: C0 E0                 push    acc
0B1A: E9                    mov     a, r1
0B1B: C0 E0                 push    acc
0B1D: EC                    mov     a, r4
0B1E: C0 E0                 push    acc
0B20: D2 D1                 setb    psw.1
0B22: D2 D5                 setb    psw.5
0B24: E4           pcstr1: clr      a
0B25: 93                    movc    a, @a+dptr
0B26: A3                    inc     dptr
0B27: 60 25                 jz      pcstr2
0B29: 20 E7 2E              jb      acc.7, decomp
0B2C: 54 7F                 anl     a, #0x7F
0B2E: B4 0D 07     pcstrs1:cjne     a, #13, pcstrs2
0B31: 12 00 80              lcall   newline
0B34: D2 D1                 setb    psw.1
0B36: 80 EC                 sjmp    pcstr1
0B38: B4 1F 04     pcstrs2:cjne     a, #31, pcstrs3
0B3B: C2 D5                 clr     psw.5
0B3D: 80 E5                 sjmp    pcstr1
0B3F: B4 0E 05     pcstrs3:cjne     a, #14, pcstrs4
0B42: 12 00 80              lcall   newline
0B45: 80 07                 sjmp    pcstr2
                   pcstrs4:
0B47: C2 D1                 clr     psw.1
0B49: 12 00 76              lcall   cout
0B4C: 80 D6                 sjmp    pcstr1
0B4E: D0 E0        pcstr2: pop      acc
0B50: FC                    mov     r4, a
0B51: D0 E0                 pop     acc
0B53: F9                    mov     r1, a
0B54: D0 E0                 pop     acc
0B56: F8                    mov     r0, a
0B57: D0 E0                 pop     acc
0B59: 22                    ret
                   
                   ;dcomp actually takes care of printing a word from the dicti
                   
                   ; dptr = position in packed words table
                   ; r4=0 if next nibble is low, r4=255 if next nibble is high
                   
0B5A: 54 7F        decomp: anl      a, #0x7F
0B5C: F8                    mov     r0, a           ;r0 counts which word
0B5D: 20 D1 03              jb      psw.1, decomp1  ;avoid leading space if fir
0B60: 12 00 74              lcall   space
0B63: C2 D1        decomp1:clr      psw.1
0B65: C0 82                 push    dpl
0B67: C0 83                 push    dph
0B69: 90 0B CF              mov     dptr, #words
0B6C: 7C 00                 mov     r4, #0
0B6E: E8                    mov     a, r0
0B6F: 60 07                 jz      dcomp3
                            ;here we must seek past all the words in the table
                            ;that come before the one we're supposed to print
0B71: F9                    mov     r1, a
0B72: 71 BE        dcomp2: acall    get_next_nibble
0B74: 70 FC                 jnz     dcomp2
                            ;when we get here, a word has been skipped... keep 
                            ;this until we're pointing to the correct one
0B76: D9 FA                 djnz    r1, dcomp2
                   dcomp3: ;now we're pointing to the correct word, so all we h
                            ;to do is print it out
0B78: 71 BE                 acall   get_next_nibble
0B7A: 60 3C                 jz      dcomp_end
0B7C: B4 0F 12              cjne    a, #15, dcomp4
                            ;the character is one of the 12 least commonly used
0B7F: 71 BE                 acall   get_next_nibble
0B81: 04                    inc     a
0B82: 83                    movc    a, @a+pc
0B83: 80 1E                 sjmp    dcomp5
0B85: 68 66 77 67 
      79 62 78 76 
      6B 71 6A 7A 
                            .db     "hfwgybxvkqjz"
                   dcomp4: ;the character is one of the 14 most commonly used
0B91: 04                    inc     a
0B92: 83                    movc    a, @a+pc
0B93: 80 0E                 sjmp    dcomp5
0B95: 65 74 61 72 
      6E 69 73 6F 
      6C 75 6D 70 
      64 63                 .db     "etarnisolumpdc"
                   dcomp5: ;decide if it should be uppercase or lowercase
0BA3: A2 D5                 mov     c, psw.5
0BA5: 92 E5                 mov     acc.5, c
0BA7: D2 D5                 setb    psw.5
0BA9: B8 14 02              cjne    r0, #20, dcomp6
0BAC: C2 E5                 clr     acc.5
0BAE: B8 0C 02     dcomp6: cjne     r0, #12, dcomp7
0BB1: C2 E5                 clr     acc.5
0BB3: 12 00 76     dcomp7: lcall    cout
0BB6: 80 C0                 sjmp    dcomp3
                   dcomp_end:
0BB8: D0 83                 pop     dph
0BBA: D0 82                 pop     dpl
0BBC: 61 24                 ajmp    pcstr1
                   
                   get_next_nibble:         ;...and update dptr and r4, of cour
0BBE: E4                    clr     a
0BBF: 93                    movc    a, @a+dptr
0BC0: BC 00 05              cjne    r4, #0, gnn2
0BC3: 7C FF                 mov     r4, #255
0BC5: 54 0F                 anl     a, #00001111b
0BC7: 22                    ret
0BC8: 7C 00        gnn2:    mov     r4, #0
0BCA: A3                    inc     dptr
0BCB: C4                    swap    a
0BCC: 54 0F                 anl     a, #00001111b
0BCE: 22                    ret
                   
                   
                   ;---------------------------------------------------------;
                   ;                                                          ;
                   ;         Here begins the data tables and strings          ;
                   ;                                                          ;
                   ;---------------------------------------------------------;
                   
                   ;this is the dictionary of 128 words used by pcstr.
                   
                   words:
0BCF: 82 90 E8 23 
      86 05 4C F8 
                            .db     0x82, 0x90, 0xE8, 0x23, 0x86, 0x05, 0x4C, 0
0BD7: 44 B3 B0 B1 
      48 5F F0 11 
                            .db     0x44, 0xB3, 0xB0, 0xB1, 0x48, 0x5F, 0xF0, 0
0BDF: 7F A0 15 7F 
      1C 2E D1 40 
                            .db     0x7F, 0xA0, 0x15, 0x7F, 0x1C, 0x2E, 0xD1, 0
0BE7: 5A 50 F1 03 
      BF BA 0C 2F 
                            .db     0x5A, 0x50, 0xF1, 0x03, 0xBF, 0xBA, 0x0C, 0
0BEF: 96 01 8D 3F 
      95 38 0D 6F 
                            .db     0x96, 0x01, 0x8D, 0x3F, 0x95, 0x38, 0x0D, 0
0BF7: 5F 12 07 71 
      0E 56 2F 48 
                            .db     0x5F, 0x12, 0x07, 0x71, 0x0E, 0x56, 0x2F, 0
0BFF: 3B 62 58 20 
      1F 76 70 32 
                            .db     0x3B, 0x62, 0x58, 0x20, 0x1F, 0x76, 0x70, 0
0C07: 24 40 B8 40 
      E1 61 8F 01 
                            .db     0x24, 0x40, 0xB8, 0x40, 0xE1, 0x61, 0x8F, 0
0C0F: 34 0B CA 89 
      D3 C0 A3 B9 
                            .db     0x34, 0x0B, 0xCA, 0x89, 0xD3, 0xC0, 0xA3, 0
0C17: 58 80 04 F8 
      02 85 60 25 
                            .db     0x58, 0x80, 0x04, 0xF8, 0x02, 0x85, 0x60, 0
0C1F: 91 F0 92 73 
      1F 10 7F 12 
                            .db     0x91, 0xF0, 0x92, 0x73, 0x1F, 0x10, 0x7F, 0
0C27: 54 93 10 44 
      48 07 D1 26 
                            .db     0x54, 0x93, 0x10, 0x44, 0x48, 0x07, 0xD1, 0
0C2F: 56 4F D0 F6 
      64 72 E0 B8 
                            .db     0x56, 0x4F, 0xD0, 0xF6, 0x64, 0x72, 0xE0, 0
0C37: 3B D5 F0 16 
      4F 56 30 6F 
                            .db     0x3B, 0xD5, 0xF0, 0x16, 0x4F, 0x56, 0x30, 0
0C3F: 48 02 5F A8 
      20 1F 01 76 
                            .db     0x48, 0x02, 0x5F, 0xA8, 0x20, 0x1F, 0x01, 0
0C47: 30 D5 60 25 
      41 A4 2C 60 
                            .db     0x30, 0xD5, 0x60, 0x25, 0x41, 0xA4, 0x2C, 0
0C4F: 05 6F 01 3F 
      26 1F 30 07 
                            .db     0x05, 0x6F, 0x01, 0x3F, 0x26, 0x1F, 0x30, 0
0C57: 8E 1D F0 63 
      99 F0 42 B8 
                            .db     0x8E, 0x1D, 0xF0, 0x63, 0x99, 0xF0, 0x42, 0
0C5F: 20 1F 23 30 
      02 7A D1 60 
                            .db     0x20, 0x1F, 0x23, 0x30, 0x02, 0x7A, 0xD1, 0
0C67: 2F F0 F6 05 
      8F 93 1A 50 
                            .db     0x2F, 0xF0, 0xF6, 0x05, 0x8F, 0x93, 0x1A, 0
0C6F: 28 F0 82 04 
      6F A3 0D 3F 
                            .db     0x28, 0xF0, 0x82, 0x04, 0x6F, 0xA3, 0x0D, 0
0C77: 1F 51 40 23 
      01 3E 05 43 
                            .db     0x1F, 0x51, 0x40, 0x23, 0x01, 0x3E, 0x05, 0
0C7F: 01 7A 01 17 
      64 93 30 2A 
                            .db     0x01, 0x7A, 0x01, 0x17, 0x64, 0x93, 0x30, 0
0C87: 08 8C 24 30 
      99 B0 F3 19 
                            .db     0x08, 0x8C, 0x24, 0x30, 0x99, 0xB0, 0xF3, 0
0C8F: 60 25 41 35 
      09 8E CB 19 
                            .db     0x60, 0x25, 0x41, 0x35, 0x09, 0x8E, 0xCB, 0
0C97: 12 30 05 1F 
      31 1D 04 14 
                            .db     0x12, 0x30, 0x05, 0x1F, 0x31, 0x1D, 0x04, 0
0C9F: 4F 76 12 04 
      AB 27 90 56 
                            .db     0x4F, 0x76, 0x12, 0x04, 0xAB, 0x27, 0x90, 0
0CA7: 01 2F A8 D5 
      F0 AA 26 20 
                            .db     0x01, 0x2F, 0xA8, 0xD5, 0xF0, 0xAA, 0x26, 0
0CAF: 5F 1C F0 F3 
      61 FE 01 41 
                            .db     0x5F, 0x1C, 0xF0, 0xF3, 0x61, 0xFE, 0x01, 0
0CB7: 73 01 27 C1 
      C0 84 8F D6 
                            .db     0x73, 0x01, 0x27, 0xC1, 0xC0, 0x84, 0x8F, 0
0CBF: 01 87 70 56 
      4F 19 70 1F 
                            .db     0x01, 0x87, 0x70, 0x56, 0x4F, 0x19, 0x70, 0
0CC7: A8 D9 90 76 
      02 17 43 FE 
                            .db     0xA8, 0xD9, 0x90, 0x76, 0x02, 0x17, 0x43, 0
0CCF: 01 C1 84 0B 
      15 7F 02 8B 
                            .db     0x01, 0xC1, 0x84, 0x0B, 0x15, 0x7F, 0x02, 0
0CD7: 14 30 8F 63 
      39 6F 19 F0 
                            .db     0x14, 0x30, 0x8F, 0x63, 0x39, 0x6F, 0x19, 0
0CDF: 11 C9 10 6D 
      02 3F 91 09 
                            .db     0x11, 0xC9, 0x10, 0x6D, 0x02, 0x3F, 0x91, 0
0CE7: 7A 41 D0 BA 
      0C 1D 39 5F 
                            .db     0x7A, 0x41, 0xD0, 0xBA, 0x0C, 0x1D, 0x39, 0
0CEF: 07 F2 11 17 
      20 41 6B 35 
                            .db     0x07, 0xF2, 0x11, 0x17, 0x20, 0x41, 0x6B, 0
0CF7: 09 F7 75 12 
      0B A7 CC 48 
                            .db     0x09, 0xF7, 0x75, 0x12, 0x0B, 0xA7, 0xCC, 0
0CFF: 02 3F 64 12 
      A0 0C 27 E3 
                            .db     0x02, 0x3F, 0x64, 0x12, 0xA0, 0x0C, 0x27, 0
0D07: 9F C0 14 77 
      70 11 40 71 
                            .db     0x9F, 0xC0, 0x14, 0x77, 0x70, 0x11, 0x40, 0
0D0F: 21 C0 68 25 
      41 F0 62 7F 
                            .db     0x21, 0xC0, 0x68, 0x25, 0x41, 0xF0, 0x62, 0
0D17: D1 D0 21 E1 
      62 58 B0 F3 
                            .db     0xD1, 0xD0, 0x21, 0xE1, 0x62, 0x58, 0xB0, 0
0D1F: 05 1F 73 30 
      77 B1 6F 19 
                            .db     0x05, 0x1F, 0x73, 0x30, 0x77, 0xB1, 0x6F, 0
0D27: E0 19 43 E0 
      58 2F F6 A4 
                            .db     0xE0, 0x19, 0x43, 0xE0, 0x58, 0x2F, 0xF6, 0
0D2F: 14 D0 23 03 
      FE 31 F5 14 
                            .db     0x14, 0xD0, 0x23, 0x03, 0xFE, 0x31, 0xF5, 0
0D37: 30 99 F8 03 
      3F 64 22 51 
                            .db     0x30, 0x99, 0xF8, 0x03, 0x3F, 0x64, 0x22, 0
0D3F: 60 25 41 2F 
      E3 01 56 27 
                            .db     0x60, 0x25, 0x41, 0x2F, 0xE3, 0x01, 0x56, 0
0D47: 93 09 FE 11 
      FE 79 BA 60 
                            .db     0x93, 0x09, 0xFE, 0x11, 0xFE, 0x79, 0xBA, 0
0D4F: 75 42 EA 62 
      58 A0 E5 1F 
                            .db     0x75, 0x42, 0xEA, 0x62, 0x58, 0xA0, 0xE5, 0
0D57: 53 4F D1 C0 
      A3 09 42 53 
                            .db     0x53, 0x4F, 0xD1, 0xC0, 0xA3, 0x09, 0x42, 0
0D5F: F7 12 04 62 
      1B 30 F5 05 
                            .db     0xF7, 0x12, 0x04, 0x62, 0x1B, 0x30, 0xF5, 0
0D67: F7 69 0C 35 
      1B 70 82 2F 
                            .db     0xF7, 0x69, 0x0C, 0x35, 0x1B, 0x70, 0x82, 0
0D6F: 2F 14 4F 51 
      C0 64 25 00 
                            .db     0x2F, 0x14, 0x4F, 0x51, 0xC0, 0x64, 0x25, 0
                   
                   ;STR
                   
0D77: 57 65 6C 63 
      6F 6D 65 80 
      94 32 20 76 
      32 2E 31 2C 
      20 62 79 1F 
      F8 1F FE 0D 
      0E           logon1: .db      "Welcome",128,148,"2 v2.1, by",31,248,31,25
0D90: 20 20 53 65 
      65 94 32 2E 
      44 4F 43 2C 
      94 32 2E 45 
      51 55 A4     logon2: .db      32,32,"See",148,"2.DOC,",148,"2.EQU",164
0DA3: 94 32 2E 48 
      44 52 B4 D5 
      8D 2E 0E              .db     148,"2.HDR",180,213,141,".",14
0DAE: 20 1F 9E 1F 
      A0 21 0D 0E 
                   abort:   .db     " ",31,158,31,160,"!",13,14
0DB6: 94 32 20 4C 
      6F 63 3A 00 
                   prompt1:.db      148,"2 Loc:",0
0DBE: 20 3E A0     prompt2:.db      " >", 160       ;must follow after prompt1
0DC1: 86 CA 82 28 
      00           prompt3:.db      134,202,130,'(',0
0DC6: 29 2C 95 8C 
      80 C8 3A 20 
      00           prompt4:.db      "),",149,140,128,200,": ",0
0DCF: 1F 97 82 C3 
      73 C7 A6 83 
      2C           prompt5:.db      31,151,130,195,"s",199,166,131,","
0DD8: BA 20 4A 55 
      4D 50 80 86 
      A1 72 82 0D 
      0E                    .db     186," JUMP",128,134,161,"r",130,13,14
0DE5: 0D 0D 1F 87 
      83 81 3A 20 
      00           prompt6:.db      13,13,31,135,131,129,": ",0
0DEE: 1F E4 FB 20 
      6B 65 79 3A 
      20 00        prompt7:.db      31,228,251," key: ",0
0DF8: 0D 0D 1F 88 
      80 83 81 20 
      28 00        prompt8:.db      13,13,31,136,128,131,129," (",0
0E02: 0D 0D 1F 82 
      1F FD 00     prompt9:.db      13,13,31,130,31,253,0
0E09: 1F 81 20 20 
      20 20 20 1F 
      C9 0E        prompt9b:.db      31,129,32,32,32,32,32,31,201,14        ;mu
0E13: 29 20 1F 87 
      1F B2 3A 20 
      00           prompt10:.db     ") ",31,135,31,178,": ",0
0E1C: 46 69 72 73 
      74 1F 81 3A 
      20 00        beg_str:.db      "First",31,129,": ",0
0E26: 4C 61 73 74 
      1F 81 3A 20 
      20 00        end_str:.db      "Last",31,129,":",32,32,0
0E30: 1F B9 A1 20 
      73 75 72 65 
      3F 00        sure:    .db     31,185,161," sure?",0
0E3A: 0D 0D 1F 9C 
      9A 92 2C 8C 
      80 C8 0E     edits1: .db      13,13,31,156,154,146,",",140,128,200,14
0E45: 20 20 1F 9C 
      C1 2C 8E 81 
      F7 0D 0E     edits2: .db      "  ",31,156,193,",",142,129,247,13,14
0E50: 0D 0D 1F 9F 
      20 61 73 63 
      69 69 F9 96 
      1F 98 84 89 
                   dnlds1: .db      13,13,31,159," ascii",249,150,31,152,132,13
0E60: 2C 95 8C 80 
      A0 0D 0E              .db     ",",149,140,128,160,13,14
0E67: 0D 1F 8A A0 
      65 64 0D 0E 
                   dnlds2: .db      13,31,138,160,"ed",13,14
0E6F: 0D 1F 8A C1 
      64 0D 0E     dnlds3: .db      13,31,138,193,"d",13,14
0E76: 53 75 6D 6D 
      61 72 79 3A 
      0E           dnlds4: .db      "Summary:",14
0E7F: 20 C6 73 91 
      64 0E        dnlds5: .db      " ",198,"s",145,"d",14
0E85: 20 8B 91 64 
      0E           dnlds6a:.db      " ",139,145,"d",14
0E8A: 20 8B 20 77 
      72 69 74 74 
      65 6E 0E     dnlds6b:.db      " ",139," written",14
0E95: 1F 9B 3A 0E 
                   dnlds7: .db      31,155,":",14
0E99: 20 8B 20 75 
      6E 61 62 6C 
      65 80 20 77 
      72 69 74 65 
      0E           dnlds8: .db      " ",139," unable",128," write",14
0EAA: 20 20 62 61 
      64 F5 73 0E 
                   dnlds9: .db      32,32,"bad",245,"s",14
0EB2: 20 85 9F 96 
      C6 0E        dnlds10:.db      " ",133,159,150,198,14
0EB8: 20 85 84 9D 
      0E           dnlds11:.db      " ",133,132,157,14
0EBD: 20 85 20 6E 
      6F 6E 84 9D 
      0E           dnlds12:.db      " ",133," non",132,157,14
0EC6: 1F 97 9B 20 
      64 65 74 65 
      63 74 65 64 
      0D 0E        dnlds13:.db      31,151,155," detected",13,14
0ED4: 0D 86 6E 69 
      6E 67 82 3A 
      0D 0E        runs1:   .db     13,134,"ning",130,":",13,14
0EDE: 0D 0D 53 65 
      6E 64 69 6E 
      67 1F 98 84 
      89 AC 20 20 
      00           uplds3: .db      13,13,"Sending",31,152,132,137,172,32,32,0
0EEF: 20 80 20 20 
      00           uplds4: .db      " ",128,32,32,0                 ;must follo
0EF4: 0D 0D 53 74 
      61 6E 64 61 
      72 64 1F 9E 
      73 0E        help1txt:.db     13,13,"Standard",31,158,"s",14
0F02: 1F DA 1F F4 
      65 64 1F 9E 
      73 0E        help2txt:.db     31,218,31,244,"ed",31,158,"s",14
0F0C: 1F 9A 9E 00 
                   type1:   .db     31,154,158,0
0F10: 1F 82 00     type2:   .db     31,130,0
0F13: 1F 8F 1F E2 
      1F AA 00     type4:   .db     31,143,31,226,31,170,0
0F1A: 3F 3F 3F 00 
                   type5:   .db     "???",0
0F1E: 1F D7 00     help_cmd2:.db    31,215,0
0F21: 1F 8E D7 D1 
      00           help_cmd: .db    31,142,215,209,0        ;these 11 _cmd stri
0F26: 1F D1 82 73 
      00           dir_cmd:  .db    31,209,130,"s",0
0F2B: 1F 86 82 00 
                   run_cmd:  .db    31,134,130,0
0F2F: 1F 8A 00     dnld_cmd: .db    31,138,0
0F32: 1F 93 00     upld_cmd: .db    31,147,0
0F35: 1F 87 81 00 
                   nloc_cmd: .db    31,135,129,0
0F39: 1F 88 80 83 
      81 00        jump_cmd: .db    31,136,128,131,129,0
0F3F: 1F 84 DB 9A 
      83 00        dump_cmd: .db    31,132,219,154,131,0
0F45: 1F 84 DB C0 
      83 00        intm_cmd: .db    31,132,219,192,131,0
0F4B: 1F 9C 9A 92 
      00           edit_cmd: .db    31,156,154,146,0
0F50: 1F ED 83 00 
                   clrm_cmd: .db    31,237,131,0
0F54: 1F CB 99 90 
      00           erfr_cmd: .db    31,203,153,144,0
0F59: 1F 99 90 CB 
      64 0D 0E     erfr_ok:  .db    31,153,144,203,'d',13,14
0F60: 1F 85 9B 0D 
      0E           erfr_err: .db    31,133,155,13,14
                   
                   
